/*
 * Google Analytics API
 * Views and manages your Google Analytics data.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ExperimentParentLink;
import org.openapitools.client.model.ExperimentVariationsInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JSON template for Analytics experiment resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:01:26.696972-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Experiment {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private String accountId;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_EDITABLE_IN_GA_UI = "editableInGaUi";
  @SerializedName(SERIALIZED_NAME_EDITABLE_IN_GA_UI)
  private Boolean editableInGaUi;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private OffsetDateTime endTime;

  public static final String SERIALIZED_NAME_EQUAL_WEIGHTING = "equalWeighting";
  @SerializedName(SERIALIZED_NAME_EQUAL_WEIGHTING)
  private Boolean equalWeighting;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_INTERNAL_WEB_PROPERTY_ID = "internalWebPropertyId";
  @SerializedName(SERIALIZED_NAME_INTERNAL_WEB_PROPERTY_ID)
  private String internalWebPropertyId;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind = "analytics#experiment";

  public static final String SERIALIZED_NAME_MINIMUM_EXPERIMENT_LENGTH_IN_DAYS = "minimumExperimentLengthInDays";
  @SerializedName(SERIALIZED_NAME_MINIMUM_EXPERIMENT_LENGTH_IN_DAYS)
  private Integer minimumExperimentLengthInDays;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OBJECTIVE_METRIC = "objectiveMetric";
  @SerializedName(SERIALIZED_NAME_OBJECTIVE_METRIC)
  private String objectiveMetric;

  public static final String SERIALIZED_NAME_OPTIMIZATION_TYPE = "optimizationType";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_TYPE)
  private String optimizationType;

  public static final String SERIALIZED_NAME_PARENT_LINK = "parentLink";
  @SerializedName(SERIALIZED_NAME_PARENT_LINK)
  private ExperimentParentLink parentLink;

  public static final String SERIALIZED_NAME_PROFILE_ID = "profileId";
  @SerializedName(SERIALIZED_NAME_PROFILE_ID)
  private String profileId;

  public static final String SERIALIZED_NAME_REASON_EXPERIMENT_ENDED = "reasonExperimentEnded";
  @SerializedName(SERIALIZED_NAME_REASON_EXPERIMENT_ENDED)
  private String reasonExperimentEnded;

  public static final String SERIALIZED_NAME_REWRITE_VARIATION_URLS_AS_ORIGINAL = "rewriteVariationUrlsAsOriginal";
  @SerializedName(SERIALIZED_NAME_REWRITE_VARIATION_URLS_AS_ORIGINAL)
  private Boolean rewriteVariationUrlsAsOriginal;

  public static final String SERIALIZED_NAME_SELF_LINK = "selfLink";
  @SerializedName(SERIALIZED_NAME_SELF_LINK)
  private String selfLink;

  public static final String SERIALIZED_NAME_SERVING_FRAMEWORK = "servingFramework";
  @SerializedName(SERIALIZED_NAME_SERVING_FRAMEWORK)
  private String servingFramework;

  public static final String SERIALIZED_NAME_SNIPPET = "snippet";
  @SerializedName(SERIALIZED_NAME_SNIPPET)
  private String snippet;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_TRAFFIC_COVERAGE = "trafficCoverage";
  @SerializedName(SERIALIZED_NAME_TRAFFIC_COVERAGE)
  private Double trafficCoverage;

  public static final String SERIALIZED_NAME_UPDATED = "updated";
  @SerializedName(SERIALIZED_NAME_UPDATED)
  private OffsetDateTime updated;

  public static final String SERIALIZED_NAME_VARIATIONS = "variations";
  @SerializedName(SERIALIZED_NAME_VARIATIONS)
  private List<ExperimentVariationsInner> variations = new ArrayList<>();

  public static final String SERIALIZED_NAME_WEB_PROPERTY_ID = "webPropertyId";
  @SerializedName(SERIALIZED_NAME_WEB_PROPERTY_ID)
  private String webPropertyId;

  public static final String SERIALIZED_NAME_WINNER_CONFIDENCE_LEVEL = "winnerConfidenceLevel";
  @SerializedName(SERIALIZED_NAME_WINNER_CONFIDENCE_LEVEL)
  private Double winnerConfidenceLevel;

  public static final String SERIALIZED_NAME_WINNER_FOUND = "winnerFound";
  @SerializedName(SERIALIZED_NAME_WINNER_FOUND)
  private Boolean winnerFound;

  public Experiment() {
  }

  public Experiment accountId(String accountId) {
    this.accountId = accountId;
    return this;
  }

  /**
   * Account ID to which this experiment belongs. This field is read-only.
   * @return accountId
   */
  @javax.annotation.Nullable
  public String getAccountId() {
    return accountId;
  }

  public void setAccountId(String accountId) {
    this.accountId = accountId;
  }


  public Experiment created(OffsetDateTime created) {
    this.created = created;
    return this;
  }

  /**
   * Time the experiment was created. This field is read-only.
   * @return created
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreated() {
    return created;
  }

  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public Experiment description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Notes about this experiment.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Experiment editableInGaUi(Boolean editableInGaUi) {
    this.editableInGaUi = editableInGaUi;
    return this;
  }

  /**
   * If true, the end user will be able to edit the experiment via the Google Analytics user interface.
   * @return editableInGaUi
   */
  @javax.annotation.Nullable
  public Boolean getEditableInGaUi() {
    return editableInGaUi;
  }

  public void setEditableInGaUi(Boolean editableInGaUi) {
    this.editableInGaUi = editableInGaUi;
  }


  public Experiment endTime(OffsetDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * The ending time of the experiment (the time the status changed from RUNNING to ENDED). This field is present only if the experiment has ended. This field is read-only.
   * @return endTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(OffsetDateTime endTime) {
    this.endTime = endTime;
  }


  public Experiment equalWeighting(Boolean equalWeighting) {
    this.equalWeighting = equalWeighting;
    return this;
  }

  /**
   * Boolean specifying whether to distribute traffic evenly across all variations. If the value is False, content experiments follows the default behavior of adjusting traffic dynamically based on variation performance. Optional -- defaults to False. This field may not be changed for an experiment whose status is ENDED.
   * @return equalWeighting
   */
  @javax.annotation.Nullable
  public Boolean getEqualWeighting() {
    return equalWeighting;
  }

  public void setEqualWeighting(Boolean equalWeighting) {
    this.equalWeighting = equalWeighting;
  }


  public Experiment id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Experiment ID. Required for patch and update. Disallowed for create.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Experiment internalWebPropertyId(String internalWebPropertyId) {
    this.internalWebPropertyId = internalWebPropertyId;
    return this;
  }

  /**
   * Internal ID for the web property to which this experiment belongs. This field is read-only.
   * @return internalWebPropertyId
   */
  @javax.annotation.Nullable
  public String getInternalWebPropertyId() {
    return internalWebPropertyId;
  }

  public void setInternalWebPropertyId(String internalWebPropertyId) {
    this.internalWebPropertyId = internalWebPropertyId;
  }


  public Experiment kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Resource type for an Analytics experiment. This field is read-only.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Experiment minimumExperimentLengthInDays(Integer minimumExperimentLengthInDays) {
    this.minimumExperimentLengthInDays = minimumExperimentLengthInDays;
    return this;
  }

  /**
   * An integer number in [3, 90]. Specifies the minimum length of the experiment. Can be changed for a running experiment. This field may not be changed for an experiments whose status is ENDED.
   * @return minimumExperimentLengthInDays
   */
  @javax.annotation.Nullable
  public Integer getMinimumExperimentLengthInDays() {
    return minimumExperimentLengthInDays;
  }

  public void setMinimumExperimentLengthInDays(Integer minimumExperimentLengthInDays) {
    this.minimumExperimentLengthInDays = minimumExperimentLengthInDays;
  }


  public Experiment name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Experiment name. This field may not be changed for an experiment whose status is ENDED. This field is required when creating an experiment.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Experiment objectiveMetric(String objectiveMetric) {
    this.objectiveMetric = objectiveMetric;
    return this;
  }

  /**
   * The metric that the experiment is optimizing. Valid values: \&quot;ga:goal(n)Completions\&quot;, \&quot;ga:adsenseAdsClicks\&quot;, \&quot;ga:adsenseAdsViewed\&quot;, \&quot;ga:adsenseRevenue\&quot;, \&quot;ga:bounces\&quot;, \&quot;ga:pageviews\&quot;, \&quot;ga:sessionDuration\&quot;, \&quot;ga:transactions\&quot;, \&quot;ga:transactionRevenue\&quot;. This field is required if status is \&quot;RUNNING\&quot; and servingFramework is one of \&quot;REDIRECT\&quot; or \&quot;API\&quot;.
   * @return objectiveMetric
   */
  @javax.annotation.Nullable
  public String getObjectiveMetric() {
    return objectiveMetric;
  }

  public void setObjectiveMetric(String objectiveMetric) {
    this.objectiveMetric = objectiveMetric;
  }


  public Experiment optimizationType(String optimizationType) {
    this.optimizationType = optimizationType;
    return this;
  }

  /**
   * Whether the objectiveMetric should be minimized or maximized. Possible values: \&quot;MAXIMUM\&quot;, \&quot;MINIMUM\&quot;. Optional--defaults to \&quot;MAXIMUM\&quot;. Cannot be specified without objectiveMetric. Cannot be modified when status is \&quot;RUNNING\&quot; or \&quot;ENDED\&quot;.
   * @return optimizationType
   */
  @javax.annotation.Nullable
  public String getOptimizationType() {
    return optimizationType;
  }

  public void setOptimizationType(String optimizationType) {
    this.optimizationType = optimizationType;
  }


  public Experiment parentLink(ExperimentParentLink parentLink) {
    this.parentLink = parentLink;
    return this;
  }

  /**
   * Get parentLink
   * @return parentLink
   */
  @javax.annotation.Nullable
  public ExperimentParentLink getParentLink() {
    return parentLink;
  }

  public void setParentLink(ExperimentParentLink parentLink) {
    this.parentLink = parentLink;
  }


  public Experiment profileId(String profileId) {
    this.profileId = profileId;
    return this;
  }

  /**
   * View (Profile) ID to which this experiment belongs. This field is read-only.
   * @return profileId
   */
  @javax.annotation.Nullable
  public String getProfileId() {
    return profileId;
  }

  public void setProfileId(String profileId) {
    this.profileId = profileId;
  }


  public Experiment reasonExperimentEnded(String reasonExperimentEnded) {
    this.reasonExperimentEnded = reasonExperimentEnded;
    return this;
  }

  /**
   * Why the experiment ended. Possible values: \&quot;STOPPED_BY_USER\&quot;, \&quot;WINNER_FOUND\&quot;, \&quot;EXPERIMENT_EXPIRED\&quot;, \&quot;ENDED_WITH_NO_WINNER\&quot;, \&quot;GOAL_OBJECTIVE_CHANGED\&quot;. \&quot;ENDED_WITH_NO_WINNER\&quot; means that the experiment didn&#39;t expire but no winner was projected to be found. If the experiment status is changed via the API to ENDED this field is set to STOPPED_BY_USER. This field is read-only.
   * @return reasonExperimentEnded
   */
  @javax.annotation.Nullable
  public String getReasonExperimentEnded() {
    return reasonExperimentEnded;
  }

  public void setReasonExperimentEnded(String reasonExperimentEnded) {
    this.reasonExperimentEnded = reasonExperimentEnded;
  }


  public Experiment rewriteVariationUrlsAsOriginal(Boolean rewriteVariationUrlsAsOriginal) {
    this.rewriteVariationUrlsAsOriginal = rewriteVariationUrlsAsOriginal;
    return this;
  }

  /**
   * Boolean specifying whether variations URLS are rewritten to match those of the original. This field may not be changed for an experiments whose status is ENDED.
   * @return rewriteVariationUrlsAsOriginal
   */
  @javax.annotation.Nullable
  public Boolean getRewriteVariationUrlsAsOriginal() {
    return rewriteVariationUrlsAsOriginal;
  }

  public void setRewriteVariationUrlsAsOriginal(Boolean rewriteVariationUrlsAsOriginal) {
    this.rewriteVariationUrlsAsOriginal = rewriteVariationUrlsAsOriginal;
  }


  public Experiment selfLink(String selfLink) {
    this.selfLink = selfLink;
    return this;
  }

  /**
   * Link for this experiment. This field is read-only.
   * @return selfLink
   */
  @javax.annotation.Nullable
  public String getSelfLink() {
    return selfLink;
  }

  public void setSelfLink(String selfLink) {
    this.selfLink = selfLink;
  }


  public Experiment servingFramework(String servingFramework) {
    this.servingFramework = servingFramework;
    return this;
  }

  /**
   * The framework used to serve the experiment variations and evaluate the results. One of:   - REDIRECT: Google Analytics redirects traffic to different variation pages, reports the chosen variation and evaluates the results. - API: Google Analytics chooses and reports the variation to serve and evaluates the results; the caller is responsible for serving the selected variation. - EXTERNAL: The variations will be served externally and the chosen variation reported to Google Analytics. The caller is responsible for serving the selected variation and evaluating the results.
   * @return servingFramework
   */
  @javax.annotation.Nullable
  public String getServingFramework() {
    return servingFramework;
  }

  public void setServingFramework(String servingFramework) {
    this.servingFramework = servingFramework;
  }


  public Experiment snippet(String snippet) {
    this.snippet = snippet;
    return this;
  }

  /**
   * The snippet of code to include on the control page(s). This field is read-only.
   * @return snippet
   */
  @javax.annotation.Nullable
  public String getSnippet() {
    return snippet;
  }

  public void setSnippet(String snippet) {
    this.snippet = snippet;
  }


  public Experiment startTime(OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * The starting time of the experiment (the time the status changed from READY_TO_RUN to RUNNING). This field is present only if the experiment has started. This field is read-only.
   * @return startTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public Experiment status(String status) {
    this.status = status;
    return this;
  }

  /**
   * Experiment status. Possible values: \&quot;DRAFT\&quot;, \&quot;READY_TO_RUN\&quot;, \&quot;RUNNING\&quot;, \&quot;ENDED\&quot;. Experiments can be created in the \&quot;DRAFT\&quot;, \&quot;READY_TO_RUN\&quot; or \&quot;RUNNING\&quot; state. This field is required when creating an experiment.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public Experiment trafficCoverage(Double trafficCoverage) {
    this.trafficCoverage = trafficCoverage;
    return this;
  }

  /**
   * A floating-point number in (0, 1]. Specifies the fraction of the traffic that participates in the experiment. Can be changed for a running experiment. This field may not be changed for an experiments whose status is ENDED.
   * @return trafficCoverage
   */
  @javax.annotation.Nullable
  public Double getTrafficCoverage() {
    return trafficCoverage;
  }

  public void setTrafficCoverage(Double trafficCoverage) {
    this.trafficCoverage = trafficCoverage;
  }


  public Experiment updated(OffsetDateTime updated) {
    this.updated = updated;
    return this;
  }

  /**
   * Time the experiment was last modified. This field is read-only.
   * @return updated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdated() {
    return updated;
  }

  public void setUpdated(OffsetDateTime updated) {
    this.updated = updated;
  }


  public Experiment variations(List<ExperimentVariationsInner> variations) {
    this.variations = variations;
    return this;
  }

  public Experiment addVariationsItem(ExperimentVariationsInner variationsItem) {
    if (this.variations == null) {
      this.variations = new ArrayList<>();
    }
    this.variations.add(variationsItem);
    return this;
  }

  /**
   * Array of variations. The first variation in the array is the original. The number of variations may not change once an experiment is in the RUNNING state. At least two variations are required before status can be set to RUNNING.
   * @return variations
   */
  @javax.annotation.Nullable
  public List<ExperimentVariationsInner> getVariations() {
    return variations;
  }

  public void setVariations(List<ExperimentVariationsInner> variations) {
    this.variations = variations;
  }


  public Experiment webPropertyId(String webPropertyId) {
    this.webPropertyId = webPropertyId;
    return this;
  }

  /**
   * Web property ID to which this experiment belongs. The web property ID is of the form UA-XXXXX-YY. This field is read-only.
   * @return webPropertyId
   */
  @javax.annotation.Nullable
  public String getWebPropertyId() {
    return webPropertyId;
  }

  public void setWebPropertyId(String webPropertyId) {
    this.webPropertyId = webPropertyId;
  }


  public Experiment winnerConfidenceLevel(Double winnerConfidenceLevel) {
    this.winnerConfidenceLevel = winnerConfidenceLevel;
    return this;
  }

  /**
   * A floating-point number in (0, 1). Specifies the necessary confidence level to choose a winner. This field may not be changed for an experiments whose status is ENDED.
   * @return winnerConfidenceLevel
   */
  @javax.annotation.Nullable
  public Double getWinnerConfidenceLevel() {
    return winnerConfidenceLevel;
  }

  public void setWinnerConfidenceLevel(Double winnerConfidenceLevel) {
    this.winnerConfidenceLevel = winnerConfidenceLevel;
  }


  public Experiment winnerFound(Boolean winnerFound) {
    this.winnerFound = winnerFound;
    return this;
  }

  /**
   * Boolean specifying whether a winner has been found for this experiment. This field is read-only.
   * @return winnerFound
   */
  @javax.annotation.Nullable
  public Boolean getWinnerFound() {
    return winnerFound;
  }

  public void setWinnerFound(Boolean winnerFound) {
    this.winnerFound = winnerFound;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Experiment experiment = (Experiment) o;
    return Objects.equals(this.accountId, experiment.accountId) &&
        Objects.equals(this.created, experiment.created) &&
        Objects.equals(this.description, experiment.description) &&
        Objects.equals(this.editableInGaUi, experiment.editableInGaUi) &&
        Objects.equals(this.endTime, experiment.endTime) &&
        Objects.equals(this.equalWeighting, experiment.equalWeighting) &&
        Objects.equals(this.id, experiment.id) &&
        Objects.equals(this.internalWebPropertyId, experiment.internalWebPropertyId) &&
        Objects.equals(this.kind, experiment.kind) &&
        Objects.equals(this.minimumExperimentLengthInDays, experiment.minimumExperimentLengthInDays) &&
        Objects.equals(this.name, experiment.name) &&
        Objects.equals(this.objectiveMetric, experiment.objectiveMetric) &&
        Objects.equals(this.optimizationType, experiment.optimizationType) &&
        Objects.equals(this.parentLink, experiment.parentLink) &&
        Objects.equals(this.profileId, experiment.profileId) &&
        Objects.equals(this.reasonExperimentEnded, experiment.reasonExperimentEnded) &&
        Objects.equals(this.rewriteVariationUrlsAsOriginal, experiment.rewriteVariationUrlsAsOriginal) &&
        Objects.equals(this.selfLink, experiment.selfLink) &&
        Objects.equals(this.servingFramework, experiment.servingFramework) &&
        Objects.equals(this.snippet, experiment.snippet) &&
        Objects.equals(this.startTime, experiment.startTime) &&
        Objects.equals(this.status, experiment.status) &&
        Objects.equals(this.trafficCoverage, experiment.trafficCoverage) &&
        Objects.equals(this.updated, experiment.updated) &&
        Objects.equals(this.variations, experiment.variations) &&
        Objects.equals(this.webPropertyId, experiment.webPropertyId) &&
        Objects.equals(this.winnerConfidenceLevel, experiment.winnerConfidenceLevel) &&
        Objects.equals(this.winnerFound, experiment.winnerFound);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, created, description, editableInGaUi, endTime, equalWeighting, id, internalWebPropertyId, kind, minimumExperimentLengthInDays, name, objectiveMetric, optimizationType, parentLink, profileId, reasonExperimentEnded, rewriteVariationUrlsAsOriginal, selfLink, servingFramework, snippet, startTime, status, trafficCoverage, updated, variations, webPropertyId, winnerConfidenceLevel, winnerFound);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Experiment {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    editableInGaUi: ").append(toIndentedString(editableInGaUi)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    equalWeighting: ").append(toIndentedString(equalWeighting)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    internalWebPropertyId: ").append(toIndentedString(internalWebPropertyId)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    minimumExperimentLengthInDays: ").append(toIndentedString(minimumExperimentLengthInDays)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    objectiveMetric: ").append(toIndentedString(objectiveMetric)).append("\n");
    sb.append("    optimizationType: ").append(toIndentedString(optimizationType)).append("\n");
    sb.append("    parentLink: ").append(toIndentedString(parentLink)).append("\n");
    sb.append("    profileId: ").append(toIndentedString(profileId)).append("\n");
    sb.append("    reasonExperimentEnded: ").append(toIndentedString(reasonExperimentEnded)).append("\n");
    sb.append("    rewriteVariationUrlsAsOriginal: ").append(toIndentedString(rewriteVariationUrlsAsOriginal)).append("\n");
    sb.append("    selfLink: ").append(toIndentedString(selfLink)).append("\n");
    sb.append("    servingFramework: ").append(toIndentedString(servingFramework)).append("\n");
    sb.append("    snippet: ").append(toIndentedString(snippet)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    trafficCoverage: ").append(toIndentedString(trafficCoverage)).append("\n");
    sb.append("    updated: ").append(toIndentedString(updated)).append("\n");
    sb.append("    variations: ").append(toIndentedString(variations)).append("\n");
    sb.append("    webPropertyId: ").append(toIndentedString(webPropertyId)).append("\n");
    sb.append("    winnerConfidenceLevel: ").append(toIndentedString(winnerConfidenceLevel)).append("\n");
    sb.append("    winnerFound: ").append(toIndentedString(winnerFound)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountId");
    openapiFields.add("created");
    openapiFields.add("description");
    openapiFields.add("editableInGaUi");
    openapiFields.add("endTime");
    openapiFields.add("equalWeighting");
    openapiFields.add("id");
    openapiFields.add("internalWebPropertyId");
    openapiFields.add("kind");
    openapiFields.add("minimumExperimentLengthInDays");
    openapiFields.add("name");
    openapiFields.add("objectiveMetric");
    openapiFields.add("optimizationType");
    openapiFields.add("parentLink");
    openapiFields.add("profileId");
    openapiFields.add("reasonExperimentEnded");
    openapiFields.add("rewriteVariationUrlsAsOriginal");
    openapiFields.add("selfLink");
    openapiFields.add("servingFramework");
    openapiFields.add("snippet");
    openapiFields.add("startTime");
    openapiFields.add("status");
    openapiFields.add("trafficCoverage");
    openapiFields.add("updated");
    openapiFields.add("variations");
    openapiFields.add("webPropertyId");
    openapiFields.add("winnerConfidenceLevel");
    openapiFields.add("winnerFound");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Experiment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Experiment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Experiment is not found in the empty JSON string", Experiment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Experiment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Experiment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accountId") != null && !jsonObj.get("accountId").isJsonNull()) && !jsonObj.get("accountId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountId").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("internalWebPropertyId") != null && !jsonObj.get("internalWebPropertyId").isJsonNull()) && !jsonObj.get("internalWebPropertyId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `internalWebPropertyId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("internalWebPropertyId").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("objectiveMetric") != null && !jsonObj.get("objectiveMetric").isJsonNull()) && !jsonObj.get("objectiveMetric").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `objectiveMetric` to be a primitive type in the JSON string but got `%s`", jsonObj.get("objectiveMetric").toString()));
      }
      if ((jsonObj.get("optimizationType") != null && !jsonObj.get("optimizationType").isJsonNull()) && !jsonObj.get("optimizationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizationType").toString()));
      }
      // validate the optional field `parentLink`
      if (jsonObj.get("parentLink") != null && !jsonObj.get("parentLink").isJsonNull()) {
        ExperimentParentLink.validateJsonElement(jsonObj.get("parentLink"));
      }
      if ((jsonObj.get("profileId") != null && !jsonObj.get("profileId").isJsonNull()) && !jsonObj.get("profileId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profileId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profileId").toString()));
      }
      if ((jsonObj.get("reasonExperimentEnded") != null && !jsonObj.get("reasonExperimentEnded").isJsonNull()) && !jsonObj.get("reasonExperimentEnded").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reasonExperimentEnded` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reasonExperimentEnded").toString()));
      }
      if ((jsonObj.get("selfLink") != null && !jsonObj.get("selfLink").isJsonNull()) && !jsonObj.get("selfLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selfLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selfLink").toString()));
      }
      if ((jsonObj.get("servingFramework") != null && !jsonObj.get("servingFramework").isJsonNull()) && !jsonObj.get("servingFramework").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `servingFramework` to be a primitive type in the JSON string but got `%s`", jsonObj.get("servingFramework").toString()));
      }
      if ((jsonObj.get("snippet") != null && !jsonObj.get("snippet").isJsonNull()) && !jsonObj.get("snippet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `snippet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("snippet").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (jsonObj.get("variations") != null && !jsonObj.get("variations").isJsonNull()) {
        JsonArray jsonArrayvariations = jsonObj.getAsJsonArray("variations");
        if (jsonArrayvariations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("variations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `variations` to be an array in the JSON string but got `%s`", jsonObj.get("variations").toString()));
          }

          // validate the optional field `variations` (array)
          for (int i = 0; i < jsonArrayvariations.size(); i++) {
            ExperimentVariationsInner.validateJsonElement(jsonArrayvariations.get(i));
          };
        }
      }
      if ((jsonObj.get("webPropertyId") != null && !jsonObj.get("webPropertyId").isJsonNull()) && !jsonObj.get("webPropertyId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webPropertyId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webPropertyId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Experiment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Experiment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Experiment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Experiment.class));

       return (TypeAdapter<T>) new TypeAdapter<Experiment>() {
           @Override
           public void write(JsonWriter out, Experiment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Experiment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Experiment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Experiment
   * @throws IOException if the JSON string is invalid with respect to Experiment
   */
  public static Experiment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Experiment.class);
  }

  /**
   * Convert an instance of Experiment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

