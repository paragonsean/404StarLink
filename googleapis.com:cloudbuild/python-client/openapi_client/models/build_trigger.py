# coding: utf-8

"""
    Cloud Build API

    Creates and manages builds on Google Cloud Platform.

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.approval_config import ApprovalConfig
from openapi_client.models.bitbucket_server_trigger_config import BitbucketServerTriggerConfig
from openapi_client.models.build import Build
from openapi_client.models.git_file_source import GitFileSource
from openapi_client.models.git_hub_events_config import GitHubEventsConfig
from openapi_client.models.git_lab_events_config import GitLabEventsConfig
from openapi_client.models.git_repo_source import GitRepoSource
from openapi_client.models.pubsub_config import PubsubConfig
from openapi_client.models.repo_source import RepoSource
from openapi_client.models.repository_event_config import RepositoryEventConfig
from openapi_client.models.webhook_config import WebhookConfig
from typing import Optional, Set
from typing_extensions import Self

class BuildTrigger(BaseModel):
    """
    Configuration for an automated build in response to source repository changes.
    """ # noqa: E501
    approval_config: Optional[ApprovalConfig] = Field(default=None, alias="approvalConfig")
    autodetect: Optional[StrictBool] = Field(default=None, description="Autodetect build configuration. The following precedence is used (case insensitive): 1. cloudbuild.yaml 2. cloudbuild.yml 3. cloudbuild.json 4. Dockerfile Currently only available for GitHub App Triggers.")
    bitbucket_server_trigger_config: Optional[BitbucketServerTriggerConfig] = Field(default=None, alias="bitbucketServerTriggerConfig")
    build: Optional[Build] = None
    create_time: Optional[StrictStr] = Field(default=None, description="Output only. Time when the trigger was created.", alias="createTime")
    description: Optional[StrictStr] = Field(default=None, description="Human-readable description of this trigger.")
    disabled: Optional[StrictBool] = Field(default=None, description="If true, the trigger will never automatically execute a build.")
    event_type: Optional[StrictStr] = Field(default=None, description="EventType allows the user to explicitly set the type of event to which this BuildTrigger should respond. This field will be validated against the rest of the configuration if it is set.", alias="eventType")
    filename: Optional[StrictStr] = Field(default=None, description="Path, from the source root, to the build configuration file (i.e. cloudbuild.yaml).")
    filter: Optional[StrictStr] = Field(default=None, description="A Common Expression Language string.")
    git_file_source: Optional[GitFileSource] = Field(default=None, alias="gitFileSource")
    github: Optional[GitHubEventsConfig] = None
    gitlab_enterprise_events_config: Optional[GitLabEventsConfig] = Field(default=None, alias="gitlabEnterpriseEventsConfig")
    id: Optional[StrictStr] = Field(default=None, description="Output only. Unique identifier of the trigger.")
    ignored_files: Optional[List[StrictStr]] = Field(default=None, description="ignored_files and included_files are file glob matches using https://golang.org/pkg/path/filepath/#Match extended with support for \"**\". If ignored_files and changed files are both empty, then they are not used to determine whether or not to trigger a build. If ignored_files is not empty, then we ignore any files that match any of the ignored_file globs. If the change has no files that are outside of the ignored_files globs, then we do not trigger a build.", alias="ignoredFiles")
    include_build_logs: Optional[StrictStr] = Field(default=None, description="If set to INCLUDE_BUILD_LOGS_WITH_STATUS, log url will be shown on GitHub page when build status is final. Setting this field to INCLUDE_BUILD_LOGS_WITH_STATUS for non GitHub triggers results in INVALID_ARGUMENT error.", alias="includeBuildLogs")
    included_files: Optional[List[StrictStr]] = Field(default=None, description="If any of the files altered in the commit pass the ignored_files filter and included_files is empty, then as far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the ignored_files filter and included_files is not empty, then we make sure that at least one of those files matches a included_files glob. If not, then we do not trigger a build.", alias="includedFiles")
    name: Optional[StrictStr] = Field(default=None, description="User-assigned name of the trigger. Must be unique within the project. Trigger names must meet the following requirements: + They must contain only alphanumeric characters and dashes. + They can be 1-64 characters long. + They must begin and end with an alphanumeric character.")
    pubsub_config: Optional[PubsubConfig] = Field(default=None, alias="pubsubConfig")
    repository_event_config: Optional[RepositoryEventConfig] = Field(default=None, alias="repositoryEventConfig")
    resource_name: Optional[StrictStr] = Field(default=None, description="The `Trigger` name with format: `projects/{project}/locations/{location}/triggers/{trigger}`, where {trigger} is a unique identifier generated by the service.", alias="resourceName")
    service_account: Optional[StrictStr] = Field(default=None, description="The service account used for all user-controlled operations including UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild. If no service account is set, then the standard Cloud Build service account ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead. Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`", alias="serviceAccount")
    source_to_build: Optional[GitRepoSource] = Field(default=None, alias="sourceToBuild")
    substitutions: Optional[Dict[str, StrictStr]] = Field(default=None, description="Substitutions for Build resource. The keys must match the following regular expression: `^_[A-Z0-9_]+$`.")
    tags: Optional[List[StrictStr]] = Field(default=None, description="Tags for annotation of a `BuildTrigger`")
    trigger_template: Optional[RepoSource] = Field(default=None, alias="triggerTemplate")
    webhook_config: Optional[WebhookConfig] = Field(default=None, alias="webhookConfig")
    __properties: ClassVar[List[str]] = ["approvalConfig", "autodetect", "bitbucketServerTriggerConfig", "build", "createTime", "description", "disabled", "eventType", "filename", "filter", "gitFileSource", "github", "gitlabEnterpriseEventsConfig", "id", "ignoredFiles", "includeBuildLogs", "includedFiles", "name", "pubsubConfig", "repositoryEventConfig", "resourceName", "serviceAccount", "sourceToBuild", "substitutions", "tags", "triggerTemplate", "webhookConfig"]

    @field_validator('event_type')
    def event_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['EVENT_TYPE_UNSPECIFIED', 'REPO', 'WEBHOOK', 'PUBSUB', 'MANUAL']):
            raise ValueError("must be one of enum values ('EVENT_TYPE_UNSPECIFIED', 'REPO', 'WEBHOOK', 'PUBSUB', 'MANUAL')")
        return value

    @field_validator('include_build_logs')
    def include_build_logs_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['INCLUDE_BUILD_LOGS_UNSPECIFIED', 'INCLUDE_BUILD_LOGS_WITH_STATUS']):
            raise ValueError("must be one of enum values ('INCLUDE_BUILD_LOGS_UNSPECIFIED', 'INCLUDE_BUILD_LOGS_WITH_STATUS')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BuildTrigger from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "create_time",
            "id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of approval_config
        if self.approval_config:
            _dict['approvalConfig'] = self.approval_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bitbucket_server_trigger_config
        if self.bitbucket_server_trigger_config:
            _dict['bitbucketServerTriggerConfig'] = self.bitbucket_server_trigger_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of build
        if self.build:
            _dict['build'] = self.build.to_dict()
        # override the default output from pydantic by calling `to_dict()` of git_file_source
        if self.git_file_source:
            _dict['gitFileSource'] = self.git_file_source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of github
        if self.github:
            _dict['github'] = self.github.to_dict()
        # override the default output from pydantic by calling `to_dict()` of gitlab_enterprise_events_config
        if self.gitlab_enterprise_events_config:
            _dict['gitlabEnterpriseEventsConfig'] = self.gitlab_enterprise_events_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pubsub_config
        if self.pubsub_config:
            _dict['pubsubConfig'] = self.pubsub_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of repository_event_config
        if self.repository_event_config:
            _dict['repositoryEventConfig'] = self.repository_event_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source_to_build
        if self.source_to_build:
            _dict['sourceToBuild'] = self.source_to_build.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trigger_template
        if self.trigger_template:
            _dict['triggerTemplate'] = self.trigger_template.to_dict()
        # override the default output from pydantic by calling `to_dict()` of webhook_config
        if self.webhook_config:
            _dict['webhookConfig'] = self.webhook_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BuildTrigger from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "approvalConfig": ApprovalConfig.from_dict(obj["approvalConfig"]) if obj.get("approvalConfig") is not None else None,
            "autodetect": obj.get("autodetect"),
            "bitbucketServerTriggerConfig": BitbucketServerTriggerConfig.from_dict(obj["bitbucketServerTriggerConfig"]) if obj.get("bitbucketServerTriggerConfig") is not None else None,
            "build": Build.from_dict(obj["build"]) if obj.get("build") is not None else None,
            "createTime": obj.get("createTime"),
            "description": obj.get("description"),
            "disabled": obj.get("disabled"),
            "eventType": obj.get("eventType"),
            "filename": obj.get("filename"),
            "filter": obj.get("filter"),
            "gitFileSource": GitFileSource.from_dict(obj["gitFileSource"]) if obj.get("gitFileSource") is not None else None,
            "github": GitHubEventsConfig.from_dict(obj["github"]) if obj.get("github") is not None else None,
            "gitlabEnterpriseEventsConfig": GitLabEventsConfig.from_dict(obj["gitlabEnterpriseEventsConfig"]) if obj.get("gitlabEnterpriseEventsConfig") is not None else None,
            "id": obj.get("id"),
            "ignoredFiles": obj.get("ignoredFiles"),
            "includeBuildLogs": obj.get("includeBuildLogs"),
            "includedFiles": obj.get("includedFiles"),
            "name": obj.get("name"),
            "pubsubConfig": PubsubConfig.from_dict(obj["pubsubConfig"]) if obj.get("pubsubConfig") is not None else None,
            "repositoryEventConfig": RepositoryEventConfig.from_dict(obj["repositoryEventConfig"]) if obj.get("repositoryEventConfig") is not None else None,
            "resourceName": obj.get("resourceName"),
            "serviceAccount": obj.get("serviceAccount"),
            "sourceToBuild": GitRepoSource.from_dict(obj["sourceToBuild"]) if obj.get("sourceToBuild") is not None else None,
            "substitutions": obj.get("substitutions"),
            "tags": obj.get("tags"),
            "triggerTemplate": RepoSource.from_dict(obj["triggerTemplate"]) if obj.get("triggerTemplate") is not None else None,
            "webhookConfig": WebhookConfig.from_dict(obj["webhookConfig"]) if obj.get("webhookConfig") is not None else None
        })
        return _obj


