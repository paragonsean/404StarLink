# coding: utf-8

"""
    Amazon Kinesis Firehose

    <fullname>Amazon Kinesis Data Firehose API Reference</fullname> <p>Amazon Kinesis Data Firehose is a fully managed service that delivers real-time streaming data to destinations such as Amazon Simple Storage Service (Amazon S3), Amazon OpenSearch Service, Amazon Redshift, Splunk, and various other supportd destinations.</p>

    The version of the OpenAPI document: 2015-08-04
    Contact: mike.ralphson@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.data_format_conversion_configuration_input_format_configuration import DataFormatConversionConfigurationInputFormatConfiguration
from openapi_client.models.data_format_conversion_configuration_output_format_configuration import DataFormatConversionConfigurationOutputFormatConfiguration
from openapi_client.models.data_format_conversion_configuration_schema_configuration import DataFormatConversionConfigurationSchemaConfiguration
from typing import Optional, Set
from typing_extensions import Self

class DataFormatConversionConfiguration(BaseModel):
    """
    Specifies that you want Kinesis Data Firehose to convert data from the JSON format to the Parquet or ORC format before writing it to Amazon S3. Kinesis Data Firehose uses the serializer and deserializer that you specify, in addition to the column information from the Amazon Web Services Glue table, to deserialize your input data from JSON and then serialize it to the Parquet or ORC format. For more information, see <a href=\"https://docs.aws.amazon.com/firehose/latest/dev/record-format-conversion.html\">Kinesis Data Firehose Record Format Conversion</a>.
    """ # noqa: E501
    schema_configuration: Optional[DataFormatConversionConfigurationSchemaConfiguration] = Field(default=None, alias="SchemaConfiguration")
    input_format_configuration: Optional[DataFormatConversionConfigurationInputFormatConfiguration] = Field(default=None, alias="InputFormatConfiguration")
    output_format_configuration: Optional[DataFormatConversionConfigurationOutputFormatConfiguration] = Field(default=None, alias="OutputFormatConfiguration")
    enabled: Optional[Any] = Field(default=None, alias="Enabled")
    __properties: ClassVar[List[str]] = ["SchemaConfiguration", "InputFormatConfiguration", "OutputFormatConfiguration", "Enabled"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DataFormatConversionConfiguration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of schema_configuration
        if self.schema_configuration:
            _dict['SchemaConfiguration'] = self.schema_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of input_format_configuration
        if self.input_format_configuration:
            _dict['InputFormatConfiguration'] = self.input_format_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of output_format_configuration
        if self.output_format_configuration:
            _dict['OutputFormatConfiguration'] = self.output_format_configuration.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DataFormatConversionConfiguration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "SchemaConfiguration": DataFormatConversionConfigurationSchemaConfiguration.from_dict(obj["SchemaConfiguration"]) if obj.get("SchemaConfiguration") is not None else None,
            "InputFormatConfiguration": DataFormatConversionConfigurationInputFormatConfiguration.from_dict(obj["InputFormatConfiguration"]) if obj.get("InputFormatConfiguration") is not None else None,
            "OutputFormatConfiguration": DataFormatConversionConfigurationOutputFormatConfiguration.from_dict(obj["OutputFormatConfiguration"]) if obj.get("OutputFormatConfiguration") is not None else None,
            "Enabled": obj.get("Enabled")
        })
        return _obj


