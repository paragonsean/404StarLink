/*
 * Notebooks API
 * Notebooks API is used to manage notebook resources in Google Cloud.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ContainerImage;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies the selection and configuration of software inside the runtime. The properties to set on runtime. Properties keys are specified in &#x60;key:value&#x60; format, for example: * &#x60;idle_shutdown: true&#x60; * &#x60;idle_shutdown_timeout: 180&#x60; * &#x60;enable_health_monitoring: true&#x60;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:00:12.602654-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RuntimeSoftwareConfig {
  public static final String SERIALIZED_NAME_CUSTOM_GPU_DRIVER_PATH = "customGpuDriverPath";
  @SerializedName(SERIALIZED_NAME_CUSTOM_GPU_DRIVER_PATH)
  private String customGpuDriverPath;

  public static final String SERIALIZED_NAME_DISABLE_TERMINAL = "disableTerminal";
  @SerializedName(SERIALIZED_NAME_DISABLE_TERMINAL)
  private Boolean disableTerminal;

  public static final String SERIALIZED_NAME_ENABLE_HEALTH_MONITORING = "enableHealthMonitoring";
  @SerializedName(SERIALIZED_NAME_ENABLE_HEALTH_MONITORING)
  private Boolean enableHealthMonitoring;

  public static final String SERIALIZED_NAME_IDLE_SHUTDOWN = "idleShutdown";
  @SerializedName(SERIALIZED_NAME_IDLE_SHUTDOWN)
  private Boolean idleShutdown;

  public static final String SERIALIZED_NAME_IDLE_SHUTDOWN_TIMEOUT = "idleShutdownTimeout";
  @SerializedName(SERIALIZED_NAME_IDLE_SHUTDOWN_TIMEOUT)
  private Integer idleShutdownTimeout;

  public static final String SERIALIZED_NAME_INSTALL_GPU_DRIVER = "installGpuDriver";
  @SerializedName(SERIALIZED_NAME_INSTALL_GPU_DRIVER)
  private Boolean installGpuDriver;

  public static final String SERIALIZED_NAME_KERNELS = "kernels";
  @SerializedName(SERIALIZED_NAME_KERNELS)
  private List<ContainerImage> kernels = new ArrayList<>();

  public static final String SERIALIZED_NAME_MIXER_DISABLED = "mixerDisabled";
  @SerializedName(SERIALIZED_NAME_MIXER_DISABLED)
  private Boolean mixerDisabled;

  public static final String SERIALIZED_NAME_NOTEBOOK_UPGRADE_SCHEDULE = "notebookUpgradeSchedule";
  @SerializedName(SERIALIZED_NAME_NOTEBOOK_UPGRADE_SCHEDULE)
  private String notebookUpgradeSchedule;

  public static final String SERIALIZED_NAME_POST_STARTUP_SCRIPT = "postStartupScript";
  @SerializedName(SERIALIZED_NAME_POST_STARTUP_SCRIPT)
  private String postStartupScript;

  /**
   * Behavior for the post startup script.
   */
  @JsonAdapter(PostStartupScriptBehaviorEnum.Adapter.class)
  public enum PostStartupScriptBehaviorEnum {
    POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED("POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED"),
    
    RUN_EVERY_START("RUN_EVERY_START"),
    
    DOWNLOAD_AND_RUN_EVERY_START("DOWNLOAD_AND_RUN_EVERY_START");

    private String value;

    PostStartupScriptBehaviorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PostStartupScriptBehaviorEnum fromValue(String value) {
      for (PostStartupScriptBehaviorEnum b : PostStartupScriptBehaviorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PostStartupScriptBehaviorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PostStartupScriptBehaviorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PostStartupScriptBehaviorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PostStartupScriptBehaviorEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PostStartupScriptBehaviorEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_POST_STARTUP_SCRIPT_BEHAVIOR = "postStartupScriptBehavior";
  @SerializedName(SERIALIZED_NAME_POST_STARTUP_SCRIPT_BEHAVIOR)
  private PostStartupScriptBehaviorEnum postStartupScriptBehavior;

  public static final String SERIALIZED_NAME_UPGRADEABLE = "upgradeable";
  @SerializedName(SERIALIZED_NAME_UPGRADEABLE)
  private Boolean upgradeable;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public RuntimeSoftwareConfig() {
  }

  public RuntimeSoftwareConfig(
     Boolean upgradeable, 
     String version
  ) {
    this();
    this.upgradeable = upgradeable;
    this.version = version;
  }

  public RuntimeSoftwareConfig customGpuDriverPath(String customGpuDriverPath) {
    this.customGpuDriverPath = customGpuDriverPath;
    return this;
  }

  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored. If not specified, we&#39;ll automatically choose from official GPU drivers.
   * @return customGpuDriverPath
   */
  @javax.annotation.Nullable
  public String getCustomGpuDriverPath() {
    return customGpuDriverPath;
  }

  public void setCustomGpuDriverPath(String customGpuDriverPath) {
    this.customGpuDriverPath = customGpuDriverPath;
  }


  public RuntimeSoftwareConfig disableTerminal(Boolean disableTerminal) {
    this.disableTerminal = disableTerminal;
    return this;
  }

  /**
   * Bool indicating whether JupyterLab terminal will be available or not. Default: False
   * @return disableTerminal
   */
  @javax.annotation.Nullable
  public Boolean getDisableTerminal() {
    return disableTerminal;
  }

  public void setDisableTerminal(Boolean disableTerminal) {
    this.disableTerminal = disableTerminal;
  }


  public RuntimeSoftwareConfig enableHealthMonitoring(Boolean enableHealthMonitoring) {
    this.enableHealthMonitoring = enableHealthMonitoring;
    return this;
  }

  /**
   * Verifies core internal services are running. Default: True
   * @return enableHealthMonitoring
   */
  @javax.annotation.Nullable
  public Boolean getEnableHealthMonitoring() {
    return enableHealthMonitoring;
  }

  public void setEnableHealthMonitoring(Boolean enableHealthMonitoring) {
    this.enableHealthMonitoring = enableHealthMonitoring;
  }


  public RuntimeSoftwareConfig idleShutdown(Boolean idleShutdown) {
    this.idleShutdown = idleShutdown;
    return this;
  }

  /**
   * Runtime will automatically shutdown after idle_shutdown_time. Default: True
   * @return idleShutdown
   */
  @javax.annotation.Nullable
  public Boolean getIdleShutdown() {
    return idleShutdown;
  }

  public void setIdleShutdown(Boolean idleShutdown) {
    this.idleShutdown = idleShutdown;
  }


  public RuntimeSoftwareConfig idleShutdownTimeout(Integer idleShutdownTimeout) {
    this.idleShutdownTimeout = idleShutdownTimeout;
    return this;
  }

  /**
   * Time in minutes to wait before shutting down runtime. Default: 180 minutes
   * @return idleShutdownTimeout
   */
  @javax.annotation.Nullable
  public Integer getIdleShutdownTimeout() {
    return idleShutdownTimeout;
  }

  public void setIdleShutdownTimeout(Integer idleShutdownTimeout) {
    this.idleShutdownTimeout = idleShutdownTimeout;
  }


  public RuntimeSoftwareConfig installGpuDriver(Boolean installGpuDriver) {
    this.installGpuDriver = installGpuDriver;
    return this;
  }

  /**
   * Install Nvidia Driver automatically. Default: True
   * @return installGpuDriver
   */
  @javax.annotation.Nullable
  public Boolean getInstallGpuDriver() {
    return installGpuDriver;
  }

  public void setInstallGpuDriver(Boolean installGpuDriver) {
    this.installGpuDriver = installGpuDriver;
  }


  public RuntimeSoftwareConfig kernels(List<ContainerImage> kernels) {
    this.kernels = kernels;
    return this;
  }

  public RuntimeSoftwareConfig addKernelsItem(ContainerImage kernelsItem) {
    if (this.kernels == null) {
      this.kernels = new ArrayList<>();
    }
    this.kernels.add(kernelsItem);
    return this;
  }

  /**
   * Optional. Use a list of container images to use as Kernels in the notebook instance.
   * @return kernels
   */
  @javax.annotation.Nullable
  public List<ContainerImage> getKernels() {
    return kernels;
  }

  public void setKernels(List<ContainerImage> kernels) {
    this.kernels = kernels;
  }


  public RuntimeSoftwareConfig mixerDisabled(Boolean mixerDisabled) {
    this.mixerDisabled = mixerDisabled;
    return this;
  }

  /**
   * Bool indicating whether mixer client should be disabled. Default: False
   * @return mixerDisabled
   */
  @javax.annotation.Nullable
  public Boolean getMixerDisabled() {
    return mixerDisabled;
  }

  public void setMixerDisabled(Boolean mixerDisabled) {
    this.mixerDisabled = mixerDisabled;
  }


  public RuntimeSoftwareConfig notebookUpgradeSchedule(String notebookUpgradeSchedule) {
    this.notebookUpgradeSchedule = notebookUpgradeSchedule;
    return this;
  }

  /**
   * Cron expression in UTC timezone, used to schedule instance auto upgrade. Please follow the [cron format](https://en.wikipedia.org/wiki/Cron).
   * @return notebookUpgradeSchedule
   */
  @javax.annotation.Nullable
  public String getNotebookUpgradeSchedule() {
    return notebookUpgradeSchedule;
  }

  public void setNotebookUpgradeSchedule(String notebookUpgradeSchedule) {
    this.notebookUpgradeSchedule = notebookUpgradeSchedule;
  }


  public RuntimeSoftwareConfig postStartupScript(String postStartupScript) {
    this.postStartupScript = postStartupScript;
    return this;
  }

  /**
   * Path to a Bash script that automatically runs after a notebook instance fully boots up. The path must be a URL or Cloud Storage path (&#x60;gs://path-to-file/file-name&#x60;).
   * @return postStartupScript
   */
  @javax.annotation.Nullable
  public String getPostStartupScript() {
    return postStartupScript;
  }

  public void setPostStartupScript(String postStartupScript) {
    this.postStartupScript = postStartupScript;
  }


  public RuntimeSoftwareConfig postStartupScriptBehavior(PostStartupScriptBehaviorEnum postStartupScriptBehavior) {
    this.postStartupScriptBehavior = postStartupScriptBehavior;
    return this;
  }

  /**
   * Behavior for the post startup script.
   * @return postStartupScriptBehavior
   */
  @javax.annotation.Nullable
  public PostStartupScriptBehaviorEnum getPostStartupScriptBehavior() {
    return postStartupScriptBehavior;
  }

  public void setPostStartupScriptBehavior(PostStartupScriptBehaviorEnum postStartupScriptBehavior) {
    this.postStartupScriptBehavior = postStartupScriptBehavior;
  }


  /**
   * Output only. Bool indicating whether an newer image is available in an image family.
   * @return upgradeable
   */
  @javax.annotation.Nullable
  public Boolean getUpgradeable() {
    return upgradeable;
  }



  /**
   * Output only. version of boot image such as M100, from release label of the image.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RuntimeSoftwareConfig runtimeSoftwareConfig = (RuntimeSoftwareConfig) o;
    return Objects.equals(this.customGpuDriverPath, runtimeSoftwareConfig.customGpuDriverPath) &&
        Objects.equals(this.disableTerminal, runtimeSoftwareConfig.disableTerminal) &&
        Objects.equals(this.enableHealthMonitoring, runtimeSoftwareConfig.enableHealthMonitoring) &&
        Objects.equals(this.idleShutdown, runtimeSoftwareConfig.idleShutdown) &&
        Objects.equals(this.idleShutdownTimeout, runtimeSoftwareConfig.idleShutdownTimeout) &&
        Objects.equals(this.installGpuDriver, runtimeSoftwareConfig.installGpuDriver) &&
        Objects.equals(this.kernels, runtimeSoftwareConfig.kernels) &&
        Objects.equals(this.mixerDisabled, runtimeSoftwareConfig.mixerDisabled) &&
        Objects.equals(this.notebookUpgradeSchedule, runtimeSoftwareConfig.notebookUpgradeSchedule) &&
        Objects.equals(this.postStartupScript, runtimeSoftwareConfig.postStartupScript) &&
        Objects.equals(this.postStartupScriptBehavior, runtimeSoftwareConfig.postStartupScriptBehavior) &&
        Objects.equals(this.upgradeable, runtimeSoftwareConfig.upgradeable) &&
        Objects.equals(this.version, runtimeSoftwareConfig.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(customGpuDriverPath, disableTerminal, enableHealthMonitoring, idleShutdown, idleShutdownTimeout, installGpuDriver, kernels, mixerDisabled, notebookUpgradeSchedule, postStartupScript, postStartupScriptBehavior, upgradeable, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RuntimeSoftwareConfig {\n");
    sb.append("    customGpuDriverPath: ").append(toIndentedString(customGpuDriverPath)).append("\n");
    sb.append("    disableTerminal: ").append(toIndentedString(disableTerminal)).append("\n");
    sb.append("    enableHealthMonitoring: ").append(toIndentedString(enableHealthMonitoring)).append("\n");
    sb.append("    idleShutdown: ").append(toIndentedString(idleShutdown)).append("\n");
    sb.append("    idleShutdownTimeout: ").append(toIndentedString(idleShutdownTimeout)).append("\n");
    sb.append("    installGpuDriver: ").append(toIndentedString(installGpuDriver)).append("\n");
    sb.append("    kernels: ").append(toIndentedString(kernels)).append("\n");
    sb.append("    mixerDisabled: ").append(toIndentedString(mixerDisabled)).append("\n");
    sb.append("    notebookUpgradeSchedule: ").append(toIndentedString(notebookUpgradeSchedule)).append("\n");
    sb.append("    postStartupScript: ").append(toIndentedString(postStartupScript)).append("\n");
    sb.append("    postStartupScriptBehavior: ").append(toIndentedString(postStartupScriptBehavior)).append("\n");
    sb.append("    upgradeable: ").append(toIndentedString(upgradeable)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("customGpuDriverPath");
    openapiFields.add("disableTerminal");
    openapiFields.add("enableHealthMonitoring");
    openapiFields.add("idleShutdown");
    openapiFields.add("idleShutdownTimeout");
    openapiFields.add("installGpuDriver");
    openapiFields.add("kernels");
    openapiFields.add("mixerDisabled");
    openapiFields.add("notebookUpgradeSchedule");
    openapiFields.add("postStartupScript");
    openapiFields.add("postStartupScriptBehavior");
    openapiFields.add("upgradeable");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RuntimeSoftwareConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RuntimeSoftwareConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RuntimeSoftwareConfig is not found in the empty JSON string", RuntimeSoftwareConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RuntimeSoftwareConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RuntimeSoftwareConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("customGpuDriverPath") != null && !jsonObj.get("customGpuDriverPath").isJsonNull()) && !jsonObj.get("customGpuDriverPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customGpuDriverPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customGpuDriverPath").toString()));
      }
      if (jsonObj.get("kernels") != null && !jsonObj.get("kernels").isJsonNull()) {
        JsonArray jsonArraykernels = jsonObj.getAsJsonArray("kernels");
        if (jsonArraykernels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kernels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kernels` to be an array in the JSON string but got `%s`", jsonObj.get("kernels").toString()));
          }

          // validate the optional field `kernels` (array)
          for (int i = 0; i < jsonArraykernels.size(); i++) {
            ContainerImage.validateJsonElement(jsonArraykernels.get(i));
          };
        }
      }
      if ((jsonObj.get("notebookUpgradeSchedule") != null && !jsonObj.get("notebookUpgradeSchedule").isJsonNull()) && !jsonObj.get("notebookUpgradeSchedule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `notebookUpgradeSchedule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("notebookUpgradeSchedule").toString()));
      }
      if ((jsonObj.get("postStartupScript") != null && !jsonObj.get("postStartupScript").isJsonNull()) && !jsonObj.get("postStartupScript").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postStartupScript` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postStartupScript").toString()));
      }
      if ((jsonObj.get("postStartupScriptBehavior") != null && !jsonObj.get("postStartupScriptBehavior").isJsonNull()) && !jsonObj.get("postStartupScriptBehavior").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postStartupScriptBehavior` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postStartupScriptBehavior").toString()));
      }
      // validate the optional field `postStartupScriptBehavior`
      if (jsonObj.get("postStartupScriptBehavior") != null && !jsonObj.get("postStartupScriptBehavior").isJsonNull()) {
        PostStartupScriptBehaviorEnum.validateJsonElement(jsonObj.get("postStartupScriptBehavior"));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RuntimeSoftwareConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RuntimeSoftwareConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RuntimeSoftwareConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RuntimeSoftwareConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<RuntimeSoftwareConfig>() {
           @Override
           public void write(JsonWriter out, RuntimeSoftwareConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RuntimeSoftwareConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RuntimeSoftwareConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RuntimeSoftwareConfig
   * @throws IOException if the JSON string is invalid with respect to RuntimeSoftwareConfig
   */
  public static RuntimeSoftwareConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RuntimeSoftwareConfig.class);
  }

  /**
   * Convert an instance of RuntimeSoftwareConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

