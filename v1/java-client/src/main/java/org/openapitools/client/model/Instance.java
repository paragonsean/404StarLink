/*
 * Notebooks API
 * Notebooks API is used to manage notebook resources in Google Cloud.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.AcceleratorConfig;
import org.openapitools.client.model.ContainerImage;
import org.openapitools.client.model.Disk;
import org.openapitools.client.model.ReservationAffinity;
import org.openapitools.client.model.ShieldedInstanceConfig;
import org.openapitools.client.model.UpgradeHistoryEntry;
import org.openapitools.client.model.VmImage;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The definition of a notebook instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:09:43.451204-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Instance {
  public static final String SERIALIZED_NAME_ACCELERATOR_CONFIG = "acceleratorConfig";
  @SerializedName(SERIALIZED_NAME_ACCELERATOR_CONFIG)
  private AcceleratorConfig acceleratorConfig;

  public static final String SERIALIZED_NAME_BOOT_DISK_SIZE_GB = "bootDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_SIZE_GB)
  private String bootDiskSizeGb;

  /**
   * Input only. The type of the boot disk attached to this instance, defaults to standard persistent disk (&#x60;PD_STANDARD&#x60;).
   */
  @JsonAdapter(BootDiskTypeEnum.Adapter.class)
  public enum BootDiskTypeEnum {
    DISK_TYPE_UNSPECIFIED("DISK_TYPE_UNSPECIFIED"),
    
    PD_STANDARD("PD_STANDARD"),
    
    PD_SSD("PD_SSD"),
    
    PD_BALANCED("PD_BALANCED"),
    
    PD_EXTREME("PD_EXTREME");

    private String value;

    BootDiskTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BootDiskTypeEnum fromValue(String value) {
      for (BootDiskTypeEnum b : BootDiskTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BootDiskTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BootDiskTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BootDiskTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BootDiskTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BootDiskTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BOOT_DISK_TYPE = "bootDiskType";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_TYPE)
  private BootDiskTypeEnum bootDiskType;

  public static final String SERIALIZED_NAME_CAN_IP_FORWARD = "canIpForward";
  @SerializedName(SERIALIZED_NAME_CAN_IP_FORWARD)
  private Boolean canIpForward;

  public static final String SERIALIZED_NAME_CONTAINER_IMAGE = "containerImage";
  @SerializedName(SERIALIZED_NAME_CONTAINER_IMAGE)
  private ContainerImage containerImage;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CREATOR = "creator";
  @SerializedName(SERIALIZED_NAME_CREATOR)
  private String creator;

  public static final String SERIALIZED_NAME_CUSTOM_GPU_DRIVER_PATH = "customGpuDriverPath";
  @SerializedName(SERIALIZED_NAME_CUSTOM_GPU_DRIVER_PATH)
  private String customGpuDriverPath;

  public static final String SERIALIZED_NAME_DATA_DISK_SIZE_GB = "dataDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_SIZE_GB)
  private String dataDiskSizeGb;

  /**
   * Input only. The type of the data disk attached to this instance, defaults to standard persistent disk (&#x60;PD_STANDARD&#x60;).
   */
  @JsonAdapter(DataDiskTypeEnum.Adapter.class)
  public enum DataDiskTypeEnum {
    DISK_TYPE_UNSPECIFIED("DISK_TYPE_UNSPECIFIED"),
    
    PD_STANDARD("PD_STANDARD"),
    
    PD_SSD("PD_SSD"),
    
    PD_BALANCED("PD_BALANCED"),
    
    PD_EXTREME("PD_EXTREME");

    private String value;

    DataDiskTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataDiskTypeEnum fromValue(String value) {
      for (DataDiskTypeEnum b : DataDiskTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataDiskTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataDiskTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataDiskTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataDiskTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataDiskTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_DISK_TYPE = "dataDiskType";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_TYPE)
  private DataDiskTypeEnum dataDiskType;

  /**
   * Input only. Disk encryption method used on the boot and data disks, defaults to GMEK.
   */
  @JsonAdapter(DiskEncryptionEnum.Adapter.class)
  public enum DiskEncryptionEnum {
    DISK_ENCRYPTION_UNSPECIFIED("DISK_ENCRYPTION_UNSPECIFIED"),
    
    GMEK("GMEK"),
    
    CMEK("CMEK");

    private String value;

    DiskEncryptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DiskEncryptionEnum fromValue(String value) {
      for (DiskEncryptionEnum b : DiskEncryptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DiskEncryptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DiskEncryptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DiskEncryptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DiskEncryptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DiskEncryptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISK_ENCRYPTION = "diskEncryption";
  @SerializedName(SERIALIZED_NAME_DISK_ENCRYPTION)
  private DiskEncryptionEnum diskEncryption;

  public static final String SERIALIZED_NAME_DISKS = "disks";
  @SerializedName(SERIALIZED_NAME_DISKS)
  private List<Disk> disks = new ArrayList<>();

  public static final String SERIALIZED_NAME_INSTALL_GPU_DRIVER = "installGpuDriver";
  @SerializedName(SERIALIZED_NAME_INSTALL_GPU_DRIVER)
  private Boolean installGpuDriver;

  public static final String SERIALIZED_NAME_INSTANCE_OWNERS = "instanceOwners";
  @SerializedName(SERIALIZED_NAME_INSTANCE_OWNERS)
  private List<String> instanceOwners = new ArrayList<>();

  public static final String SERIALIZED_NAME_KMS_KEY = "kmsKey";
  @SerializedName(SERIALIZED_NAME_KMS_KEY)
  private String kmsKey;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
   */
  @JsonAdapter(NicTypeEnum.Adapter.class)
  public enum NicTypeEnum {
    UNSPECIFIED_NIC_TYPE("UNSPECIFIED_NIC_TYPE"),
    
    VIRTIO_NET("VIRTIO_NET"),
    
    GVNIC("GVNIC");

    private String value;

    NicTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NicTypeEnum fromValue(String value) {
      for (NicTypeEnum b : NicTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<NicTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NicTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NicTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NicTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      NicTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_NIC_TYPE = "nicType";
  @SerializedName(SERIALIZED_NAME_NIC_TYPE)
  private NicTypeEnum nicType;

  public static final String SERIALIZED_NAME_NO_PROXY_ACCESS = "noProxyAccess";
  @SerializedName(SERIALIZED_NAME_NO_PROXY_ACCESS)
  private Boolean noProxyAccess;

  public static final String SERIALIZED_NAME_NO_PUBLIC_IP = "noPublicIp";
  @SerializedName(SERIALIZED_NAME_NO_PUBLIC_IP)
  private Boolean noPublicIp;

  public static final String SERIALIZED_NAME_NO_REMOVE_DATA_DISK = "noRemoveDataDisk";
  @SerializedName(SERIALIZED_NAME_NO_REMOVE_DATA_DISK)
  private Boolean noRemoveDataDisk;

  public static final String SERIALIZED_NAME_POST_STARTUP_SCRIPT = "postStartupScript";
  @SerializedName(SERIALIZED_NAME_POST_STARTUP_SCRIPT)
  private String postStartupScript;

  public static final String SERIALIZED_NAME_PROXY_URI = "proxyUri";
  @SerializedName(SERIALIZED_NAME_PROXY_URI)
  private String proxyUri;

  public static final String SERIALIZED_NAME_RESERVATION_AFFINITY = "reservationAffinity";
  @SerializedName(SERIALIZED_NAME_RESERVATION_AFFINITY)
  private ReservationAffinity reservationAffinity;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES = "serviceAccountScopes";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES)
  private List<String> serviceAccountScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG = "shieldedInstanceConfig";
  @SerializedName(SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG)
  private ShieldedInstanceConfig shieldedInstanceConfig;

  /**
   * Output only. The state of this instance.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    STARTING("STARTING"),
    
    PROVISIONING("PROVISIONING"),
    
    ACTIVE("ACTIVE"),
    
    STOPPING("STOPPING"),
    
    STOPPED("STOPPED"),
    
    DELETED("DELETED"),
    
    UPGRADING("UPGRADING"),
    
    INITIALIZING("INITIALIZING"),
    
    REGISTERING("REGISTERING"),
    
    SUSPENDING("SUSPENDING"),
    
    SUSPENDED("SUSPENDED");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_SUBNET = "subnet";
  @SerializedName(SERIALIZED_NAME_SUBNET)
  private String subnet;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_UPGRADE_HISTORY = "upgradeHistory";
  @SerializedName(SERIALIZED_NAME_UPGRADE_HISTORY)
  private List<UpgradeHistoryEntry> upgradeHistory = new ArrayList<>();

  public static final String SERIALIZED_NAME_VM_IMAGE = "vmImage";
  @SerializedName(SERIALIZED_NAME_VM_IMAGE)
  private VmImage vmImage;

  public Instance() {
  }

  public Instance(
     String createTime, 
     String creator, 
     List<Disk> disks, 
     String name, 
     String proxyUri, 
     StateEnum state, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.creator = creator;
    this.disks = disks;
    this.name = name;
    this.proxyUri = proxyUri;
    this.state = state;
    this.updateTime = updateTime;
  }

  public Instance acceleratorConfig(AcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
    return this;
  }

  /**
   * Get acceleratorConfig
   * @return acceleratorConfig
   */
  @javax.annotation.Nullable
  public AcceleratorConfig getAcceleratorConfig() {
    return acceleratorConfig;
  }

  public void setAcceleratorConfig(AcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
  }


  public Instance bootDiskSizeGb(String bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
    return this;
  }

  /**
   * Input only. The size of the boot disk in GB attached to this instance, up to a maximum of 64000 GB (64 TB). The minimum recommended value is 100 GB. If not specified, this defaults to 100.
   * @return bootDiskSizeGb
   */
  @javax.annotation.Nullable
  public String getBootDiskSizeGb() {
    return bootDiskSizeGb;
  }

  public void setBootDiskSizeGb(String bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
  }


  public Instance bootDiskType(BootDiskTypeEnum bootDiskType) {
    this.bootDiskType = bootDiskType;
    return this;
  }

  /**
   * Input only. The type of the boot disk attached to this instance, defaults to standard persistent disk (&#x60;PD_STANDARD&#x60;).
   * @return bootDiskType
   */
  @javax.annotation.Nullable
  public BootDiskTypeEnum getBootDiskType() {
    return bootDiskType;
  }

  public void setBootDiskType(BootDiskTypeEnum bootDiskType) {
    this.bootDiskType = bootDiskType;
  }


  public Instance canIpForward(Boolean canIpForward) {
    this.canIpForward = canIpForward;
    return this;
  }

  /**
   * Optional. Flag to enable ip forwarding or not, default false/off. https://cloud.google.com/vpc/docs/using-routes#canipforward
   * @return canIpForward
   */
  @javax.annotation.Nullable
  public Boolean getCanIpForward() {
    return canIpForward;
  }

  public void setCanIpForward(Boolean canIpForward) {
    this.canIpForward = canIpForward;
  }


  public Instance containerImage(ContainerImage containerImage) {
    this.containerImage = containerImage;
    return this;
  }

  /**
   * Get containerImage
   * @return containerImage
   */
  @javax.annotation.Nullable
  public ContainerImage getContainerImage() {
    return containerImage;
  }

  public void setContainerImage(ContainerImage containerImage) {
    this.containerImage = containerImage;
  }


  /**
   * Output only. Instance creation time.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. Email address of entity that sent original CreateInstance request.
   * @return creator
   */
  @javax.annotation.Nullable
  public String getCreator() {
    return creator;
  }



  public Instance customGpuDriverPath(String customGpuDriverPath) {
    this.customGpuDriverPath = customGpuDriverPath;
    return this;
  }

  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored. If not specified, we&#39;ll automatically choose from official GPU drivers.
   * @return customGpuDriverPath
   */
  @javax.annotation.Nullable
  public String getCustomGpuDriverPath() {
    return customGpuDriverPath;
  }

  public void setCustomGpuDriverPath(String customGpuDriverPath) {
    this.customGpuDriverPath = customGpuDriverPath;
  }


  public Instance dataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
    return this;
  }

  /**
   * Input only. The size of the data disk in GB attached to this instance, up to a maximum of 64000 GB (64 TB). You can choose the size of the data disk based on how big your notebooks and data are. If not specified, this defaults to 100.
   * @return dataDiskSizeGb
   */
  @javax.annotation.Nullable
  public String getDataDiskSizeGb() {
    return dataDiskSizeGb;
  }

  public void setDataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
  }


  public Instance dataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
    return this;
  }

  /**
   * Input only. The type of the data disk attached to this instance, defaults to standard persistent disk (&#x60;PD_STANDARD&#x60;).
   * @return dataDiskType
   */
  @javax.annotation.Nullable
  public DataDiskTypeEnum getDataDiskType() {
    return dataDiskType;
  }

  public void setDataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
  }


  public Instance diskEncryption(DiskEncryptionEnum diskEncryption) {
    this.diskEncryption = diskEncryption;
    return this;
  }

  /**
   * Input only. Disk encryption method used on the boot and data disks, defaults to GMEK.
   * @return diskEncryption
   */
  @javax.annotation.Nullable
  public DiskEncryptionEnum getDiskEncryption() {
    return diskEncryption;
  }

  public void setDiskEncryption(DiskEncryptionEnum diskEncryption) {
    this.diskEncryption = diskEncryption;
  }


  /**
   * Output only. Attached disks to notebook instance.
   * @return disks
   */
  @javax.annotation.Nullable
  public List<Disk> getDisks() {
    return disks;
  }



  public Instance installGpuDriver(Boolean installGpuDriver) {
    this.installGpuDriver = installGpuDriver;
    return this;
  }

  /**
   * Whether the end user authorizes Google Cloud to install GPU driver on this instance. If this field is empty or set to false, the GPU driver won&#39;t be installed. Only applicable to instances with GPUs.
   * @return installGpuDriver
   */
  @javax.annotation.Nullable
  public Boolean getInstallGpuDriver() {
    return installGpuDriver;
  }

  public void setInstallGpuDriver(Boolean installGpuDriver) {
    this.installGpuDriver = installGpuDriver;
  }


  public Instance instanceOwners(List<String> instanceOwners) {
    this.instanceOwners = instanceOwners;
    return this;
  }

  public Instance addInstanceOwnersItem(String instanceOwnersItem) {
    if (this.instanceOwners == null) {
      this.instanceOwners = new ArrayList<>();
    }
    this.instanceOwners.add(instanceOwnersItem);
    return this;
  }

  /**
   * Input only. The owner of this instance after creation. Format: &#x60;alias@example.com&#x60; Currently supports one owner only. If not specified, all of the service account users of your VM instance&#39;s service account can use the instance.
   * @return instanceOwners
   */
  @javax.annotation.Nullable
  public List<String> getInstanceOwners() {
    return instanceOwners;
  }

  public void setInstanceOwners(List<String> instanceOwners) {
    this.instanceOwners = instanceOwners;
  }


  public Instance kmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
    return this;
  }

  /**
   * Input only. The KMS key used to encrypt the disks, only applicable if disk_encryption is CMEK. Format: &#x60;projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}&#x60; Learn more about [using your own encryption keys](/kms/docs/quickstart).
   * @return kmsKey
   */
  @javax.annotation.Nullable
  public String getKmsKey() {
    return kmsKey;
  }

  public void setKmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
  }


  public Instance labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Instance putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels to apply to this instance. These can be later modified by the setLabels method.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Instance machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Required. The [Compute Engine machine type](https://cloud.google.com/compute/docs/machine-types) of this instance.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public Instance metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public Instance putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Custom metadata to apply to this instance.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  /**
   * Output only. The name of this notebook instance. Format: &#x60;projects/{project_id}/locations/{location}/instances/{instance_id}&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public Instance network(String network) {
    this.network = network;
    return this;
  }

  /**
   * The name of the VPC that this instance is in. Format: &#x60;projects/{project_id}/global/networks/{network_id}&#x60;
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public Instance nicType(NicTypeEnum nicType) {
    this.nicType = nicType;
    return this;
  }

  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
   * @return nicType
   */
  @javax.annotation.Nullable
  public NicTypeEnum getNicType() {
    return nicType;
  }

  public void setNicType(NicTypeEnum nicType) {
    this.nicType = nicType;
  }


  public Instance noProxyAccess(Boolean noProxyAccess) {
    this.noProxyAccess = noProxyAccess;
    return this;
  }

  /**
   * If true, the notebook instance will not register with the proxy.
   * @return noProxyAccess
   */
  @javax.annotation.Nullable
  public Boolean getNoProxyAccess() {
    return noProxyAccess;
  }

  public void setNoProxyAccess(Boolean noProxyAccess) {
    this.noProxyAccess = noProxyAccess;
  }


  public Instance noPublicIp(Boolean noPublicIp) {
    this.noPublicIp = noPublicIp;
    return this;
  }

  /**
   * If true, no public IP will be assigned to this instance.
   * @return noPublicIp
   */
  @javax.annotation.Nullable
  public Boolean getNoPublicIp() {
    return noPublicIp;
  }

  public void setNoPublicIp(Boolean noPublicIp) {
    this.noPublicIp = noPublicIp;
  }


  public Instance noRemoveDataDisk(Boolean noRemoveDataDisk) {
    this.noRemoveDataDisk = noRemoveDataDisk;
    return this;
  }

  /**
   * Input only. If true, the data disk will not be auto deleted when deleting the instance.
   * @return noRemoveDataDisk
   */
  @javax.annotation.Nullable
  public Boolean getNoRemoveDataDisk() {
    return noRemoveDataDisk;
  }

  public void setNoRemoveDataDisk(Boolean noRemoveDataDisk) {
    this.noRemoveDataDisk = noRemoveDataDisk;
  }


  public Instance postStartupScript(String postStartupScript) {
    this.postStartupScript = postStartupScript;
    return this;
  }

  /**
   * Path to a Bash script that automatically runs after a notebook instance fully boots up. The path must be a URL or Cloud Storage path (&#x60;gs://path-to-file/file-name&#x60;).
   * @return postStartupScript
   */
  @javax.annotation.Nullable
  public String getPostStartupScript() {
    return postStartupScript;
  }

  public void setPostStartupScript(String postStartupScript) {
    this.postStartupScript = postStartupScript;
  }


  /**
   * Output only. The proxy endpoint that is used to access the Jupyter notebook.
   * @return proxyUri
   */
  @javax.annotation.Nullable
  public String getProxyUri() {
    return proxyUri;
  }



  public Instance reservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
    return this;
  }

  /**
   * Get reservationAffinity
   * @return reservationAffinity
   */
  @javax.annotation.Nullable
  public ReservationAffinity getReservationAffinity() {
    return reservationAffinity;
  }

  public void setReservationAffinity(ReservationAffinity reservationAffinity) {
    this.reservationAffinity = reservationAffinity;
  }


  public Instance serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * The service account on this instance, giving access to other Google Cloud services. You can use any service account within the same project, but you must have the service account user permission to use the instance. If not specified, the [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account) is used.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public Instance serviceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
    return this;
  }

  public Instance addServiceAccountScopesItem(String serviceAccountScopesItem) {
    if (this.serviceAccountScopes == null) {
      this.serviceAccountScopes = new ArrayList<>();
    }
    this.serviceAccountScopes.add(serviceAccountScopesItem);
    return this;
  }

  /**
   * Optional. The URIs of service account scopes to be included in Compute Engine instances. If not specified, the following [scopes](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam) are defined: - https://www.googleapis.com/auth/cloud-platform - https://www.googleapis.com/auth/userinfo.email If not using default scopes, you need at least: https://www.googleapis.com/auth/compute
   * @return serviceAccountScopes
   */
  @javax.annotation.Nullable
  public List<String> getServiceAccountScopes() {
    return serviceAccountScopes;
  }

  public void setServiceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
  }


  public Instance shieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
    return this;
  }

  /**
   * Get shieldedInstanceConfig
   * @return shieldedInstanceConfig
   */
  @javax.annotation.Nullable
  public ShieldedInstanceConfig getShieldedInstanceConfig() {
    return shieldedInstanceConfig;
  }

  public void setShieldedInstanceConfig(ShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
  }


  /**
   * Output only. The state of this instance.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  public Instance subnet(String subnet) {
    this.subnet = subnet;
    return this;
  }

  /**
   * The name of the subnet that this instance is in. Format: &#x60;projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}&#x60;
   * @return subnet
   */
  @javax.annotation.Nullable
  public String getSubnet() {
    return subnet;
  }

  public void setSubnet(String subnet) {
    this.subnet = subnet;
  }


  public Instance tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public Instance addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }


  /**
   * Output only. Instance update time.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  public Instance upgradeHistory(List<UpgradeHistoryEntry> upgradeHistory) {
    this.upgradeHistory = upgradeHistory;
    return this;
  }

  public Instance addUpgradeHistoryItem(UpgradeHistoryEntry upgradeHistoryItem) {
    if (this.upgradeHistory == null) {
      this.upgradeHistory = new ArrayList<>();
    }
    this.upgradeHistory.add(upgradeHistoryItem);
    return this;
  }

  /**
   * The upgrade history of this instance.
   * @return upgradeHistory
   */
  @javax.annotation.Nullable
  public List<UpgradeHistoryEntry> getUpgradeHistory() {
    return upgradeHistory;
  }

  public void setUpgradeHistory(List<UpgradeHistoryEntry> upgradeHistory) {
    this.upgradeHistory = upgradeHistory;
  }


  public Instance vmImage(VmImage vmImage) {
    this.vmImage = vmImage;
    return this;
  }

  /**
   * Get vmImage
   * @return vmImage
   */
  @javax.annotation.Nullable
  public VmImage getVmImage() {
    return vmImage;
  }

  public void setVmImage(VmImage vmImage) {
    this.vmImage = vmImage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Instance instance = (Instance) o;
    return Objects.equals(this.acceleratorConfig, instance.acceleratorConfig) &&
        Objects.equals(this.bootDiskSizeGb, instance.bootDiskSizeGb) &&
        Objects.equals(this.bootDiskType, instance.bootDiskType) &&
        Objects.equals(this.canIpForward, instance.canIpForward) &&
        Objects.equals(this.containerImage, instance.containerImage) &&
        Objects.equals(this.createTime, instance.createTime) &&
        Objects.equals(this.creator, instance.creator) &&
        Objects.equals(this.customGpuDriverPath, instance.customGpuDriverPath) &&
        Objects.equals(this.dataDiskSizeGb, instance.dataDiskSizeGb) &&
        Objects.equals(this.dataDiskType, instance.dataDiskType) &&
        Objects.equals(this.diskEncryption, instance.diskEncryption) &&
        Objects.equals(this.disks, instance.disks) &&
        Objects.equals(this.installGpuDriver, instance.installGpuDriver) &&
        Objects.equals(this.instanceOwners, instance.instanceOwners) &&
        Objects.equals(this.kmsKey, instance.kmsKey) &&
        Objects.equals(this.labels, instance.labels) &&
        Objects.equals(this.machineType, instance.machineType) &&
        Objects.equals(this.metadata, instance.metadata) &&
        Objects.equals(this.name, instance.name) &&
        Objects.equals(this.network, instance.network) &&
        Objects.equals(this.nicType, instance.nicType) &&
        Objects.equals(this.noProxyAccess, instance.noProxyAccess) &&
        Objects.equals(this.noPublicIp, instance.noPublicIp) &&
        Objects.equals(this.noRemoveDataDisk, instance.noRemoveDataDisk) &&
        Objects.equals(this.postStartupScript, instance.postStartupScript) &&
        Objects.equals(this.proxyUri, instance.proxyUri) &&
        Objects.equals(this.reservationAffinity, instance.reservationAffinity) &&
        Objects.equals(this.serviceAccount, instance.serviceAccount) &&
        Objects.equals(this.serviceAccountScopes, instance.serviceAccountScopes) &&
        Objects.equals(this.shieldedInstanceConfig, instance.shieldedInstanceConfig) &&
        Objects.equals(this.state, instance.state) &&
        Objects.equals(this.subnet, instance.subnet) &&
        Objects.equals(this.tags, instance.tags) &&
        Objects.equals(this.updateTime, instance.updateTime) &&
        Objects.equals(this.upgradeHistory, instance.upgradeHistory) &&
        Objects.equals(this.vmImage, instance.vmImage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceleratorConfig, bootDiskSizeGb, bootDiskType, canIpForward, containerImage, createTime, creator, customGpuDriverPath, dataDiskSizeGb, dataDiskType, diskEncryption, disks, installGpuDriver, instanceOwners, kmsKey, labels, machineType, metadata, name, network, nicType, noProxyAccess, noPublicIp, noRemoveDataDisk, postStartupScript, proxyUri, reservationAffinity, serviceAccount, serviceAccountScopes, shieldedInstanceConfig, state, subnet, tags, updateTime, upgradeHistory, vmImage);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Instance {\n");
    sb.append("    acceleratorConfig: ").append(toIndentedString(acceleratorConfig)).append("\n");
    sb.append("    bootDiskSizeGb: ").append(toIndentedString(bootDiskSizeGb)).append("\n");
    sb.append("    bootDiskType: ").append(toIndentedString(bootDiskType)).append("\n");
    sb.append("    canIpForward: ").append(toIndentedString(canIpForward)).append("\n");
    sb.append("    containerImage: ").append(toIndentedString(containerImage)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    creator: ").append(toIndentedString(creator)).append("\n");
    sb.append("    customGpuDriverPath: ").append(toIndentedString(customGpuDriverPath)).append("\n");
    sb.append("    dataDiskSizeGb: ").append(toIndentedString(dataDiskSizeGb)).append("\n");
    sb.append("    dataDiskType: ").append(toIndentedString(dataDiskType)).append("\n");
    sb.append("    diskEncryption: ").append(toIndentedString(diskEncryption)).append("\n");
    sb.append("    disks: ").append(toIndentedString(disks)).append("\n");
    sb.append("    installGpuDriver: ").append(toIndentedString(installGpuDriver)).append("\n");
    sb.append("    instanceOwners: ").append(toIndentedString(instanceOwners)).append("\n");
    sb.append("    kmsKey: ").append(toIndentedString(kmsKey)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    nicType: ").append(toIndentedString(nicType)).append("\n");
    sb.append("    noProxyAccess: ").append(toIndentedString(noProxyAccess)).append("\n");
    sb.append("    noPublicIp: ").append(toIndentedString(noPublicIp)).append("\n");
    sb.append("    noRemoveDataDisk: ").append(toIndentedString(noRemoveDataDisk)).append("\n");
    sb.append("    postStartupScript: ").append(toIndentedString(postStartupScript)).append("\n");
    sb.append("    proxyUri: ").append(toIndentedString(proxyUri)).append("\n");
    sb.append("    reservationAffinity: ").append(toIndentedString(reservationAffinity)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    serviceAccountScopes: ").append(toIndentedString(serviceAccountScopes)).append("\n");
    sb.append("    shieldedInstanceConfig: ").append(toIndentedString(shieldedInstanceConfig)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    subnet: ").append(toIndentedString(subnet)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    upgradeHistory: ").append(toIndentedString(upgradeHistory)).append("\n");
    sb.append("    vmImage: ").append(toIndentedString(vmImage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceleratorConfig");
    openapiFields.add("bootDiskSizeGb");
    openapiFields.add("bootDiskType");
    openapiFields.add("canIpForward");
    openapiFields.add("containerImage");
    openapiFields.add("createTime");
    openapiFields.add("creator");
    openapiFields.add("customGpuDriverPath");
    openapiFields.add("dataDiskSizeGb");
    openapiFields.add("dataDiskType");
    openapiFields.add("diskEncryption");
    openapiFields.add("disks");
    openapiFields.add("installGpuDriver");
    openapiFields.add("instanceOwners");
    openapiFields.add("kmsKey");
    openapiFields.add("labels");
    openapiFields.add("machineType");
    openapiFields.add("metadata");
    openapiFields.add("name");
    openapiFields.add("network");
    openapiFields.add("nicType");
    openapiFields.add("noProxyAccess");
    openapiFields.add("noPublicIp");
    openapiFields.add("noRemoveDataDisk");
    openapiFields.add("postStartupScript");
    openapiFields.add("proxyUri");
    openapiFields.add("reservationAffinity");
    openapiFields.add("serviceAccount");
    openapiFields.add("serviceAccountScopes");
    openapiFields.add("shieldedInstanceConfig");
    openapiFields.add("state");
    openapiFields.add("subnet");
    openapiFields.add("tags");
    openapiFields.add("updateTime");
    openapiFields.add("upgradeHistory");
    openapiFields.add("vmImage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Instance
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Instance.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Instance is not found in the empty JSON string", Instance.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Instance.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Instance` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `acceleratorConfig`
      if (jsonObj.get("acceleratorConfig") != null && !jsonObj.get("acceleratorConfig").isJsonNull()) {
        AcceleratorConfig.validateJsonElement(jsonObj.get("acceleratorConfig"));
      }
      if ((jsonObj.get("bootDiskSizeGb") != null && !jsonObj.get("bootDiskSizeGb").isJsonNull()) && !jsonObj.get("bootDiskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskSizeGb").toString()));
      }
      if ((jsonObj.get("bootDiskType") != null && !jsonObj.get("bootDiskType").isJsonNull()) && !jsonObj.get("bootDiskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskType").toString()));
      }
      // validate the optional field `bootDiskType`
      if (jsonObj.get("bootDiskType") != null && !jsonObj.get("bootDiskType").isJsonNull()) {
        BootDiskTypeEnum.validateJsonElement(jsonObj.get("bootDiskType"));
      }
      // validate the optional field `containerImage`
      if (jsonObj.get("containerImage") != null && !jsonObj.get("containerImage").isJsonNull()) {
        ContainerImage.validateJsonElement(jsonObj.get("containerImage"));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("creator") != null && !jsonObj.get("creator").isJsonNull()) && !jsonObj.get("creator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creator").toString()));
      }
      if ((jsonObj.get("customGpuDriverPath") != null && !jsonObj.get("customGpuDriverPath").isJsonNull()) && !jsonObj.get("customGpuDriverPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customGpuDriverPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customGpuDriverPath").toString()));
      }
      if ((jsonObj.get("dataDiskSizeGb") != null && !jsonObj.get("dataDiskSizeGb").isJsonNull()) && !jsonObj.get("dataDiskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskSizeGb").toString()));
      }
      if ((jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) && !jsonObj.get("dataDiskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskType").toString()));
      }
      // validate the optional field `dataDiskType`
      if (jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) {
        DataDiskTypeEnum.validateJsonElement(jsonObj.get("dataDiskType"));
      }
      if ((jsonObj.get("diskEncryption") != null && !jsonObj.get("diskEncryption").isJsonNull()) && !jsonObj.get("diskEncryption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskEncryption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskEncryption").toString()));
      }
      // validate the optional field `diskEncryption`
      if (jsonObj.get("diskEncryption") != null && !jsonObj.get("diskEncryption").isJsonNull()) {
        DiskEncryptionEnum.validateJsonElement(jsonObj.get("diskEncryption"));
      }
      if (jsonObj.get("disks") != null && !jsonObj.get("disks").isJsonNull()) {
        JsonArray jsonArraydisks = jsonObj.getAsJsonArray("disks");
        if (jsonArraydisks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("disks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `disks` to be an array in the JSON string but got `%s`", jsonObj.get("disks").toString()));
          }

          // validate the optional field `disks` (array)
          for (int i = 0; i < jsonArraydisks.size(); i++) {
            Disk.validateJsonElement(jsonArraydisks.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instanceOwners") != null && !jsonObj.get("instanceOwners").isJsonNull() && !jsonObj.get("instanceOwners").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceOwners` to be an array in the JSON string but got `%s`", jsonObj.get("instanceOwners").toString()));
      }
      if ((jsonObj.get("kmsKey") != null && !jsonObj.get("kmsKey").isJsonNull()) && !jsonObj.get("kmsKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKey").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("nicType") != null && !jsonObj.get("nicType").isJsonNull()) && !jsonObj.get("nicType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nicType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nicType").toString()));
      }
      // validate the optional field `nicType`
      if (jsonObj.get("nicType") != null && !jsonObj.get("nicType").isJsonNull()) {
        NicTypeEnum.validateJsonElement(jsonObj.get("nicType"));
      }
      if ((jsonObj.get("postStartupScript") != null && !jsonObj.get("postStartupScript").isJsonNull()) && !jsonObj.get("postStartupScript").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postStartupScript` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postStartupScript").toString()));
      }
      if ((jsonObj.get("proxyUri") != null && !jsonObj.get("proxyUri").isJsonNull()) && !jsonObj.get("proxyUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `proxyUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("proxyUri").toString()));
      }
      // validate the optional field `reservationAffinity`
      if (jsonObj.get("reservationAffinity") != null && !jsonObj.get("reservationAffinity").isJsonNull()) {
        ReservationAffinity.validateJsonElement(jsonObj.get("reservationAffinity"));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("serviceAccountScopes") != null && !jsonObj.get("serviceAccountScopes").isJsonNull() && !jsonObj.get("serviceAccountScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountScopes` to be an array in the JSON string but got `%s`", jsonObj.get("serviceAccountScopes").toString()));
      }
      // validate the optional field `shieldedInstanceConfig`
      if (jsonObj.get("shieldedInstanceConfig") != null && !jsonObj.get("shieldedInstanceConfig").isJsonNull()) {
        ShieldedInstanceConfig.validateJsonElement(jsonObj.get("shieldedInstanceConfig"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("subnet") != null && !jsonObj.get("subnet").isJsonNull()) && !jsonObj.get("subnet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      if (jsonObj.get("upgradeHistory") != null && !jsonObj.get("upgradeHistory").isJsonNull()) {
        JsonArray jsonArrayupgradeHistory = jsonObj.getAsJsonArray("upgradeHistory");
        if (jsonArrayupgradeHistory != null) {
          // ensure the json data is an array
          if (!jsonObj.get("upgradeHistory").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `upgradeHistory` to be an array in the JSON string but got `%s`", jsonObj.get("upgradeHistory").toString()));
          }

          // validate the optional field `upgradeHistory` (array)
          for (int i = 0; i < jsonArrayupgradeHistory.size(); i++) {
            UpgradeHistoryEntry.validateJsonElement(jsonArrayupgradeHistory.get(i));
          };
        }
      }
      // validate the optional field `vmImage`
      if (jsonObj.get("vmImage") != null && !jsonObj.get("vmImage").isJsonNull()) {
        VmImage.validateJsonElement(jsonObj.get("vmImage"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Instance.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Instance' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Instance> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Instance.class));

       return (TypeAdapter<T>) new TypeAdapter<Instance>() {
           @Override
           public void write(JsonWriter out, Instance value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Instance read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Instance given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Instance
   * @throws IOException if the JSON string is invalid with respect to Instance
   */
  public static Instance fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Instance.class);
  }

  /**
   * Convert an instance of Instance to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

