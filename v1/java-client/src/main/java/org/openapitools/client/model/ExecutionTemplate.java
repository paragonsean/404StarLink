/*
 * Notebooks API
 * Notebooks API is used to manage notebook resources in Google Cloud.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.DataprocParameters;
import org.openapitools.client.model.SchedulerAcceleratorConfig;
import org.openapitools.client.model.VertexAIParameters;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The description a notebook execution workload.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:09:43.451204-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExecutionTemplate {
  public static final String SERIALIZED_NAME_ACCELERATOR_CONFIG = "acceleratorConfig";
  @SerializedName(SERIALIZED_NAME_ACCELERATOR_CONFIG)
  private SchedulerAcceleratorConfig acceleratorConfig;

  public static final String SERIALIZED_NAME_CONTAINER_IMAGE_URI = "containerImageUri";
  @SerializedName(SERIALIZED_NAME_CONTAINER_IMAGE_URI)
  private String containerImageUri;

  public static final String SERIALIZED_NAME_DATAPROC_PARAMETERS = "dataprocParameters";
  @SerializedName(SERIALIZED_NAME_DATAPROC_PARAMETERS)
  private DataprocParameters dataprocParameters;

  public static final String SERIALIZED_NAME_INPUT_NOTEBOOK_FILE = "inputNotebookFile";
  @SerializedName(SERIALIZED_NAME_INPUT_NOTEBOOK_FILE)
  private String inputNotebookFile;

  /**
   * The type of Job to be used on this execution.
   */
  @JsonAdapter(JobTypeEnum.Adapter.class)
  public enum JobTypeEnum {
    JOB_TYPE_UNSPECIFIED("JOB_TYPE_UNSPECIFIED"),
    
    VERTEX_AI("VERTEX_AI"),
    
    DATAPROC("DATAPROC");

    private String value;

    JobTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static JobTypeEnum fromValue(String value) {
      for (JobTypeEnum b : JobTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<JobTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final JobTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public JobTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return JobTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      JobTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_JOB_TYPE = "jobType";
  @SerializedName(SERIALIZED_NAME_JOB_TYPE)
  private JobTypeEnum jobType;

  public static final String SERIALIZED_NAME_KERNEL_SPEC = "kernelSpec";
  @SerializedName(SERIALIZED_NAME_KERNEL_SPEC)
  private String kernelSpec;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MASTER_TYPE = "masterType";
  @SerializedName(SERIALIZED_NAME_MASTER_TYPE)
  private String masterType;

  public static final String SERIALIZED_NAME_OUTPUT_NOTEBOOK_FOLDER = "outputNotebookFolder";
  @SerializedName(SERIALIZED_NAME_OUTPUT_NOTEBOOK_FOLDER)
  private String outputNotebookFolder;

  public static final String SERIALIZED_NAME_PARAMETERS = "parameters";
  @SerializedName(SERIALIZED_NAME_PARAMETERS)
  private String parameters;

  public static final String SERIALIZED_NAME_PARAMS_YAML_FILE = "paramsYamlFile";
  @SerializedName(SERIALIZED_NAME_PARAMS_YAML_FILE)
  private String paramsYamlFile;

  /**
   * Required. Scale tier of the hardware used for notebook execution. DEPRECATED Will be discontinued. As right now only CUSTOM is supported.
   */
  @JsonAdapter(ScaleTierEnum.Adapter.class)
  public enum ScaleTierEnum {
    SCALE_TIER_UNSPECIFIED("SCALE_TIER_UNSPECIFIED"),
    
    BASIC("BASIC"),
    
    STANDARD_1("STANDARD_1"),
    
    PREMIUM_1("PREMIUM_1"),
    
    BASIC_GPU("BASIC_GPU"),
    
    BASIC_TPU("BASIC_TPU"),
    
    CUSTOM("CUSTOM");

    private String value;

    ScaleTierEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ScaleTierEnum fromValue(String value) {
      for (ScaleTierEnum b : ScaleTierEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ScaleTierEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ScaleTierEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ScaleTierEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ScaleTierEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ScaleTierEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCALE_TIER = "scaleTier";
  @SerializedName(SERIALIZED_NAME_SCALE_TIER)
  private ScaleTierEnum scaleTier;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_TENSORBOARD = "tensorboard";
  @SerializedName(SERIALIZED_NAME_TENSORBOARD)
  private String tensorboard;

  public static final String SERIALIZED_NAME_VERTEX_AI_PARAMETERS = "vertexAiParameters";
  @SerializedName(SERIALIZED_NAME_VERTEX_AI_PARAMETERS)
  private VertexAIParameters vertexAiParameters;

  public ExecutionTemplate() {
  }

  public ExecutionTemplate acceleratorConfig(SchedulerAcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
    return this;
  }

  /**
   * Get acceleratorConfig
   * @return acceleratorConfig
   */
  @javax.annotation.Nullable
  public SchedulerAcceleratorConfig getAcceleratorConfig() {
    return acceleratorConfig;
  }

  public void setAcceleratorConfig(SchedulerAcceleratorConfig acceleratorConfig) {
    this.acceleratorConfig = acceleratorConfig;
  }


  public ExecutionTemplate containerImageUri(String containerImageUri) {
    this.containerImageUri = containerImageUri;
    return this;
  }

  /**
   * Container Image URI to a DLVM Example: &#39;gcr.io/deeplearning-platform-release/base-cu100&#39; More examples can be found at: https://cloud.google.com/ai-platform/deep-learning-containers/docs/choosing-container
   * @return containerImageUri
   */
  @javax.annotation.Nullable
  public String getContainerImageUri() {
    return containerImageUri;
  }

  public void setContainerImageUri(String containerImageUri) {
    this.containerImageUri = containerImageUri;
  }


  public ExecutionTemplate dataprocParameters(DataprocParameters dataprocParameters) {
    this.dataprocParameters = dataprocParameters;
    return this;
  }

  /**
   * Get dataprocParameters
   * @return dataprocParameters
   */
  @javax.annotation.Nullable
  public DataprocParameters getDataprocParameters() {
    return dataprocParameters;
  }

  public void setDataprocParameters(DataprocParameters dataprocParameters) {
    this.dataprocParameters = dataprocParameters;
  }


  public ExecutionTemplate inputNotebookFile(String inputNotebookFile) {
    this.inputNotebookFile = inputNotebookFile;
    return this;
  }

  /**
   * Path to the notebook file to execute. Must be in a Google Cloud Storage bucket. Format: &#x60;gs://{bucket_name}/{folder}/{notebook_file_name}&#x60; Ex: &#x60;gs://notebook_user/scheduled_notebooks/sentiment_notebook.ipynb&#x60;
   * @return inputNotebookFile
   */
  @javax.annotation.Nullable
  public String getInputNotebookFile() {
    return inputNotebookFile;
  }

  public void setInputNotebookFile(String inputNotebookFile) {
    this.inputNotebookFile = inputNotebookFile;
  }


  public ExecutionTemplate jobType(JobTypeEnum jobType) {
    this.jobType = jobType;
    return this;
  }

  /**
   * The type of Job to be used on this execution.
   * @return jobType
   */
  @javax.annotation.Nullable
  public JobTypeEnum getJobType() {
    return jobType;
  }

  public void setJobType(JobTypeEnum jobType) {
    this.jobType = jobType;
  }


  public ExecutionTemplate kernelSpec(String kernelSpec) {
    this.kernelSpec = kernelSpec;
    return this;
  }

  /**
   * Name of the kernel spec to use. This must be specified if the kernel spec name on the execution target does not match the name in the input notebook file.
   * @return kernelSpec
   */
  @javax.annotation.Nullable
  public String getKernelSpec() {
    return kernelSpec;
  }

  public void setKernelSpec(String kernelSpec) {
    this.kernelSpec = kernelSpec;
  }


  public ExecutionTemplate labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public ExecutionTemplate putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels for execution. If execution is scheduled, a field included will be &#39;nbs-scheduled&#39;. Otherwise, it is an immediate execution, and an included field will be &#39;nbs-immediate&#39;. Use fields to efficiently index between various types of executions.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public ExecutionTemplate masterType(String masterType) {
    this.masterType = masterType;
    return this;
  }

  /**
   * Specifies the type of virtual machine to use for your training job&#39;s master worker. You must specify this field when &#x60;scaleTier&#x60; is set to &#x60;CUSTOM&#x60;. You can use certain Compute Engine machine types directly in this field. The following types are supported: - &#x60;n1-standard-4&#x60; - &#x60;n1-standard-8&#x60; - &#x60;n1-standard-16&#x60; - &#x60;n1-standard-32&#x60; - &#x60;n1-standard-64&#x60; - &#x60;n1-standard-96&#x60; - &#x60;n1-highmem-2&#x60; - &#x60;n1-highmem-4&#x60; - &#x60;n1-highmem-8&#x60; - &#x60;n1-highmem-16&#x60; - &#x60;n1-highmem-32&#x60; - &#x60;n1-highmem-64&#x60; - &#x60;n1-highmem-96&#x60; - &#x60;n1-highcpu-16&#x60; - &#x60;n1-highcpu-32&#x60; - &#x60;n1-highcpu-64&#x60; - &#x60;n1-highcpu-96&#x60; Alternatively, you can use the following legacy machine types: - &#x60;standard&#x60; - &#x60;large_model&#x60; - &#x60;complex_model_s&#x60; - &#x60;complex_model_m&#x60; - &#x60;complex_model_l&#x60; - &#x60;standard_gpu&#x60; - &#x60;complex_model_m_gpu&#x60; - &#x60;complex_model_l_gpu&#x60; - &#x60;standard_p100&#x60; - &#x60;complex_model_m_p100&#x60; - &#x60;standard_v100&#x60; - &#x60;large_model_v100&#x60; - &#x60;complex_model_m_v100&#x60; - &#x60;complex_model_l_v100&#x60; Finally, if you want to use a TPU for training, specify &#x60;cloud_tpu&#x60; in this field. Learn more about the [special configuration options for training with TPU](https://cloud.google.com/ai-platform/training/docs/using-tpus#configuring_a_custom_tpu_machine).
   * @return masterType
   */
  @javax.annotation.Nullable
  public String getMasterType() {
    return masterType;
  }

  public void setMasterType(String masterType) {
    this.masterType = masterType;
  }


  public ExecutionTemplate outputNotebookFolder(String outputNotebookFolder) {
    this.outputNotebookFolder = outputNotebookFolder;
    return this;
  }

  /**
   * Path to the notebook folder to write to. Must be in a Google Cloud Storage bucket path. Format: &#x60;gs://{bucket_name}/{folder}&#x60; Ex: &#x60;gs://notebook_user/scheduled_notebooks&#x60;
   * @return outputNotebookFolder
   */
  @javax.annotation.Nullable
  public String getOutputNotebookFolder() {
    return outputNotebookFolder;
  }

  public void setOutputNotebookFolder(String outputNotebookFolder) {
    this.outputNotebookFolder = outputNotebookFolder;
  }


  public ExecutionTemplate parameters(String parameters) {
    this.parameters = parameters;
    return this;
  }

  /**
   * Parameters used within the &#39;input_notebook_file&#39; notebook.
   * @return parameters
   */
  @javax.annotation.Nullable
  public String getParameters() {
    return parameters;
  }

  public void setParameters(String parameters) {
    this.parameters = parameters;
  }


  public ExecutionTemplate paramsYamlFile(String paramsYamlFile) {
    this.paramsYamlFile = paramsYamlFile;
    return this;
  }

  /**
   * Parameters to be overridden in the notebook during execution. Ref https://papermill.readthedocs.io/en/latest/usage-parameterize.html on how to specifying parameters in the input notebook and pass them here in an YAML file. Ex: &#x60;gs://notebook_user/scheduled_notebooks/sentiment_notebook_params.yaml&#x60;
   * @return paramsYamlFile
   */
  @javax.annotation.Nullable
  public String getParamsYamlFile() {
    return paramsYamlFile;
  }

  public void setParamsYamlFile(String paramsYamlFile) {
    this.paramsYamlFile = paramsYamlFile;
  }


  public ExecutionTemplate scaleTier(ScaleTierEnum scaleTier) {
    this.scaleTier = scaleTier;
    return this;
  }

  /**
   * Required. Scale tier of the hardware used for notebook execution. DEPRECATED Will be discontinued. As right now only CUSTOM is supported.
   * @return scaleTier
   */
  @javax.annotation.Nullable
  public ScaleTierEnum getScaleTier() {
    return scaleTier;
  }

  public void setScaleTier(ScaleTierEnum scaleTier) {
    this.scaleTier = scaleTier;
  }


  public ExecutionTemplate serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * The email address of a service account to use when running the execution. You must have the &#x60;iam.serviceAccounts.actAs&#x60; permission for the specified service account.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public ExecutionTemplate tensorboard(String tensorboard) {
    this.tensorboard = tensorboard;
    return this;
  }

  /**
   * The name of a Vertex AI [Tensorboard] resource to which this execution will upload Tensorboard logs. Format: &#x60;projects/{project}/locations/{location}/tensorboards/{tensorboard}&#x60;
   * @return tensorboard
   */
  @javax.annotation.Nullable
  public String getTensorboard() {
    return tensorboard;
  }

  public void setTensorboard(String tensorboard) {
    this.tensorboard = tensorboard;
  }


  public ExecutionTemplate vertexAiParameters(VertexAIParameters vertexAiParameters) {
    this.vertexAiParameters = vertexAiParameters;
    return this;
  }

  /**
   * Get vertexAiParameters
   * @return vertexAiParameters
   */
  @javax.annotation.Nullable
  public VertexAIParameters getVertexAiParameters() {
    return vertexAiParameters;
  }

  public void setVertexAiParameters(VertexAIParameters vertexAiParameters) {
    this.vertexAiParameters = vertexAiParameters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExecutionTemplate executionTemplate = (ExecutionTemplate) o;
    return Objects.equals(this.acceleratorConfig, executionTemplate.acceleratorConfig) &&
        Objects.equals(this.containerImageUri, executionTemplate.containerImageUri) &&
        Objects.equals(this.dataprocParameters, executionTemplate.dataprocParameters) &&
        Objects.equals(this.inputNotebookFile, executionTemplate.inputNotebookFile) &&
        Objects.equals(this.jobType, executionTemplate.jobType) &&
        Objects.equals(this.kernelSpec, executionTemplate.kernelSpec) &&
        Objects.equals(this.labels, executionTemplate.labels) &&
        Objects.equals(this.masterType, executionTemplate.masterType) &&
        Objects.equals(this.outputNotebookFolder, executionTemplate.outputNotebookFolder) &&
        Objects.equals(this.parameters, executionTemplate.parameters) &&
        Objects.equals(this.paramsYamlFile, executionTemplate.paramsYamlFile) &&
        Objects.equals(this.scaleTier, executionTemplate.scaleTier) &&
        Objects.equals(this.serviceAccount, executionTemplate.serviceAccount) &&
        Objects.equals(this.tensorboard, executionTemplate.tensorboard) &&
        Objects.equals(this.vertexAiParameters, executionTemplate.vertexAiParameters);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceleratorConfig, containerImageUri, dataprocParameters, inputNotebookFile, jobType, kernelSpec, labels, masterType, outputNotebookFolder, parameters, paramsYamlFile, scaleTier, serviceAccount, tensorboard, vertexAiParameters);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExecutionTemplate {\n");
    sb.append("    acceleratorConfig: ").append(toIndentedString(acceleratorConfig)).append("\n");
    sb.append("    containerImageUri: ").append(toIndentedString(containerImageUri)).append("\n");
    sb.append("    dataprocParameters: ").append(toIndentedString(dataprocParameters)).append("\n");
    sb.append("    inputNotebookFile: ").append(toIndentedString(inputNotebookFile)).append("\n");
    sb.append("    jobType: ").append(toIndentedString(jobType)).append("\n");
    sb.append("    kernelSpec: ").append(toIndentedString(kernelSpec)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    masterType: ").append(toIndentedString(masterType)).append("\n");
    sb.append("    outputNotebookFolder: ").append(toIndentedString(outputNotebookFolder)).append("\n");
    sb.append("    parameters: ").append(toIndentedString(parameters)).append("\n");
    sb.append("    paramsYamlFile: ").append(toIndentedString(paramsYamlFile)).append("\n");
    sb.append("    scaleTier: ").append(toIndentedString(scaleTier)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    tensorboard: ").append(toIndentedString(tensorboard)).append("\n");
    sb.append("    vertexAiParameters: ").append(toIndentedString(vertexAiParameters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceleratorConfig");
    openapiFields.add("containerImageUri");
    openapiFields.add("dataprocParameters");
    openapiFields.add("inputNotebookFile");
    openapiFields.add("jobType");
    openapiFields.add("kernelSpec");
    openapiFields.add("labels");
    openapiFields.add("masterType");
    openapiFields.add("outputNotebookFolder");
    openapiFields.add("parameters");
    openapiFields.add("paramsYamlFile");
    openapiFields.add("scaleTier");
    openapiFields.add("serviceAccount");
    openapiFields.add("tensorboard");
    openapiFields.add("vertexAiParameters");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExecutionTemplate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExecutionTemplate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExecutionTemplate is not found in the empty JSON string", ExecutionTemplate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExecutionTemplate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExecutionTemplate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `acceleratorConfig`
      if (jsonObj.get("acceleratorConfig") != null && !jsonObj.get("acceleratorConfig").isJsonNull()) {
        SchedulerAcceleratorConfig.validateJsonElement(jsonObj.get("acceleratorConfig"));
      }
      if ((jsonObj.get("containerImageUri") != null && !jsonObj.get("containerImageUri").isJsonNull()) && !jsonObj.get("containerImageUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerImageUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("containerImageUri").toString()));
      }
      // validate the optional field `dataprocParameters`
      if (jsonObj.get("dataprocParameters") != null && !jsonObj.get("dataprocParameters").isJsonNull()) {
        DataprocParameters.validateJsonElement(jsonObj.get("dataprocParameters"));
      }
      if ((jsonObj.get("inputNotebookFile") != null && !jsonObj.get("inputNotebookFile").isJsonNull()) && !jsonObj.get("inputNotebookFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inputNotebookFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inputNotebookFile").toString()));
      }
      if ((jsonObj.get("jobType") != null && !jsonObj.get("jobType").isJsonNull()) && !jsonObj.get("jobType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jobType").toString()));
      }
      // validate the optional field `jobType`
      if (jsonObj.get("jobType") != null && !jsonObj.get("jobType").isJsonNull()) {
        JobTypeEnum.validateJsonElement(jsonObj.get("jobType"));
      }
      if ((jsonObj.get("kernelSpec") != null && !jsonObj.get("kernelSpec").isJsonNull()) && !jsonObj.get("kernelSpec").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kernelSpec` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kernelSpec").toString()));
      }
      if ((jsonObj.get("masterType") != null && !jsonObj.get("masterType").isJsonNull()) && !jsonObj.get("masterType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `masterType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("masterType").toString()));
      }
      if ((jsonObj.get("outputNotebookFolder") != null && !jsonObj.get("outputNotebookFolder").isJsonNull()) && !jsonObj.get("outputNotebookFolder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputNotebookFolder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputNotebookFolder").toString()));
      }
      if ((jsonObj.get("parameters") != null && !jsonObj.get("parameters").isJsonNull()) && !jsonObj.get("parameters").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parameters` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parameters").toString()));
      }
      if ((jsonObj.get("paramsYamlFile") != null && !jsonObj.get("paramsYamlFile").isJsonNull()) && !jsonObj.get("paramsYamlFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paramsYamlFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paramsYamlFile").toString()));
      }
      if ((jsonObj.get("scaleTier") != null && !jsonObj.get("scaleTier").isJsonNull()) && !jsonObj.get("scaleTier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scaleTier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scaleTier").toString()));
      }
      // validate the optional field `scaleTier`
      if (jsonObj.get("scaleTier") != null && !jsonObj.get("scaleTier").isJsonNull()) {
        ScaleTierEnum.validateJsonElement(jsonObj.get("scaleTier"));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      if ((jsonObj.get("tensorboard") != null && !jsonObj.get("tensorboard").isJsonNull()) && !jsonObj.get("tensorboard").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tensorboard` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tensorboard").toString()));
      }
      // validate the optional field `vertexAiParameters`
      if (jsonObj.get("vertexAiParameters") != null && !jsonObj.get("vertexAiParameters").isJsonNull()) {
        VertexAIParameters.validateJsonElement(jsonObj.get("vertexAiParameters"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExecutionTemplate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExecutionTemplate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExecutionTemplate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExecutionTemplate.class));

       return (TypeAdapter<T>) new TypeAdapter<ExecutionTemplate>() {
           @Override
           public void write(JsonWriter out, ExecutionTemplate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExecutionTemplate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExecutionTemplate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExecutionTemplate
   * @throws IOException if the JSON string is invalid with respect to ExecutionTemplate
   */
  public static ExecutionTemplate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExecutionTemplate.class);
  }

  /**
   * Convert an instance of ExecutionTemplate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

