/*
 * Notebooks API
 * Notebooks API is used to manage notebook resources in Google Cloud.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.LocalDiskInitializeParams;
import org.openapitools.client.model.RuntimeGuestOsFeature;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Local attached disk resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:00:12.602654-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LocalDisk {
  public static final String SERIALIZED_NAME_AUTO_DELETE = "autoDelete";
  @SerializedName(SERIALIZED_NAME_AUTO_DELETE)
  private Boolean autoDelete;

  public static final String SERIALIZED_NAME_BOOT = "boot";
  @SerializedName(SERIALIZED_NAME_BOOT)
  private Boolean boot;

  public static final String SERIALIZED_NAME_DEVICE_NAME = "deviceName";
  @SerializedName(SERIALIZED_NAME_DEVICE_NAME)
  private String deviceName;

  public static final String SERIALIZED_NAME_GUEST_OS_FEATURES = "guestOsFeatures";
  @SerializedName(SERIALIZED_NAME_GUEST_OS_FEATURES)
  private List<RuntimeGuestOsFeature> guestOsFeatures = new ArrayList<>();

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private Integer index;

  public static final String SERIALIZED_NAME_INITIALIZE_PARAMS = "initializeParams";
  @SerializedName(SERIALIZED_NAME_INITIALIZE_PARAMS)
  private LocalDiskInitializeParams initializeParams;

  public static final String SERIALIZED_NAME_INTERFACE = "interface";
  @SerializedName(SERIALIZED_NAME_INTERFACE)
  private String _interface;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_LICENSES = "licenses";
  @SerializedName(SERIALIZED_NAME_LICENSES)
  private List<String> licenses = new ArrayList<>();

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private String mode;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public LocalDisk() {
  }

  public LocalDisk(
     Boolean autoDelete, 
     Boolean boot, 
     String deviceName, 
     List<RuntimeGuestOsFeature> guestOsFeatures, 
     Integer index, 
     String kind, 
     List<String> licenses
  ) {
    this();
    this.autoDelete = autoDelete;
    this.boot = boot;
    this.deviceName = deviceName;
    this.guestOsFeatures = guestOsFeatures;
    this.index = index;
    this.kind = kind;
    this.licenses = licenses;
  }

  /**
   * Optional. Output only. Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
   * @return autoDelete
   */
  @javax.annotation.Nullable
  public Boolean getAutoDelete() {
    return autoDelete;
  }



  /**
   * Optional. Output only. Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
   * @return boot
   */
  @javax.annotation.Nullable
  public Boolean getBoot() {
    return boot;
  }



  /**
   * Optional. Output only. Specifies a unique device name of your choice that is reflected into the &#x60;/dev/disk/by-id/google-*&#x60; tree of a Linux operating system running within the instance. This name can be used to reference the device for mounting, resizing, and so on, from within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine. This field is only applicable for persistent disks.
   * @return deviceName
   */
  @javax.annotation.Nullable
  public String getDeviceName() {
    return deviceName;
  }



  /**
   * Output only. Indicates a list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
   * @return guestOsFeatures
   */
  @javax.annotation.Nullable
  public List<RuntimeGuestOsFeature> getGuestOsFeatures() {
    return guestOsFeatures;
  }



  /**
   * Output only. A zero-based index to this disk, where 0 is reserved for the boot disk. If you have many disks attached to an instance, each disk would have a unique index number.
   * @return index
   */
  @javax.annotation.Nullable
  public Integer getIndex() {
    return index;
  }



  public LocalDisk initializeParams(LocalDiskInitializeParams initializeParams) {
    this.initializeParams = initializeParams;
    return this;
  }

  /**
   * Get initializeParams
   * @return initializeParams
   */
  @javax.annotation.Nullable
  public LocalDiskInitializeParams getInitializeParams() {
    return initializeParams;
  }

  public void setInitializeParams(LocalDiskInitializeParams initializeParams) {
    this.initializeParams = initializeParams;
  }


  public LocalDisk _interface(String _interface) {
    this._interface = _interface;
    return this;
  }

  /**
   * Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance. Valid values: * &#x60;NVME&#x60; * &#x60;SCSI&#x60;
   * @return _interface
   */
  @javax.annotation.Nullable
  public String getInterface() {
    return _interface;
  }

  public void setInterface(String _interface) {
    this._interface = _interface;
  }


  /**
   * Output only. Type of the resource. Always compute#attachedDisk for attached disks.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }



  /**
   * Output only. Any valid publicly visible licenses.
   * @return licenses
   */
  @javax.annotation.Nullable
  public List<String> getLicenses() {
    return licenses;
  }



  public LocalDisk mode(String mode) {
    this.mode = mode;
    return this;
  }

  /**
   * The mode in which to attach this disk, either &#x60;READ_WRITE&#x60; or &#x60;READ_ONLY&#x60;. If not specified, the default is to attach the disk in &#x60;READ_WRITE&#x60; mode. Valid values: * &#x60;READ_ONLY&#x60; * &#x60;READ_WRITE&#x60;
   * @return mode
   */
  @javax.annotation.Nullable
  public String getMode() {
    return mode;
  }

  public void setMode(String mode) {
    this.mode = mode;
  }


  public LocalDisk source(String source) {
    this.source = source;
    return this;
  }

  /**
   * Specifies a valid partial or full URL to an existing Persistent Disk resource.
   * @return source
   */
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public LocalDisk type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Specifies the type of the disk, either &#x60;SCRATCH&#x60; or &#x60;PERSISTENT&#x60;. If not specified, the default is &#x60;PERSISTENT&#x60;. Valid values: * &#x60;PERSISTENT&#x60; * &#x60;SCRATCH&#x60;
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LocalDisk localDisk = (LocalDisk) o;
    return Objects.equals(this.autoDelete, localDisk.autoDelete) &&
        Objects.equals(this.boot, localDisk.boot) &&
        Objects.equals(this.deviceName, localDisk.deviceName) &&
        Objects.equals(this.guestOsFeatures, localDisk.guestOsFeatures) &&
        Objects.equals(this.index, localDisk.index) &&
        Objects.equals(this.initializeParams, localDisk.initializeParams) &&
        Objects.equals(this._interface, localDisk._interface) &&
        Objects.equals(this.kind, localDisk.kind) &&
        Objects.equals(this.licenses, localDisk.licenses) &&
        Objects.equals(this.mode, localDisk.mode) &&
        Objects.equals(this.source, localDisk.source) &&
        Objects.equals(this.type, localDisk.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoDelete, boot, deviceName, guestOsFeatures, index, initializeParams, _interface, kind, licenses, mode, source, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LocalDisk {\n");
    sb.append("    autoDelete: ").append(toIndentedString(autoDelete)).append("\n");
    sb.append("    boot: ").append(toIndentedString(boot)).append("\n");
    sb.append("    deviceName: ").append(toIndentedString(deviceName)).append("\n");
    sb.append("    guestOsFeatures: ").append(toIndentedString(guestOsFeatures)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    initializeParams: ").append(toIndentedString(initializeParams)).append("\n");
    sb.append("    _interface: ").append(toIndentedString(_interface)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    licenses: ").append(toIndentedString(licenses)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoDelete");
    openapiFields.add("boot");
    openapiFields.add("deviceName");
    openapiFields.add("guestOsFeatures");
    openapiFields.add("index");
    openapiFields.add("initializeParams");
    openapiFields.add("interface");
    openapiFields.add("kind");
    openapiFields.add("licenses");
    openapiFields.add("mode");
    openapiFields.add("source");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LocalDisk
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LocalDisk.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LocalDisk is not found in the empty JSON string", LocalDisk.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LocalDisk.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LocalDisk` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("deviceName") != null && !jsonObj.get("deviceName").isJsonNull()) && !jsonObj.get("deviceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceName").toString()));
      }
      if (jsonObj.get("guestOsFeatures") != null && !jsonObj.get("guestOsFeatures").isJsonNull()) {
        JsonArray jsonArrayguestOsFeatures = jsonObj.getAsJsonArray("guestOsFeatures");
        if (jsonArrayguestOsFeatures != null) {
          // ensure the json data is an array
          if (!jsonObj.get("guestOsFeatures").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `guestOsFeatures` to be an array in the JSON string but got `%s`", jsonObj.get("guestOsFeatures").toString()));
          }

          // validate the optional field `guestOsFeatures` (array)
          for (int i = 0; i < jsonArrayguestOsFeatures.size(); i++) {
            RuntimeGuestOsFeature.validateJsonElement(jsonArrayguestOsFeatures.get(i));
          };
        }
      }
      // validate the optional field `initializeParams`
      if (jsonObj.get("initializeParams") != null && !jsonObj.get("initializeParams").isJsonNull()) {
        LocalDiskInitializeParams.validateJsonElement(jsonObj.get("initializeParams"));
      }
      if ((jsonObj.get("interface") != null && !jsonObj.get("interface").isJsonNull()) && !jsonObj.get("interface").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interface` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interface").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("licenses") != null && !jsonObj.get("licenses").isJsonNull() && !jsonObj.get("licenses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenses` to be an array in the JSON string but got `%s`", jsonObj.get("licenses").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LocalDisk.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LocalDisk' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LocalDisk> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LocalDisk.class));

       return (TypeAdapter<T>) new TypeAdapter<LocalDisk>() {
           @Override
           public void write(JsonWriter out, LocalDisk value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LocalDisk read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LocalDisk given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LocalDisk
   * @throws IOException if the JSON string is invalid with respect to LocalDisk
   */
  public static LocalDisk fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LocalDisk.class);
  }

  /**
   * Convert an instance of LocalDisk to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

