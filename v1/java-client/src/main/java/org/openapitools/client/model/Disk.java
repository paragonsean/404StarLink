/*
 * Notebooks API
 * Notebooks API is used to manage notebook resources in Google Cloud.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GuestOsFeature;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An instance-attached disk resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:00:12.602654-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Disk {
  public static final String SERIALIZED_NAME_AUTO_DELETE = "autoDelete";
  @SerializedName(SERIALIZED_NAME_AUTO_DELETE)
  private Boolean autoDelete;

  public static final String SERIALIZED_NAME_BOOT = "boot";
  @SerializedName(SERIALIZED_NAME_BOOT)
  private Boolean boot;

  public static final String SERIALIZED_NAME_DEVICE_NAME = "deviceName";
  @SerializedName(SERIALIZED_NAME_DEVICE_NAME)
  private String deviceName;

  public static final String SERIALIZED_NAME_DISK_SIZE_GB = "diskSizeGb";
  @SerializedName(SERIALIZED_NAME_DISK_SIZE_GB)
  private String diskSizeGb;

  public static final String SERIALIZED_NAME_GUEST_OS_FEATURES = "guestOsFeatures";
  @SerializedName(SERIALIZED_NAME_GUEST_OS_FEATURES)
  private List<GuestOsFeature> guestOsFeatures = new ArrayList<>();

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private String index;

  public static final String SERIALIZED_NAME_INTERFACE = "interface";
  @SerializedName(SERIALIZED_NAME_INTERFACE)
  private String _interface;

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_LICENSES = "licenses";
  @SerializedName(SERIALIZED_NAME_LICENSES)
  private List<String> licenses = new ArrayList<>();

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private String mode;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public Disk() {
  }

  public Disk autoDelete(Boolean autoDelete) {
    this.autoDelete = autoDelete;
    return this;
  }

  /**
   * Indicates whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
   * @return autoDelete
   */
  @javax.annotation.Nullable
  public Boolean getAutoDelete() {
    return autoDelete;
  }

  public void setAutoDelete(Boolean autoDelete) {
    this.autoDelete = autoDelete;
  }


  public Disk boot(Boolean boot) {
    this.boot = boot;
    return this;
  }

  /**
   * Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
   * @return boot
   */
  @javax.annotation.Nullable
  public Boolean getBoot() {
    return boot;
  }

  public void setBoot(Boolean boot) {
    this.boot = boot;
  }


  public Disk deviceName(String deviceName) {
    this.deviceName = deviceName;
    return this;
  }

  /**
   * Indicates a unique device name of your choice that is reflected into the &#x60;/dev/disk/by-id/google-*&#x60; tree of a Linux operating system running within the instance. This name can be used to reference the device for mounting, resizing, and so on, from within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine.This field is only applicable for persistent disks.
   * @return deviceName
   */
  @javax.annotation.Nullable
  public String getDeviceName() {
    return deviceName;
  }

  public void setDeviceName(String deviceName) {
    this.deviceName = deviceName;
  }


  public Disk diskSizeGb(String diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
    return this;
  }

  /**
   * Indicates the size of the disk in base-2 GB.
   * @return diskSizeGb
   */
  @javax.annotation.Nullable
  public String getDiskSizeGb() {
    return diskSizeGb;
  }

  public void setDiskSizeGb(String diskSizeGb) {
    this.diskSizeGb = diskSizeGb;
  }


  public Disk guestOsFeatures(List<GuestOsFeature> guestOsFeatures) {
    this.guestOsFeatures = guestOsFeatures;
    return this;
  }

  public Disk addGuestOsFeaturesItem(GuestOsFeature guestOsFeaturesItem) {
    if (this.guestOsFeatures == null) {
      this.guestOsFeatures = new ArrayList<>();
    }
    this.guestOsFeatures.add(guestOsFeaturesItem);
    return this;
  }

  /**
   * Indicates a list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
   * @return guestOsFeatures
   */
  @javax.annotation.Nullable
  public List<GuestOsFeature> getGuestOsFeatures() {
    return guestOsFeatures;
  }

  public void setGuestOsFeatures(List<GuestOsFeature> guestOsFeatures) {
    this.guestOsFeatures = guestOsFeatures;
  }


  public Disk index(String index) {
    this.index = index;
    return this;
  }

  /**
   * A zero-based index to this disk, where 0 is reserved for the boot disk. If you have many disks attached to an instance, each disk would have a unique index number.
   * @return index
   */
  @javax.annotation.Nullable
  public String getIndex() {
    return index;
  }

  public void setIndex(String index) {
    this.index = index;
  }


  public Disk _interface(String _interface) {
    this._interface = _interface;
    return this;
  }

  /**
   * Indicates the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance. Valid values: * &#x60;NVME&#x60; * &#x60;SCSI&#x60;
   * @return _interface
   */
  @javax.annotation.Nullable
  public String getInterface() {
    return _interface;
  }

  public void setInterface(String _interface) {
    this._interface = _interface;
  }


  public Disk kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Type of the resource. Always compute#attachedDisk for attached disks.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public Disk licenses(List<String> licenses) {
    this.licenses = licenses;
    return this;
  }

  public Disk addLicensesItem(String licensesItem) {
    if (this.licenses == null) {
      this.licenses = new ArrayList<>();
    }
    this.licenses.add(licensesItem);
    return this;
  }

  /**
   * A list of publicly visible licenses. Reserved for Google&#39;s use. A License represents billing and aggregate usage data for public and marketplace images.
   * @return licenses
   */
  @javax.annotation.Nullable
  public List<String> getLicenses() {
    return licenses;
  }

  public void setLicenses(List<String> licenses) {
    this.licenses = licenses;
  }


  public Disk mode(String mode) {
    this.mode = mode;
    return this;
  }

  /**
   * The mode in which to attach this disk, either &#x60;READ_WRITE&#x60; or &#x60;READ_ONLY&#x60;. If not specified, the default is to attach the disk in &#x60;READ_WRITE&#x60; mode. Valid values: * &#x60;READ_ONLY&#x60; * &#x60;READ_WRITE&#x60;
   * @return mode
   */
  @javax.annotation.Nullable
  public String getMode() {
    return mode;
  }

  public void setMode(String mode) {
    this.mode = mode;
  }


  public Disk source(String source) {
    this.source = source;
    return this;
  }

  /**
   * Indicates a valid partial or full URL to an existing Persistent Disk resource.
   * @return source
   */
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public Disk type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Indicates the type of the disk, either &#x60;SCRATCH&#x60; or &#x60;PERSISTENT&#x60;. Valid values: * &#x60;PERSISTENT&#x60; * &#x60;SCRATCH&#x60;
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Disk disk = (Disk) o;
    return Objects.equals(this.autoDelete, disk.autoDelete) &&
        Objects.equals(this.boot, disk.boot) &&
        Objects.equals(this.deviceName, disk.deviceName) &&
        Objects.equals(this.diskSizeGb, disk.diskSizeGb) &&
        Objects.equals(this.guestOsFeatures, disk.guestOsFeatures) &&
        Objects.equals(this.index, disk.index) &&
        Objects.equals(this._interface, disk._interface) &&
        Objects.equals(this.kind, disk.kind) &&
        Objects.equals(this.licenses, disk.licenses) &&
        Objects.equals(this.mode, disk.mode) &&
        Objects.equals(this.source, disk.source) &&
        Objects.equals(this.type, disk.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoDelete, boot, deviceName, diskSizeGb, guestOsFeatures, index, _interface, kind, licenses, mode, source, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Disk {\n");
    sb.append("    autoDelete: ").append(toIndentedString(autoDelete)).append("\n");
    sb.append("    boot: ").append(toIndentedString(boot)).append("\n");
    sb.append("    deviceName: ").append(toIndentedString(deviceName)).append("\n");
    sb.append("    diskSizeGb: ").append(toIndentedString(diskSizeGb)).append("\n");
    sb.append("    guestOsFeatures: ").append(toIndentedString(guestOsFeatures)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    _interface: ").append(toIndentedString(_interface)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    licenses: ").append(toIndentedString(licenses)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoDelete");
    openapiFields.add("boot");
    openapiFields.add("deviceName");
    openapiFields.add("diskSizeGb");
    openapiFields.add("guestOsFeatures");
    openapiFields.add("index");
    openapiFields.add("interface");
    openapiFields.add("kind");
    openapiFields.add("licenses");
    openapiFields.add("mode");
    openapiFields.add("source");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Disk
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Disk.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Disk is not found in the empty JSON string", Disk.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Disk.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Disk` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("deviceName") != null && !jsonObj.get("deviceName").isJsonNull()) && !jsonObj.get("deviceName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceName").toString()));
      }
      if ((jsonObj.get("diskSizeGb") != null && !jsonObj.get("diskSizeGb").isJsonNull()) && !jsonObj.get("diskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskSizeGb").toString()));
      }
      if (jsonObj.get("guestOsFeatures") != null && !jsonObj.get("guestOsFeatures").isJsonNull()) {
        JsonArray jsonArrayguestOsFeatures = jsonObj.getAsJsonArray("guestOsFeatures");
        if (jsonArrayguestOsFeatures != null) {
          // ensure the json data is an array
          if (!jsonObj.get("guestOsFeatures").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `guestOsFeatures` to be an array in the JSON string but got `%s`", jsonObj.get("guestOsFeatures").toString()));
          }

          // validate the optional field `guestOsFeatures` (array)
          for (int i = 0; i < jsonArrayguestOsFeatures.size(); i++) {
            GuestOsFeature.validateJsonElement(jsonArrayguestOsFeatures.get(i));
          };
        }
      }
      if ((jsonObj.get("index") != null && !jsonObj.get("index").isJsonNull()) && !jsonObj.get("index").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `index` to be a primitive type in the JSON string but got `%s`", jsonObj.get("index").toString()));
      }
      if ((jsonObj.get("interface") != null && !jsonObj.get("interface").isJsonNull()) && !jsonObj.get("interface").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interface` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interface").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("licenses") != null && !jsonObj.get("licenses").isJsonNull() && !jsonObj.get("licenses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenses` to be an array in the JSON string but got `%s`", jsonObj.get("licenses").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Disk.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Disk' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Disk> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Disk.class));

       return (TypeAdapter<T>) new TypeAdapter<Disk>() {
           @Override
           public void write(JsonWriter out, Disk value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Disk read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Disk given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Disk
   * @throws IOException if the JSON string is invalid with respect to Disk
   */
  public static Disk fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Disk.class);
  }

  /**
   * Convert an instance of Disk to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

