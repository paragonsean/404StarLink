/*
 * Configuration API
 * The Configuration API enables you to create a platform where you can onboard your users as account holders and create balance accounts, cards, and business accounts.  ## Authentication Your Adyen contact will provide your API credential and an API key. To connect to the API, add an `X-API-Key` header with the API key as the value, for example:   ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ```  Alternatively, you can use the username and password to connect to the API using basic authentication. For example:  ``` curl -H \"Content-Type: application/json\" \\ -U \"ws@BalancePlatform.YOUR_BALANCE_PLATFORM\":\"YOUR_WS_PASSWORD\" \\ ... ``` ## Versioning The Configuration API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://balanceplatform-api-test.adyen.com/bcl/v2/accountHolders ``` ## Going live When going live, your Adyen contact will provide your API credential for the live environment. You can then use the API key or the username and password to send requests to `https://balanceplatform-api-live.adyen.com/bcl/v2`.
 *
 * The version of the OpenAPI document: 2
 * Contact: developer-experience@adyen.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ActiveNetworkTokensRestriction;
import org.openapitools.client.model.BrandVariantsRestriction;
import org.openapitools.client.model.CountriesRestriction;
import org.openapitools.client.model.DayOfWeekRestriction;
import org.openapitools.client.model.DifferentCurrenciesRestriction;
import org.openapitools.client.model.EntryModesRestriction;
import org.openapitools.client.model.InternationalTransactionRestriction;
import org.openapitools.client.model.MatchingTransactionsRestriction;
import org.openapitools.client.model.MccsRestriction;
import org.openapitools.client.model.MerchantNamesRestriction;
import org.openapitools.client.model.MerchantsRestriction;
import org.openapitools.client.model.ProcessingTypesRestriction;
import org.openapitools.client.model.TimeOfDayRestriction;
import org.openapitools.client.model.TotalAmountRestriction;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * TransactionRuleRestrictions
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:13:45.438014-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TransactionRuleRestrictions {
  public static final String SERIALIZED_NAME_ACTIVE_NETWORK_TOKENS = "activeNetworkTokens";
  @SerializedName(SERIALIZED_NAME_ACTIVE_NETWORK_TOKENS)
  private ActiveNetworkTokensRestriction activeNetworkTokens;

  public static final String SERIALIZED_NAME_BRAND_VARIANTS = "brandVariants";
  @SerializedName(SERIALIZED_NAME_BRAND_VARIANTS)
  private BrandVariantsRestriction brandVariants;

  public static final String SERIALIZED_NAME_COUNTRIES = "countries";
  @SerializedName(SERIALIZED_NAME_COUNTRIES)
  private CountriesRestriction countries;

  public static final String SERIALIZED_NAME_DAY_OF_WEEK = "dayOfWeek";
  @SerializedName(SERIALIZED_NAME_DAY_OF_WEEK)
  private DayOfWeekRestriction dayOfWeek;

  public static final String SERIALIZED_NAME_DIFFERENT_CURRENCIES = "differentCurrencies";
  @SerializedName(SERIALIZED_NAME_DIFFERENT_CURRENCIES)
  private DifferentCurrenciesRestriction differentCurrencies;

  public static final String SERIALIZED_NAME_ENTRY_MODES = "entryModes";
  @SerializedName(SERIALIZED_NAME_ENTRY_MODES)
  private EntryModesRestriction entryModes;

  public static final String SERIALIZED_NAME_INTERNATIONAL_TRANSACTION = "internationalTransaction";
  @SerializedName(SERIALIZED_NAME_INTERNATIONAL_TRANSACTION)
  private InternationalTransactionRestriction internationalTransaction;

  public static final String SERIALIZED_NAME_MATCHING_TRANSACTIONS = "matchingTransactions";
  @SerializedName(SERIALIZED_NAME_MATCHING_TRANSACTIONS)
  private MatchingTransactionsRestriction matchingTransactions;

  public static final String SERIALIZED_NAME_MCCS = "mccs";
  @SerializedName(SERIALIZED_NAME_MCCS)
  private MccsRestriction mccs;

  public static final String SERIALIZED_NAME_MERCHANT_NAMES = "merchantNames";
  @SerializedName(SERIALIZED_NAME_MERCHANT_NAMES)
  private MerchantNamesRestriction merchantNames;

  public static final String SERIALIZED_NAME_MERCHANTS = "merchants";
  @SerializedName(SERIALIZED_NAME_MERCHANTS)
  private MerchantsRestriction merchants;

  public static final String SERIALIZED_NAME_PROCESSING_TYPES = "processingTypes";
  @SerializedName(SERIALIZED_NAME_PROCESSING_TYPES)
  private ProcessingTypesRestriction processingTypes;

  public static final String SERIALIZED_NAME_TIME_OF_DAY = "timeOfDay";
  @SerializedName(SERIALIZED_NAME_TIME_OF_DAY)
  private TimeOfDayRestriction timeOfDay;

  public static final String SERIALIZED_NAME_TOTAL_AMOUNT = "totalAmount";
  @SerializedName(SERIALIZED_NAME_TOTAL_AMOUNT)
  private TotalAmountRestriction totalAmount;

  public TransactionRuleRestrictions() {
  }

  public TransactionRuleRestrictions activeNetworkTokens(ActiveNetworkTokensRestriction activeNetworkTokens) {
    this.activeNetworkTokens = activeNetworkTokens;
    return this;
  }

  /**
   * The total number of tokens that a card can have across different kinds of digital wallets on the user&#39;s phones, watches, or other wearables.  Supported operations: **equals**, **notEquals**, **greaterThanOrEqualTo**, **greaterThan**, **lessThanOrEqualTo**, **lessThan**.
   * @return activeNetworkTokens
   */
  @javax.annotation.Nullable
  public ActiveNetworkTokensRestriction getActiveNetworkTokens() {
    return activeNetworkTokens;
  }

  public void setActiveNetworkTokens(ActiveNetworkTokensRestriction activeNetworkTokens) {
    this.activeNetworkTokens = activeNetworkTokens;
  }


  public TransactionRuleRestrictions brandVariants(BrandVariantsRestriction brandVariants) {
    this.brandVariants = brandVariants;
    return this;
  }

  /**
   * List of card brand variants and the operation.  Supported operations: **anyMatch**, **noneMatch**.
   * @return brandVariants
   */
  @javax.annotation.Nullable
  public BrandVariantsRestriction getBrandVariants() {
    return brandVariants;
  }

  public void setBrandVariants(BrandVariantsRestriction brandVariants) {
    this.brandVariants = brandVariants;
  }


  public TransactionRuleRestrictions countries(CountriesRestriction countries) {
    this.countries = countries;
    return this;
  }

  /**
   * List of countries and the operation.  Supported operations: **anyMatch**, **noneMatch**.
   * @return countries
   */
  @javax.annotation.Nullable
  public CountriesRestriction getCountries() {
    return countries;
  }

  public void setCountries(CountriesRestriction countries) {
    this.countries = countries;
  }


  public TransactionRuleRestrictions dayOfWeek(DayOfWeekRestriction dayOfWeek) {
    this.dayOfWeek = dayOfWeek;
    return this;
  }

  /**
   * List of week days and the operation. Supported operations: **anyMatch**, **noneMatch**.
   * @return dayOfWeek
   */
  @javax.annotation.Nullable
  public DayOfWeekRestriction getDayOfWeek() {
    return dayOfWeek;
  }

  public void setDayOfWeek(DayOfWeekRestriction dayOfWeek) {
    this.dayOfWeek = dayOfWeek;
  }


  public TransactionRuleRestrictions differentCurrencies(DifferentCurrenciesRestriction differentCurrencies) {
    this.differentCurrencies = differentCurrencies;
    return this;
  }

  /**
   * Compares the currency of the payment against the currency of the payment instrument, and specifies the operation.  Supported operations: **equals**, **notEquals**.
   * @return differentCurrencies
   */
  @javax.annotation.Nullable
  public DifferentCurrenciesRestriction getDifferentCurrencies() {
    return differentCurrencies;
  }

  public void setDifferentCurrencies(DifferentCurrenciesRestriction differentCurrencies) {
    this.differentCurrencies = differentCurrencies;
  }


  public TransactionRuleRestrictions entryModes(EntryModesRestriction entryModes) {
    this.entryModes = entryModes;
    return this;
  }

  /**
   * List of point-of-sale entry modes and the operation..  Supported operations: **anyMatch**, **noneMatch**.
   * @return entryModes
   */
  @javax.annotation.Nullable
  public EntryModesRestriction getEntryModes() {
    return entryModes;
  }

  public void setEntryModes(EntryModesRestriction entryModes) {
    this.entryModes = entryModes;
  }


  public TransactionRuleRestrictions internationalTransaction(InternationalTransactionRestriction internationalTransaction) {
    this.internationalTransaction = internationalTransaction;
    return this;
  }

  /**
   * Indicates whether transaction is an international transaction and specifies the operation.  Supported operations: **equals**, **notEquals**.
   * @return internationalTransaction
   */
  @javax.annotation.Nullable
  public InternationalTransactionRestriction getInternationalTransaction() {
    return internationalTransaction;
  }

  public void setInternationalTransaction(InternationalTransactionRestriction internationalTransaction) {
    this.internationalTransaction = internationalTransaction;
  }


  public TransactionRuleRestrictions matchingTransactions(MatchingTransactionsRestriction matchingTransactions) {
    this.matchingTransactions = matchingTransactions;
    return this;
  }

  /**
   * The number of transactions and the operation.  Supported operations: **equals**, **notEquals**, **greaterThanOrEqualTo**, **greaterThan**, **lessThanOrEqualTo**, **lessThan**.
   * @return matchingTransactions
   */
  @javax.annotation.Nullable
  public MatchingTransactionsRestriction getMatchingTransactions() {
    return matchingTransactions;
  }

  public void setMatchingTransactions(MatchingTransactionsRestriction matchingTransactions) {
    this.matchingTransactions = matchingTransactions;
  }


  public TransactionRuleRestrictions mccs(MccsRestriction mccs) {
    this.mccs = mccs;
    return this;
  }

  /**
   * List of merchant category codes (MCCs) and the operation.  Supported operations: **anyMatch**, **noneMatch**.
   * @return mccs
   */
  @javax.annotation.Nullable
  public MccsRestriction getMccs() {
    return mccs;
  }

  public void setMccs(MccsRestriction mccs) {
    this.mccs = mccs;
  }


  public TransactionRuleRestrictions merchantNames(MerchantNamesRestriction merchantNames) {
    this.merchantNames = merchantNames;
    return this;
  }

  /**
   * List of names that will be compared to the merchant name according to the matching type.  Supported operations: **anyMatch**, **noneMatch**.
   * @return merchantNames
   */
  @javax.annotation.Nullable
  public MerchantNamesRestriction getMerchantNames() {
    return merchantNames;
  }

  public void setMerchantNames(MerchantNamesRestriction merchantNames) {
    this.merchantNames = merchantNames;
  }


  public TransactionRuleRestrictions merchants(MerchantsRestriction merchants) {
    this.merchants = merchants;
    return this;
  }

  /**
   * List of merchant ID and acquirer ID pairs, and the operation.  Supported operations: **anyMatch**, **noneMatch**.
   * @return merchants
   */
  @javax.annotation.Nullable
  public MerchantsRestriction getMerchants() {
    return merchants;
  }

  public void setMerchants(MerchantsRestriction merchants) {
    this.merchants = merchants;
  }


  public TransactionRuleRestrictions processingTypes(ProcessingTypesRestriction processingTypes) {
    this.processingTypes = processingTypes;
    return this;
  }

  /**
   * List of processing types and the operation.  Supported operations: **anyMatch**, **noneMatch**.
   * @return processingTypes
   */
  @javax.annotation.Nullable
  public ProcessingTypesRestriction getProcessingTypes() {
    return processingTypes;
  }

  public void setProcessingTypes(ProcessingTypesRestriction processingTypes) {
    this.processingTypes = processingTypes;
  }


  public TransactionRuleRestrictions timeOfDay(TimeOfDayRestriction timeOfDay) {
    this.timeOfDay = timeOfDay;
    return this;
  }

  /**
   * A start and end time in a time-only ISO-8601 extended offset format. Supported operations: **equals**, **notEquals**.
   * @return timeOfDay
   */
  @javax.annotation.Nullable
  public TimeOfDayRestriction getTimeOfDay() {
    return timeOfDay;
  }

  public void setTimeOfDay(TimeOfDayRestriction timeOfDay) {
    this.timeOfDay = timeOfDay;
  }


  public TransactionRuleRestrictions totalAmount(TotalAmountRestriction totalAmount) {
    this.totalAmount = totalAmount;
    return this;
  }

  /**
   * The total amount and the operation.  Supported operations: **equals**, **notEquals**, **greaterThanOrEqualTo**, **greaterThan**, **lessThanOrEqualTo**, **lessThan**.
   * @return totalAmount
   */
  @javax.annotation.Nullable
  public TotalAmountRestriction getTotalAmount() {
    return totalAmount;
  }

  public void setTotalAmount(TotalAmountRestriction totalAmount) {
    this.totalAmount = totalAmount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TransactionRuleRestrictions transactionRuleRestrictions = (TransactionRuleRestrictions) o;
    return Objects.equals(this.activeNetworkTokens, transactionRuleRestrictions.activeNetworkTokens) &&
        Objects.equals(this.brandVariants, transactionRuleRestrictions.brandVariants) &&
        Objects.equals(this.countries, transactionRuleRestrictions.countries) &&
        Objects.equals(this.dayOfWeek, transactionRuleRestrictions.dayOfWeek) &&
        Objects.equals(this.differentCurrencies, transactionRuleRestrictions.differentCurrencies) &&
        Objects.equals(this.entryModes, transactionRuleRestrictions.entryModes) &&
        Objects.equals(this.internationalTransaction, transactionRuleRestrictions.internationalTransaction) &&
        Objects.equals(this.matchingTransactions, transactionRuleRestrictions.matchingTransactions) &&
        Objects.equals(this.mccs, transactionRuleRestrictions.mccs) &&
        Objects.equals(this.merchantNames, transactionRuleRestrictions.merchantNames) &&
        Objects.equals(this.merchants, transactionRuleRestrictions.merchants) &&
        Objects.equals(this.processingTypes, transactionRuleRestrictions.processingTypes) &&
        Objects.equals(this.timeOfDay, transactionRuleRestrictions.timeOfDay) &&
        Objects.equals(this.totalAmount, transactionRuleRestrictions.totalAmount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeNetworkTokens, brandVariants, countries, dayOfWeek, differentCurrencies, entryModes, internationalTransaction, matchingTransactions, mccs, merchantNames, merchants, processingTypes, timeOfDay, totalAmount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TransactionRuleRestrictions {\n");
    sb.append("    activeNetworkTokens: ").append(toIndentedString(activeNetworkTokens)).append("\n");
    sb.append("    brandVariants: ").append(toIndentedString(brandVariants)).append("\n");
    sb.append("    countries: ").append(toIndentedString(countries)).append("\n");
    sb.append("    dayOfWeek: ").append(toIndentedString(dayOfWeek)).append("\n");
    sb.append("    differentCurrencies: ").append(toIndentedString(differentCurrencies)).append("\n");
    sb.append("    entryModes: ").append(toIndentedString(entryModes)).append("\n");
    sb.append("    internationalTransaction: ").append(toIndentedString(internationalTransaction)).append("\n");
    sb.append("    matchingTransactions: ").append(toIndentedString(matchingTransactions)).append("\n");
    sb.append("    mccs: ").append(toIndentedString(mccs)).append("\n");
    sb.append("    merchantNames: ").append(toIndentedString(merchantNames)).append("\n");
    sb.append("    merchants: ").append(toIndentedString(merchants)).append("\n");
    sb.append("    processingTypes: ").append(toIndentedString(processingTypes)).append("\n");
    sb.append("    timeOfDay: ").append(toIndentedString(timeOfDay)).append("\n");
    sb.append("    totalAmount: ").append(toIndentedString(totalAmount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activeNetworkTokens");
    openapiFields.add("brandVariants");
    openapiFields.add("countries");
    openapiFields.add("dayOfWeek");
    openapiFields.add("differentCurrencies");
    openapiFields.add("entryModes");
    openapiFields.add("internationalTransaction");
    openapiFields.add("matchingTransactions");
    openapiFields.add("mccs");
    openapiFields.add("merchantNames");
    openapiFields.add("merchants");
    openapiFields.add("processingTypes");
    openapiFields.add("timeOfDay");
    openapiFields.add("totalAmount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TransactionRuleRestrictions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TransactionRuleRestrictions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TransactionRuleRestrictions is not found in the empty JSON string", TransactionRuleRestrictions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TransactionRuleRestrictions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TransactionRuleRestrictions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `activeNetworkTokens`
      if (jsonObj.get("activeNetworkTokens") != null && !jsonObj.get("activeNetworkTokens").isJsonNull()) {
        ActiveNetworkTokensRestriction.validateJsonElement(jsonObj.get("activeNetworkTokens"));
      }
      // validate the optional field `brandVariants`
      if (jsonObj.get("brandVariants") != null && !jsonObj.get("brandVariants").isJsonNull()) {
        BrandVariantsRestriction.validateJsonElement(jsonObj.get("brandVariants"));
      }
      // validate the optional field `countries`
      if (jsonObj.get("countries") != null && !jsonObj.get("countries").isJsonNull()) {
        CountriesRestriction.validateJsonElement(jsonObj.get("countries"));
      }
      // validate the optional field `dayOfWeek`
      if (jsonObj.get("dayOfWeek") != null && !jsonObj.get("dayOfWeek").isJsonNull()) {
        DayOfWeekRestriction.validateJsonElement(jsonObj.get("dayOfWeek"));
      }
      // validate the optional field `differentCurrencies`
      if (jsonObj.get("differentCurrencies") != null && !jsonObj.get("differentCurrencies").isJsonNull()) {
        DifferentCurrenciesRestriction.validateJsonElement(jsonObj.get("differentCurrencies"));
      }
      // validate the optional field `entryModes`
      if (jsonObj.get("entryModes") != null && !jsonObj.get("entryModes").isJsonNull()) {
        EntryModesRestriction.validateJsonElement(jsonObj.get("entryModes"));
      }
      // validate the optional field `internationalTransaction`
      if (jsonObj.get("internationalTransaction") != null && !jsonObj.get("internationalTransaction").isJsonNull()) {
        InternationalTransactionRestriction.validateJsonElement(jsonObj.get("internationalTransaction"));
      }
      // validate the optional field `matchingTransactions`
      if (jsonObj.get("matchingTransactions") != null && !jsonObj.get("matchingTransactions").isJsonNull()) {
        MatchingTransactionsRestriction.validateJsonElement(jsonObj.get("matchingTransactions"));
      }
      // validate the optional field `mccs`
      if (jsonObj.get("mccs") != null && !jsonObj.get("mccs").isJsonNull()) {
        MccsRestriction.validateJsonElement(jsonObj.get("mccs"));
      }
      // validate the optional field `merchantNames`
      if (jsonObj.get("merchantNames") != null && !jsonObj.get("merchantNames").isJsonNull()) {
        MerchantNamesRestriction.validateJsonElement(jsonObj.get("merchantNames"));
      }
      // validate the optional field `merchants`
      if (jsonObj.get("merchants") != null && !jsonObj.get("merchants").isJsonNull()) {
        MerchantsRestriction.validateJsonElement(jsonObj.get("merchants"));
      }
      // validate the optional field `processingTypes`
      if (jsonObj.get("processingTypes") != null && !jsonObj.get("processingTypes").isJsonNull()) {
        ProcessingTypesRestriction.validateJsonElement(jsonObj.get("processingTypes"));
      }
      // validate the optional field `timeOfDay`
      if (jsonObj.get("timeOfDay") != null && !jsonObj.get("timeOfDay").isJsonNull()) {
        TimeOfDayRestriction.validateJsonElement(jsonObj.get("timeOfDay"));
      }
      // validate the optional field `totalAmount`
      if (jsonObj.get("totalAmount") != null && !jsonObj.get("totalAmount").isJsonNull()) {
        TotalAmountRestriction.validateJsonElement(jsonObj.get("totalAmount"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TransactionRuleRestrictions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TransactionRuleRestrictions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TransactionRuleRestrictions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TransactionRuleRestrictions.class));

       return (TypeAdapter<T>) new TypeAdapter<TransactionRuleRestrictions>() {
           @Override
           public void write(JsonWriter out, TransactionRuleRestrictions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TransactionRuleRestrictions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TransactionRuleRestrictions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TransactionRuleRestrictions
   * @throws IOException if the JSON string is invalid with respect to TransactionRuleRestrictions
   */
  public static TransactionRuleRestrictions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TransactionRuleRestrictions.class);
  }

  /**
   * Convert an instance of TransactionRuleRestrictions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

