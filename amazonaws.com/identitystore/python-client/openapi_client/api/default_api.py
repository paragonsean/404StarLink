# coding: utf-8

"""
    AWS SSO Identity Store

    <p>The Identity Store service used by AWS IAM Identity Center (successor to AWS Single Sign-On) provides a single place to retrieve all of your identities (users and groups). For more information, see the <a href=\"https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html\">IAM Identity Center User Guide</a>.</p> <pre><code> &lt;note&gt; &lt;p&gt;Although AWS Single Sign-On was renamed, the &lt;code&gt;sso&lt;/code&gt; and &lt;code&gt;identitystore&lt;/code&gt; API namespaces will continue to retain their original name for backward compatibility purposes. For more information, see &lt;a href=&quot;https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html#renamed&quot;&gt;IAM Identity Center rename&lt;/a&gt;.&lt;/p&gt; &lt;/note&gt; &lt;p&gt;This reference guide describes the identity store operations that you can call programatically and includes detailed information about data types and errors.&lt;/p&gt; </code></pre>

    The version of the OpenAPI document: 2020-06-15
    Contact: mike.ralphson@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import Any, Dict, Optional
from typing_extensions import Annotated
from openapi_client.models.create_group_membership_request import CreateGroupMembershipRequest
from openapi_client.models.create_group_membership_response import CreateGroupMembershipResponse
from openapi_client.models.create_group_request import CreateGroupRequest
from openapi_client.models.create_group_response import CreateGroupResponse
from openapi_client.models.create_user_request import CreateUserRequest
from openapi_client.models.create_user_response import CreateUserResponse
from openapi_client.models.delete_group_membership_request import DeleteGroupMembershipRequest
from openapi_client.models.delete_group_request import DeleteGroupRequest
from openapi_client.models.delete_user_request import DeleteUserRequest
from openapi_client.models.describe_group_membership_request import DescribeGroupMembershipRequest
from openapi_client.models.describe_group_membership_response import DescribeGroupMembershipResponse
from openapi_client.models.describe_group_request import DescribeGroupRequest
from openapi_client.models.describe_group_response import DescribeGroupResponse
from openapi_client.models.describe_user_request import DescribeUserRequest
from openapi_client.models.describe_user_response import DescribeUserResponse
from openapi_client.models.get_group_id_request import GetGroupIdRequest
from openapi_client.models.get_group_id_response import GetGroupIdResponse
from openapi_client.models.get_group_membership_id_request import GetGroupMembershipIdRequest
from openapi_client.models.get_group_membership_id_response import GetGroupMembershipIdResponse
from openapi_client.models.get_user_id_request import GetUserIdRequest
from openapi_client.models.get_user_id_response import GetUserIdResponse
from openapi_client.models.is_member_in_groups_request import IsMemberInGroupsRequest
from openapi_client.models.is_member_in_groups_response import IsMemberInGroupsResponse
from openapi_client.models.list_group_memberships_for_member_request import ListGroupMembershipsForMemberRequest
from openapi_client.models.list_group_memberships_for_member_response import ListGroupMembershipsForMemberResponse
from openapi_client.models.list_group_memberships_request import ListGroupMembershipsRequest
from openapi_client.models.list_group_memberships_response import ListGroupMembershipsResponse
from openapi_client.models.list_groups_request import ListGroupsRequest
from openapi_client.models.list_groups_response import ListGroupsResponse
from openapi_client.models.list_users_request import ListUsersRequest
from openapi_client.models.list_users_response import ListUsersResponse
from openapi_client.models.update_group_request import UpdateGroupRequest
from openapi_client.models.update_user_request import UpdateUserRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_group(
        self,
        x_amz_target: StrictStr,
        create_group_request: CreateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateGroupResponse:
        """create_group

        Creates a group within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_request: (required)
        :type create_group_request: CreateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_serialize(
            x_amz_target=x_amz_target,
            create_group_request=create_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_group_with_http_info(
        self,
        x_amz_target: StrictStr,
        create_group_request: CreateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateGroupResponse]:
        """create_group

        Creates a group within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_request: (required)
        :type create_group_request: CreateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_serialize(
            x_amz_target=x_amz_target,
            create_group_request=create_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_group_without_preload_content(
        self,
        x_amz_target: StrictStr,
        create_group_request: CreateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_group

        Creates a group within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_request: (required)
        :type create_group_request: CreateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_serialize(
            x_amz_target=x_amz_target,
            create_group_request=create_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_group_serialize(
        self,
        x_amz_target,
        create_group_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if create_group_request is not None:
            _body_params = create_group_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.CreateGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_group_membership(
        self,
        x_amz_target: StrictStr,
        create_group_membership_request: CreateGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateGroupMembershipResponse:
        """create_group_membership

        Creates a relationship between a member and a group. The following identifiers must be specified: <code>GroupId</code>, <code>IdentityStoreId</code>, and <code>MemberId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_membership_request: (required)
        :type create_group_membership_request: CreateGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_membership_serialize(
            x_amz_target=x_amz_target,
            create_group_membership_request=create_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_group_membership_with_http_info(
        self,
        x_amz_target: StrictStr,
        create_group_membership_request: CreateGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateGroupMembershipResponse]:
        """create_group_membership

        Creates a relationship between a member and a group. The following identifiers must be specified: <code>GroupId</code>, <code>IdentityStoreId</code>, and <code>MemberId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_membership_request: (required)
        :type create_group_membership_request: CreateGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_membership_serialize(
            x_amz_target=x_amz_target,
            create_group_membership_request=create_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_group_membership_without_preload_content(
        self,
        x_amz_target: StrictStr,
        create_group_membership_request: CreateGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_group_membership

        Creates a relationship between a member and a group. The following identifiers must be specified: <code>GroupId</code>, <code>IdentityStoreId</code>, and <code>MemberId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_group_membership_request: (required)
        :type create_group_membership_request: CreateGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_group_membership_serialize(
            x_amz_target=x_amz_target,
            create_group_membership_request=create_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_group_membership_serialize(
        self,
        x_amz_target,
        create_group_membership_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if create_group_membership_request is not None:
            _body_params = create_group_membership_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.CreateGroupMembership',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_user(
        self,
        x_amz_target: StrictStr,
        create_user_request: CreateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateUserResponse:
        """create_user

        Creates a user within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_user_request: (required)
        :type create_user_request: CreateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_serialize(
            x_amz_target=x_amz_target,
            create_user_request=create_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_user_with_http_info(
        self,
        x_amz_target: StrictStr,
        create_user_request: CreateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateUserResponse]:
        """create_user

        Creates a user within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_user_request: (required)
        :type create_user_request: CreateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_serialize(
            x_amz_target=x_amz_target,
            create_user_request=create_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_user_without_preload_content(
        self,
        x_amz_target: StrictStr,
        create_user_request: CreateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """create_user

        Creates a user within the specified identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param create_user_request: (required)
        :type create_user_request: CreateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_user_serialize(
            x_amz_target=x_amz_target,
            create_user_request=create_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CreateUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_user_serialize(
        self,
        x_amz_target,
        create_user_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if create_user_request is not None:
            _body_params = create_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.CreateUser',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_group(
        self,
        x_amz_target: StrictStr,
        delete_group_request: DeleteGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """delete_group

        Delete a group within an identity store given <code>GroupId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_request: (required)
        :type delete_group_request: DeleteGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_serialize(
            x_amz_target=x_amz_target,
            delete_group_request=delete_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_group_with_http_info(
        self,
        x_amz_target: StrictStr,
        delete_group_request: DeleteGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """delete_group

        Delete a group within an identity store given <code>GroupId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_request: (required)
        :type delete_group_request: DeleteGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_serialize(
            x_amz_target=x_amz_target,
            delete_group_request=delete_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_group_without_preload_content(
        self,
        x_amz_target: StrictStr,
        delete_group_request: DeleteGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_group

        Delete a group within an identity store given <code>GroupId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_request: (required)
        :type delete_group_request: DeleteGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_serialize(
            x_amz_target=x_amz_target,
            delete_group_request=delete_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_group_serialize(
        self,
        x_amz_target,
        delete_group_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if delete_group_request is not None:
            _body_params = delete_group_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DeleteGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_group_membership(
        self,
        x_amz_target: StrictStr,
        delete_group_membership_request: DeleteGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """delete_group_membership

        Delete a membership within a group given <code>MembershipId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_membership_request: (required)
        :type delete_group_membership_request: DeleteGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_membership_serialize(
            x_amz_target=x_amz_target,
            delete_group_membership_request=delete_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_group_membership_with_http_info(
        self,
        x_amz_target: StrictStr,
        delete_group_membership_request: DeleteGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """delete_group_membership

        Delete a membership within a group given <code>MembershipId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_membership_request: (required)
        :type delete_group_membership_request: DeleteGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_membership_serialize(
            x_amz_target=x_amz_target,
            delete_group_membership_request=delete_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_group_membership_without_preload_content(
        self,
        x_amz_target: StrictStr,
        delete_group_membership_request: DeleteGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_group_membership

        Delete a membership within a group given <code>MembershipId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_group_membership_request: (required)
        :type delete_group_membership_request: DeleteGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_group_membership_serialize(
            x_amz_target=x_amz_target,
            delete_group_membership_request=delete_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_group_membership_serialize(
        self,
        x_amz_target,
        delete_group_membership_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if delete_group_membership_request is not None:
            _body_params = delete_group_membership_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DeleteGroupMembership',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_user(
        self,
        x_amz_target: StrictStr,
        delete_user_request: DeleteUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """delete_user

        Deletes a user within an identity store given <code>UserId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_user_request: (required)
        :type delete_user_request: DeleteUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_serialize(
            x_amz_target=x_amz_target,
            delete_user_request=delete_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_user_with_http_info(
        self,
        x_amz_target: StrictStr,
        delete_user_request: DeleteUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """delete_user

        Deletes a user within an identity store given <code>UserId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_user_request: (required)
        :type delete_user_request: DeleteUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_serialize(
            x_amz_target=x_amz_target,
            delete_user_request=delete_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_user_without_preload_content(
        self,
        x_amz_target: StrictStr,
        delete_user_request: DeleteUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_user

        Deletes a user within an identity store given <code>UserId</code>.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param delete_user_request: (required)
        :type delete_user_request: DeleteUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_user_serialize(
            x_amz_target=x_amz_target,
            delete_user_request=delete_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_user_serialize(
        self,
        x_amz_target,
        delete_user_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if delete_user_request is not None:
            _body_params = delete_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DeleteUser',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def describe_group(
        self,
        x_amz_target: StrictStr,
        describe_group_request: DescribeGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DescribeGroupResponse:
        """describe_group

        Retrieves the group metadata and attributes from <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_request: (required)
        :type describe_group_request: DescribeGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_serialize(
            x_amz_target=x_amz_target,
            describe_group_request=describe_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def describe_group_with_http_info(
        self,
        x_amz_target: StrictStr,
        describe_group_request: DescribeGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DescribeGroupResponse]:
        """describe_group

        Retrieves the group metadata and attributes from <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_request: (required)
        :type describe_group_request: DescribeGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_serialize(
            x_amz_target=x_amz_target,
            describe_group_request=describe_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def describe_group_without_preload_content(
        self,
        x_amz_target: StrictStr,
        describe_group_request: DescribeGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """describe_group

        Retrieves the group metadata and attributes from <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_request: (required)
        :type describe_group_request: DescribeGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_serialize(
            x_amz_target=x_amz_target,
            describe_group_request=describe_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _describe_group_serialize(
        self,
        x_amz_target,
        describe_group_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if describe_group_request is not None:
            _body_params = describe_group_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DescribeGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def describe_group_membership(
        self,
        x_amz_target: StrictStr,
        describe_group_membership_request: DescribeGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DescribeGroupMembershipResponse:
        """describe_group_membership

        Retrieves membership metadata and attributes from <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_membership_request: (required)
        :type describe_group_membership_request: DescribeGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_membership_serialize(
            x_amz_target=x_amz_target,
            describe_group_membership_request=describe_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def describe_group_membership_with_http_info(
        self,
        x_amz_target: StrictStr,
        describe_group_membership_request: DescribeGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DescribeGroupMembershipResponse]:
        """describe_group_membership

        Retrieves membership metadata and attributes from <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_membership_request: (required)
        :type describe_group_membership_request: DescribeGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_membership_serialize(
            x_amz_target=x_amz_target,
            describe_group_membership_request=describe_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def describe_group_membership_without_preload_content(
        self,
        x_amz_target: StrictStr,
        describe_group_membership_request: DescribeGroupMembershipRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """describe_group_membership

        Retrieves membership metadata and attributes from <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_group_membership_request: (required)
        :type describe_group_membership_request: DescribeGroupMembershipRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_group_membership_serialize(
            x_amz_target=x_amz_target,
            describe_group_membership_request=describe_group_membership_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeGroupMembershipResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _describe_group_membership_serialize(
        self,
        x_amz_target,
        describe_group_membership_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if describe_group_membership_request is not None:
            _body_params = describe_group_membership_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DescribeGroupMembership',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def describe_user(
        self,
        x_amz_target: StrictStr,
        describe_user_request: DescribeUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DescribeUserResponse:
        """describe_user

        Retrieves the user metadata and attributes from the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_user_request: (required)
        :type describe_user_request: DescribeUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_user_serialize(
            x_amz_target=x_amz_target,
            describe_user_request=describe_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def describe_user_with_http_info(
        self,
        x_amz_target: StrictStr,
        describe_user_request: DescribeUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DescribeUserResponse]:
        """describe_user

        Retrieves the user metadata and attributes from the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_user_request: (required)
        :type describe_user_request: DescribeUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_user_serialize(
            x_amz_target=x_amz_target,
            describe_user_request=describe_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def describe_user_without_preload_content(
        self,
        x_amz_target: StrictStr,
        describe_user_request: DescribeUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """describe_user

        Retrieves the user metadata and attributes from the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param describe_user_request: (required)
        :type describe_user_request: DescribeUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._describe_user_serialize(
            x_amz_target=x_amz_target,
            describe_user_request=describe_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DescribeUserResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _describe_user_serialize(
        self,
        x_amz_target,
        describe_user_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if describe_user_request is not None:
            _body_params = describe_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.DescribeUser',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_group_id(
        self,
        x_amz_target: StrictStr,
        get_group_id_request: GetGroupIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetGroupIdResponse:
        """get_group_id

        Retrieves <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_id_request: (required)
        :type get_group_id_request: GetGroupIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_id_serialize(
            x_amz_target=x_amz_target,
            get_group_id_request=get_group_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_group_id_with_http_info(
        self,
        x_amz_target: StrictStr,
        get_group_id_request: GetGroupIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetGroupIdResponse]:
        """get_group_id

        Retrieves <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_id_request: (required)
        :type get_group_id_request: GetGroupIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_id_serialize(
            x_amz_target=x_amz_target,
            get_group_id_request=get_group_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_group_id_without_preload_content(
        self,
        x_amz_target: StrictStr,
        get_group_id_request: GetGroupIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_group_id

        Retrieves <code>GroupId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_id_request: (required)
        :type get_group_id_request: GetGroupIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_id_serialize(
            x_amz_target=x_amz_target,
            get_group_id_request=get_group_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_group_id_serialize(
        self,
        x_amz_target,
        get_group_id_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if get_group_id_request is not None:
            _body_params = get_group_id_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.GetGroupId',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_group_membership_id(
        self,
        x_amz_target: StrictStr,
        get_group_membership_id_request: GetGroupMembershipIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetGroupMembershipIdResponse:
        """get_group_membership_id

        Retrieves the <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_membership_id_request: (required)
        :type get_group_membership_id_request: GetGroupMembershipIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_membership_id_serialize(
            x_amz_target=x_amz_target,
            get_group_membership_id_request=get_group_membership_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupMembershipIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_group_membership_id_with_http_info(
        self,
        x_amz_target: StrictStr,
        get_group_membership_id_request: GetGroupMembershipIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetGroupMembershipIdResponse]:
        """get_group_membership_id

        Retrieves the <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_membership_id_request: (required)
        :type get_group_membership_id_request: GetGroupMembershipIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_membership_id_serialize(
            x_amz_target=x_amz_target,
            get_group_membership_id_request=get_group_membership_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupMembershipIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_group_membership_id_without_preload_content(
        self,
        x_amz_target: StrictStr,
        get_group_membership_id_request: GetGroupMembershipIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_group_membership_id

        Retrieves the <code>MembershipId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_group_membership_id_request: (required)
        :type get_group_membership_id_request: GetGroupMembershipIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_membership_id_serialize(
            x_amz_target=x_amz_target,
            get_group_membership_id_request=get_group_membership_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetGroupMembershipIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_group_membership_id_serialize(
        self,
        x_amz_target,
        get_group_membership_id_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if get_group_membership_id_request is not None:
            _body_params = get_group_membership_id_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.GetGroupMembershipId',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_user_id(
        self,
        x_amz_target: StrictStr,
        get_user_id_request: GetUserIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetUserIdResponse:
        """get_user_id

        Retrieves the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_user_id_request: (required)
        :type get_user_id_request: GetUserIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_id_serialize(
            x_amz_target=x_amz_target,
            get_user_id_request=get_user_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetUserIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_user_id_with_http_info(
        self,
        x_amz_target: StrictStr,
        get_user_id_request: GetUserIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetUserIdResponse]:
        """get_user_id

        Retrieves the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_user_id_request: (required)
        :type get_user_id_request: GetUserIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_id_serialize(
            x_amz_target=x_amz_target,
            get_user_id_request=get_user_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetUserIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_user_id_without_preload_content(
        self,
        x_amz_target: StrictStr,
        get_user_id_request: GetUserIdRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_user_id

        Retrieves the <code>UserId</code> in an identity store.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param get_user_id_request: (required)
        :type get_user_id_request: GetUserIdRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_id_serialize(
            x_amz_target=x_amz_target,
            get_user_id_request=get_user_id_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetUserIdResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_id_serialize(
        self,
        x_amz_target,
        get_user_id_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if get_user_id_request is not None:
            _body_params = get_user_id_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.GetUserId',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def is_member_in_groups(
        self,
        x_amz_target: StrictStr,
        is_member_in_groups_request: IsMemberInGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IsMemberInGroupsResponse:
        """is_member_in_groups

        Checks the user's membership in all requested groups and returns if the member exists in all queried groups.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param is_member_in_groups_request: (required)
        :type is_member_in_groups_request: IsMemberInGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._is_member_in_groups_serialize(
            x_amz_target=x_amz_target,
            is_member_in_groups_request=is_member_in_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsMemberInGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def is_member_in_groups_with_http_info(
        self,
        x_amz_target: StrictStr,
        is_member_in_groups_request: IsMemberInGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IsMemberInGroupsResponse]:
        """is_member_in_groups

        Checks the user's membership in all requested groups and returns if the member exists in all queried groups.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param is_member_in_groups_request: (required)
        :type is_member_in_groups_request: IsMemberInGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._is_member_in_groups_serialize(
            x_amz_target=x_amz_target,
            is_member_in_groups_request=is_member_in_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsMemberInGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def is_member_in_groups_without_preload_content(
        self,
        x_amz_target: StrictStr,
        is_member_in_groups_request: IsMemberInGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """is_member_in_groups

        Checks the user's membership in all requested groups and returns if the member exists in all queried groups.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param is_member_in_groups_request: (required)
        :type is_member_in_groups_request: IsMemberInGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._is_member_in_groups_serialize(
            x_amz_target=x_amz_target,
            is_member_in_groups_request=is_member_in_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IsMemberInGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _is_member_in_groups_serialize(
        self,
        x_amz_target,
        is_member_in_groups_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if is_member_in_groups_request is not None:
            _body_params = is_member_in_groups_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.IsMemberInGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_group_memberships(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_request: ListGroupMembershipsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListGroupMembershipsResponse:
        """list_group_memberships

        For the specified group in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_request: (required)
        :type list_group_memberships_request: ListGroupMembershipsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_request=list_group_memberships_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_group_memberships_with_http_info(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_request: ListGroupMembershipsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListGroupMembershipsResponse]:
        """list_group_memberships

        For the specified group in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_request: (required)
        :type list_group_memberships_request: ListGroupMembershipsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_request=list_group_memberships_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_group_memberships_without_preload_content(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_request: ListGroupMembershipsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """list_group_memberships

        For the specified group in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_request: (required)
        :type list_group_memberships_request: ListGroupMembershipsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_request=list_group_memberships_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_group_memberships_serialize(
        self,
        x_amz_target,
        list_group_memberships_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        max_results,
        next_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('MaxResults', max_results))
            
        if next_token is not None:
            
            _query_params.append(('NextToken', next_token))
            
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if list_group_memberships_request is not None:
            _body_params = list_group_memberships_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.ListGroupMemberships',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_group_memberships_for_member(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListGroupMembershipsForMemberResponse:
        """list_group_memberships_for_member

        For the specified member in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_for_member_request: (required)
        :type list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_for_member_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_for_member_request=list_group_memberships_for_member_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsForMemberResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_group_memberships_for_member_with_http_info(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListGroupMembershipsForMemberResponse]:
        """list_group_memberships_for_member

        For the specified member in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_for_member_request: (required)
        :type list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_for_member_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_for_member_request=list_group_memberships_for_member_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsForMemberResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_group_memberships_for_member_without_preload_content(
        self,
        x_amz_target: StrictStr,
        list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """list_group_memberships_for_member

        For the specified member in the specified identity store, returns the list of all <code>GroupMembership</code> objects and returns results in paginated form.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_group_memberships_for_member_request: (required)
        :type list_group_memberships_for_member_request: ListGroupMembershipsForMemberRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_group_memberships_for_member_serialize(
            x_amz_target=x_amz_target,
            list_group_memberships_for_member_request=list_group_memberships_for_member_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupMembershipsForMemberResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_group_memberships_for_member_serialize(
        self,
        x_amz_target,
        list_group_memberships_for_member_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        max_results,
        next_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('MaxResults', max_results))
            
        if next_token is not None:
            
            _query_params.append(('NextToken', next_token))
            
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if list_group_memberships_for_member_request is not None:
            _body_params = list_group_memberships_for_member_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.ListGroupMembershipsForMember',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_groups(
        self,
        x_amz_target: StrictStr,
        list_groups_request: ListGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListGroupsResponse:
        """list_groups

        Lists all groups in the identity store. Returns a paginated list of complete <code>Group</code> objects. Filtering for a <code>Group</code> by the <code>DisplayName</code> attribute is deprecated. Instead, use the <code>GetGroupId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_groups_request: (required)
        :type list_groups_request: ListGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_groups_serialize(
            x_amz_target=x_amz_target,
            list_groups_request=list_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_groups_with_http_info(
        self,
        x_amz_target: StrictStr,
        list_groups_request: ListGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListGroupsResponse]:
        """list_groups

        Lists all groups in the identity store. Returns a paginated list of complete <code>Group</code> objects. Filtering for a <code>Group</code> by the <code>DisplayName</code> attribute is deprecated. Instead, use the <code>GetGroupId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_groups_request: (required)
        :type list_groups_request: ListGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_groups_serialize(
            x_amz_target=x_amz_target,
            list_groups_request=list_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_groups_without_preload_content(
        self,
        x_amz_target: StrictStr,
        list_groups_request: ListGroupsRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """list_groups

        Lists all groups in the identity store. Returns a paginated list of complete <code>Group</code> objects. Filtering for a <code>Group</code> by the <code>DisplayName</code> attribute is deprecated. Instead, use the <code>GetGroupId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_groups_request: (required)
        :type list_groups_request: ListGroupsRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_groups_serialize(
            x_amz_target=x_amz_target,
            list_groups_request=list_groups_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListGroupsResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_groups_serialize(
        self,
        x_amz_target,
        list_groups_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        max_results,
        next_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('MaxResults', max_results))
            
        if next_token is not None:
            
            _query_params.append(('NextToken', next_token))
            
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if list_groups_request is not None:
            _body_params = list_groups_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.ListGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_users(
        self,
        x_amz_target: StrictStr,
        list_users_request: ListUsersRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListUsersResponse:
        """list_users

        Lists all users in the identity store. Returns a paginated list of complete <code>User</code> objects. Filtering for a <code>User</code> by the <code>UserName</code> attribute is deprecated. Instead, use the <code>GetUserId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_users_request: (required)
        :type list_users_request: ListUsersRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_users_serialize(
            x_amz_target=x_amz_target,
            list_users_request=list_users_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListUsersResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_users_with_http_info(
        self,
        x_amz_target: StrictStr,
        list_users_request: ListUsersRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListUsersResponse]:
        """list_users

        Lists all users in the identity store. Returns a paginated list of complete <code>User</code> objects. Filtering for a <code>User</code> by the <code>UserName</code> attribute is deprecated. Instead, use the <code>GetUserId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_users_request: (required)
        :type list_users_request: ListUsersRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_users_serialize(
            x_amz_target=x_amz_target,
            list_users_request=list_users_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListUsersResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_users_without_preload_content(
        self,
        x_amz_target: StrictStr,
        list_users_request: ListUsersRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        max_results: Annotated[Optional[StrictStr], Field(description="Pagination limit")] = None,
        next_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """list_users

        Lists all users in the identity store. Returns a paginated list of complete <code>User</code> objects. Filtering for a <code>User</code> by the <code>UserName</code> attribute is deprecated. Instead, use the <code>GetUserId</code> API action.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param list_users_request: (required)
        :type list_users_request: ListUsersRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param max_results: Pagination limit
        :type max_results: str
        :param next_token: Pagination token
        :type next_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_users_serialize(
            x_amz_target=x_amz_target,
            list_users_request=list_users_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            max_results=max_results,
            next_token=next_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListUsersResponse",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_users_serialize(
        self,
        x_amz_target,
        list_users_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        max_results,
        next_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if max_results is not None:
            
            _query_params.append(('MaxResults', max_results))
            
        if next_token is not None:
            
            _query_params.append(('NextToken', next_token))
            
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if list_users_request is not None:
            _body_params = list_users_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.ListUsers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_group(
        self,
        x_amz_target: StrictStr,
        update_group_request: UpdateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """update_group

        For the specified group in the specified identity store, updates the group metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_group_request: (required)
        :type update_group_request: UpdateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_group_serialize(
            x_amz_target=x_amz_target,
            update_group_request=update_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_group_with_http_info(
        self,
        x_amz_target: StrictStr,
        update_group_request: UpdateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """update_group

        For the specified group in the specified identity store, updates the group metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_group_request: (required)
        :type update_group_request: UpdateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_group_serialize(
            x_amz_target=x_amz_target,
            update_group_request=update_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_group_without_preload_content(
        self,
        x_amz_target: StrictStr,
        update_group_request: UpdateGroupRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """update_group

        For the specified group in the specified identity store, updates the group metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_group_request: (required)
        :type update_group_request: UpdateGroupRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_group_serialize(
            x_amz_target=x_amz_target,
            update_group_request=update_group_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_group_serialize(
        self,
        x_amz_target,
        update_group_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if update_group_request is not None:
            _body_params = update_group_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.UpdateGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_user(
        self,
        x_amz_target: StrictStr,
        update_user_request: UpdateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """update_user

        For the specified user in the specified identity store, updates the user metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_user_request: (required)
        :type update_user_request: UpdateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_serialize(
            x_amz_target=x_amz_target,
            update_user_request=update_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_user_with_http_info(
        self,
        x_amz_target: StrictStr,
        update_user_request: UpdateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """update_user

        For the specified user in the specified identity store, updates the user metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_user_request: (required)
        :type update_user_request: UpdateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_serialize(
            x_amz_target=x_amz_target,
            update_user_request=update_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_user_without_preload_content(
        self,
        x_amz_target: StrictStr,
        update_user_request: UpdateUserRequest,
        x_amz_content_sha256: Optional[StrictStr] = None,
        x_amz_date: Optional[StrictStr] = None,
        x_amz_algorithm: Optional[StrictStr] = None,
        x_amz_credential: Optional[StrictStr] = None,
        x_amz_security_token: Optional[StrictStr] = None,
        x_amz_signature: Optional[StrictStr] = None,
        x_amz_signed_headers: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """update_user

        For the specified user in the specified identity store, updates the user metadata and attributes.

        :param x_amz_target: (required)
        :type x_amz_target: str
        :param update_user_request: (required)
        :type update_user_request: UpdateUserRequest
        :param x_amz_content_sha256:
        :type x_amz_content_sha256: str
        :param x_amz_date:
        :type x_amz_date: str
        :param x_amz_algorithm:
        :type x_amz_algorithm: str
        :param x_amz_credential:
        :type x_amz_credential: str
        :param x_amz_security_token:
        :type x_amz_security_token: str
        :param x_amz_signature:
        :type x_amz_signature: str
        :param x_amz_signed_headers:
        :type x_amz_signed_headers: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_serialize(
            x_amz_target=x_amz_target,
            update_user_request=update_user_request,
            x_amz_content_sha256=x_amz_content_sha256,
            x_amz_date=x_amz_date,
            x_amz_algorithm=x_amz_algorithm,
            x_amz_credential=x_amz_credential,
            x_amz_security_token=x_amz_security_token,
            x_amz_signature=x_amz_signature,
            x_amz_signed_headers=x_amz_signed_headers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '480': "object",
            '481': "object",
            '482': "object",
            '483': "object",
            '484': "object",
            '485': "object",
            '486': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_user_serialize(
        self,
        x_amz_target,
        update_user_request,
        x_amz_content_sha256,
        x_amz_date,
        x_amz_algorithm,
        x_amz_credential,
        x_amz_security_token,
        x_amz_signature,
        x_amz_signed_headers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_amz_content_sha256 is not None:
            _header_params['X-Amz-Content-Sha256'] = x_amz_content_sha256
        if x_amz_date is not None:
            _header_params['X-Amz-Date'] = x_amz_date
        if x_amz_algorithm is not None:
            _header_params['X-Amz-Algorithm'] = x_amz_algorithm
        if x_amz_credential is not None:
            _header_params['X-Amz-Credential'] = x_amz_credential
        if x_amz_security_token is not None:
            _header_params['X-Amz-Security-Token'] = x_amz_security_token
        if x_amz_signature is not None:
            _header_params['X-Amz-Signature'] = x_amz_signature
        if x_amz_signed_headers is not None:
            _header_params['X-Amz-SignedHeaders'] = x_amz_signed_headers
        if x_amz_target is not None:
            _header_params['X-Amz-Target'] = x_amz_target
        # process the form parameters
        # process the body parameter
        if update_user_request is not None:
            _body_params = update_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'hmac'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/#X-Amz-Target=AWSIdentityStore.UpdateUser',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


