/*
 * Amazon Honeycode
 *  Amazon Honeycode is a fully managed service that allows you to quickly build mobile and web apps for teamsâ€”without programming. Build Honeycode apps for managing almost anything, like projects, customers, operations, approvals, resources, and even your team. 
 *
 * The version of the OpenAPI document: 2020-03-01
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.VariableValue;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * GetScreenDataRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:19:28.423278-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GetScreenDataRequest {
  public static final String SERIALIZED_NAME_WORKBOOK_ID = "workbookId";
  @SerializedName(SERIALIZED_NAME_WORKBOOK_ID)
  private String workbookId;

  public static final String SERIALIZED_NAME_APP_ID = "appId";
  @SerializedName(SERIALIZED_NAME_APP_ID)
  private String appId;

  public static final String SERIALIZED_NAME_SCREEN_ID = "screenId";
  @SerializedName(SERIALIZED_NAME_SCREEN_ID)
  private String screenId;

  public static final String SERIALIZED_NAME_VARIABLES = "variables";
  @SerializedName(SERIALIZED_NAME_VARIABLES)
  private Map<String, VariableValue> variables = new HashMap<>();

  public static final String SERIALIZED_NAME_MAX_RESULTS = "maxResults";
  @SerializedName(SERIALIZED_NAME_MAX_RESULTS)
  private Integer maxResults;

  public static final String SERIALIZED_NAME_NEXT_TOKEN = "nextToken";
  @SerializedName(SERIALIZED_NAME_NEXT_TOKEN)
  private String nextToken;

  public GetScreenDataRequest() {
  }

  public GetScreenDataRequest workbookId(String workbookId) {
    this.workbookId = workbookId;
    return this;
  }

  /**
   * The ID of the workbook that contains the screen.
   * @return workbookId
   */
  @javax.annotation.Nonnull
  public String getWorkbookId() {
    return workbookId;
  }

  public void setWorkbookId(String workbookId) {
    this.workbookId = workbookId;
  }


  public GetScreenDataRequest appId(String appId) {
    this.appId = appId;
    return this;
  }

  /**
   * The ID of the app that contains the screen.
   * @return appId
   */
  @javax.annotation.Nonnull
  public String getAppId() {
    return appId;
  }

  public void setAppId(String appId) {
    this.appId = appId;
  }


  public GetScreenDataRequest screenId(String screenId) {
    this.screenId = screenId;
    return this;
  }

  /**
   * The ID of the screen.
   * @return screenId
   */
  @javax.annotation.Nonnull
  public String getScreenId() {
    return screenId;
  }

  public void setScreenId(String screenId) {
    this.screenId = screenId;
  }


  public GetScreenDataRequest variables(Map<String, VariableValue> variables) {
    this.variables = variables;
    return this;
  }

  public GetScreenDataRequest putVariablesItem(String key, VariableValue variablesItem) {
    if (this.variables == null) {
      this.variables = new HashMap<>();
    }
    this.variables.put(key, variablesItem);
    return this;
  }

  /**
   *  Variables are optional and are needed only if the screen requires them to render correctly. Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen. 
   * @return variables
   */
  @javax.annotation.Nullable
  public Map<String, VariableValue> getVariables() {
    return variables;
  }

  public void setVariables(Map<String, VariableValue> variables) {
    this.variables = variables;
  }


  public GetScreenDataRequest maxResults(Integer maxResults) {
    this.maxResults = maxResults;
    return this;
  }

  /**
   * &lt;p&gt; The number of results to be returned on a single page. Specify a number between 1 and 100. The maximum value is 100. &lt;/p&gt; &lt;p&gt; This parameter is optional. If you don&#39;t specify this parameter, the default page size is 100. &lt;/p&gt;
   * minimum: 1
   * maximum: 100
   * @return maxResults
   */
  @javax.annotation.Nullable
  public Integer getMaxResults() {
    return maxResults;
  }

  public void setMaxResults(Integer maxResults) {
    this.maxResults = maxResults;
  }


  public GetScreenDataRequest nextToken(String nextToken) {
    this.nextToken = nextToken;
    return this;
  }

  /**
   * &lt;p&gt; This parameter is optional. If a nextToken is not specified, the API returns the first page of data. &lt;/p&gt; &lt;p&gt; Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException. &lt;/p&gt;
   * @return nextToken
   */
  @javax.annotation.Nullable
  public String getNextToken() {
    return nextToken;
  }

  public void setNextToken(String nextToken) {
    this.nextToken = nextToken;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetScreenDataRequest getScreenDataRequest = (GetScreenDataRequest) o;
    return Objects.equals(this.workbookId, getScreenDataRequest.workbookId) &&
        Objects.equals(this.appId, getScreenDataRequest.appId) &&
        Objects.equals(this.screenId, getScreenDataRequest.screenId) &&
        Objects.equals(this.variables, getScreenDataRequest.variables) &&
        Objects.equals(this.maxResults, getScreenDataRequest.maxResults) &&
        Objects.equals(this.nextToken, getScreenDataRequest.nextToken);
  }

  @Override
  public int hashCode() {
    return Objects.hash(workbookId, appId, screenId, variables, maxResults, nextToken);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetScreenDataRequest {\n");
    sb.append("    workbookId: ").append(toIndentedString(workbookId)).append("\n");
    sb.append("    appId: ").append(toIndentedString(appId)).append("\n");
    sb.append("    screenId: ").append(toIndentedString(screenId)).append("\n");
    sb.append("    variables: ").append(toIndentedString(variables)).append("\n");
    sb.append("    maxResults: ").append(toIndentedString(maxResults)).append("\n");
    sb.append("    nextToken: ").append(toIndentedString(nextToken)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("workbookId");
    openapiFields.add("appId");
    openapiFields.add("screenId");
    openapiFields.add("variables");
    openapiFields.add("maxResults");
    openapiFields.add("nextToken");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("workbookId");
    openapiRequiredFields.add("appId");
    openapiRequiredFields.add("screenId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GetScreenDataRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetScreenDataRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetScreenDataRequest is not found in the empty JSON string", GetScreenDataRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetScreenDataRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetScreenDataRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : GetScreenDataRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("workbookId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workbookId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workbookId").toString()));
      }
      if (!jsonObj.get("appId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `appId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("appId").toString()));
      }
      if (!jsonObj.get("screenId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `screenId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("screenId").toString()));
      }
      if ((jsonObj.get("nextToken") != null && !jsonObj.get("nextToken").isJsonNull()) && !jsonObj.get("nextToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nextToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nextToken").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetScreenDataRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetScreenDataRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetScreenDataRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetScreenDataRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GetScreenDataRequest>() {
           @Override
           public void write(JsonWriter out, GetScreenDataRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetScreenDataRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GetScreenDataRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GetScreenDataRequest
   * @throws IOException if the JSON string is invalid with respect to GetScreenDataRequest
   */
  public static GetScreenDataRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetScreenDataRequest.class);
  }

  /**
   * Convert an instance of GetScreenDataRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

