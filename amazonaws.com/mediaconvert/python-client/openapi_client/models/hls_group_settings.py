# coding: utf-8

"""
    AWS Elemental MediaConvert

    AWS Elemental MediaConvert

    The version of the OpenAPI document: 2017-08-29
    Contact: mike.ralphson@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.cmaf_group_settings_destination_settings import CmafGroupSettingsDestinationSettings
from openapi_client.models.hls_group_settings_encryption import HlsGroupSettingsEncryption
from openapi_client.models.hls_group_settings_image_based_trick_play_settings import HlsGroupSettingsImageBasedTrickPlaySettings
from typing import Optional, Set
from typing_extensions import Self

class HlsGroupSettings(BaseModel):
    """
    Settings related to your HLS output package. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/outputs-file-ABR.html. When you work directly in your JSON job specification, include this object and any required children when you set Type, under OutputGroupSettings, to HLS_GROUP_SETTINGS.
    """ # noqa: E501
    ad_markers: Optional[Any] = Field(default=None, alias="AdMarkers")
    additional_manifests: Optional[Any] = Field(default=None, alias="AdditionalManifests")
    audio_only_header: Optional[Any] = Field(default=None, alias="AudioOnlyHeader")
    base_url: Optional[Any] = Field(default=None, alias="BaseUrl")
    caption_language_mappings: Optional[Any] = Field(default=None, alias="CaptionLanguageMappings")
    caption_language_setting: Optional[Any] = Field(default=None, alias="CaptionLanguageSetting")
    caption_segment_length_control: Optional[Any] = Field(default=None, alias="CaptionSegmentLengthControl")
    client_cache: Optional[Any] = Field(default=None, alias="ClientCache")
    codec_specification: Optional[Any] = Field(default=None, alias="CodecSpecification")
    destination: Optional[Any] = Field(default=None, alias="Destination")
    destination_settings: Optional[CmafGroupSettingsDestinationSettings] = Field(default=None, alias="DestinationSettings")
    directory_structure: Optional[Any] = Field(default=None, alias="DirectoryStructure")
    encryption: Optional[HlsGroupSettingsEncryption] = Field(default=None, alias="Encryption")
    image_based_trick_play: Optional[Any] = Field(default=None, alias="ImageBasedTrickPlay")
    image_based_trick_play_settings: Optional[HlsGroupSettingsImageBasedTrickPlaySettings] = Field(default=None, alias="ImageBasedTrickPlaySettings")
    manifest_compression: Optional[Any] = Field(default=None, alias="ManifestCompression")
    manifest_duration_format: Optional[Any] = Field(default=None, alias="ManifestDurationFormat")
    min_final_segment_length: Optional[Any] = Field(default=None, alias="MinFinalSegmentLength")
    min_segment_length: Optional[Any] = Field(default=None, alias="MinSegmentLength")
    output_selection: Optional[Any] = Field(default=None, alias="OutputSelection")
    program_date_time: Optional[Any] = Field(default=None, alias="ProgramDateTime")
    program_date_time_period: Optional[Any] = Field(default=None, alias="ProgramDateTimePeriod")
    segment_control: Optional[Any] = Field(default=None, alias="SegmentControl")
    segment_length: Optional[Any] = Field(default=None, alias="SegmentLength")
    segment_length_control: Optional[Any] = Field(default=None, alias="SegmentLengthControl")
    segments_per_subdirectory: Optional[Any] = Field(default=None, alias="SegmentsPerSubdirectory")
    stream_inf_resolution: Optional[Any] = Field(default=None, alias="StreamInfResolution")
    target_duration_compatibility_mode: Optional[Any] = Field(default=None, alias="TargetDurationCompatibilityMode")
    timed_metadata_id3_frame: Optional[Any] = Field(default=None, alias="TimedMetadataId3Frame")
    timed_metadata_id3_period: Optional[Any] = Field(default=None, alias="TimedMetadataId3Period")
    timestamp_delta_milliseconds: Optional[Any] = Field(default=None, alias="TimestampDeltaMilliseconds")
    __properties: ClassVar[List[str]] = ["AdMarkers", "AdditionalManifests", "AudioOnlyHeader", "BaseUrl", "CaptionLanguageMappings", "CaptionLanguageSetting", "CaptionSegmentLengthControl", "ClientCache", "CodecSpecification", "Destination", "DestinationSettings", "DirectoryStructure", "Encryption", "ImageBasedTrickPlay", "ImageBasedTrickPlaySettings", "ManifestCompression", "ManifestDurationFormat", "MinFinalSegmentLength", "MinSegmentLength", "OutputSelection", "ProgramDateTime", "ProgramDateTimePeriod", "SegmentControl", "SegmentLength", "SegmentLengthControl", "SegmentsPerSubdirectory", "StreamInfResolution", "TargetDurationCompatibilityMode", "TimedMetadataId3Frame", "TimedMetadataId3Period", "TimestampDeltaMilliseconds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HlsGroupSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of audio_only_header
        if self.audio_only_header:
            _dict['AudioOnlyHeader'] = self.audio_only_header.to_dict()
        # override the default output from pydantic by calling `to_dict()` of caption_language_setting
        if self.caption_language_setting:
            _dict['CaptionLanguageSetting'] = self.caption_language_setting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of caption_segment_length_control
        if self.caption_segment_length_control:
            _dict['CaptionSegmentLengthControl'] = self.caption_segment_length_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of client_cache
        if self.client_cache:
            _dict['ClientCache'] = self.client_cache.to_dict()
        # override the default output from pydantic by calling `to_dict()` of codec_specification
        if self.codec_specification:
            _dict['CodecSpecification'] = self.codec_specification.to_dict()
        # override the default output from pydantic by calling `to_dict()` of destination_settings
        if self.destination_settings:
            _dict['DestinationSettings'] = self.destination_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of directory_structure
        if self.directory_structure:
            _dict['DirectoryStructure'] = self.directory_structure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of encryption
        if self.encryption:
            _dict['Encryption'] = self.encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_based_trick_play
        if self.image_based_trick_play:
            _dict['ImageBasedTrickPlay'] = self.image_based_trick_play.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_based_trick_play_settings
        if self.image_based_trick_play_settings:
            _dict['ImageBasedTrickPlaySettings'] = self.image_based_trick_play_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manifest_compression
        if self.manifest_compression:
            _dict['ManifestCompression'] = self.manifest_compression.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manifest_duration_format
        if self.manifest_duration_format:
            _dict['ManifestDurationFormat'] = self.manifest_duration_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of output_selection
        if self.output_selection:
            _dict['OutputSelection'] = self.output_selection.to_dict()
        # override the default output from pydantic by calling `to_dict()` of program_date_time
        if self.program_date_time:
            _dict['ProgramDateTime'] = self.program_date_time.to_dict()
        # override the default output from pydantic by calling `to_dict()` of segment_control
        if self.segment_control:
            _dict['SegmentControl'] = self.segment_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of segment_length_control
        if self.segment_length_control:
            _dict['SegmentLengthControl'] = self.segment_length_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stream_inf_resolution
        if self.stream_inf_resolution:
            _dict['StreamInfResolution'] = self.stream_inf_resolution.to_dict()
        # override the default output from pydantic by calling `to_dict()` of target_duration_compatibility_mode
        if self.target_duration_compatibility_mode:
            _dict['TargetDurationCompatibilityMode'] = self.target_duration_compatibility_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of timed_metadata_id3_frame
        if self.timed_metadata_id3_frame:
            _dict['TimedMetadataId3Frame'] = self.timed_metadata_id3_frame.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HlsGroupSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "AdMarkers": obj.get("AdMarkers"),
            "AdditionalManifests": obj.get("AdditionalManifests"),
            "AudioOnlyHeader": HlsAudioOnlyHeader.from_dict(obj["AudioOnlyHeader"]) if obj.get("AudioOnlyHeader") is not None else None,
            "BaseUrl": obj.get("BaseUrl"),
            "CaptionLanguageMappings": obj.get("CaptionLanguageMappings"),
            "CaptionLanguageSetting": HlsCaptionLanguageSetting.from_dict(obj["CaptionLanguageSetting"]) if obj.get("CaptionLanguageSetting") is not None else None,
            "CaptionSegmentLengthControl": HlsCaptionSegmentLengthControl.from_dict(obj["CaptionSegmentLengthControl"]) if obj.get("CaptionSegmentLengthControl") is not None else None,
            "ClientCache": HlsClientCache.from_dict(obj["ClientCache"]) if obj.get("ClientCache") is not None else None,
            "CodecSpecification": HlsCodecSpecification.from_dict(obj["CodecSpecification"]) if obj.get("CodecSpecification") is not None else None,
            "Destination": obj.get("Destination"),
            "DestinationSettings": CmafGroupSettingsDestinationSettings.from_dict(obj["DestinationSettings"]) if obj.get("DestinationSettings") is not None else None,
            "DirectoryStructure": HlsDirectoryStructure.from_dict(obj["DirectoryStructure"]) if obj.get("DirectoryStructure") is not None else None,
            "Encryption": HlsGroupSettingsEncryption.from_dict(obj["Encryption"]) if obj.get("Encryption") is not None else None,
            "ImageBasedTrickPlay": HlsImageBasedTrickPlay.from_dict(obj["ImageBasedTrickPlay"]) if obj.get("ImageBasedTrickPlay") is not None else None,
            "ImageBasedTrickPlaySettings": HlsGroupSettingsImageBasedTrickPlaySettings.from_dict(obj["ImageBasedTrickPlaySettings"]) if obj.get("ImageBasedTrickPlaySettings") is not None else None,
            "ManifestCompression": HlsManifestCompression.from_dict(obj["ManifestCompression"]) if obj.get("ManifestCompression") is not None else None,
            "ManifestDurationFormat": HlsManifestDurationFormat.from_dict(obj["ManifestDurationFormat"]) if obj.get("ManifestDurationFormat") is not None else None,
            "MinFinalSegmentLength": obj.get("MinFinalSegmentLength"),
            "MinSegmentLength": obj.get("MinSegmentLength"),
            "OutputSelection": HlsOutputSelection.from_dict(obj["OutputSelection"]) if obj.get("OutputSelection") is not None else None,
            "ProgramDateTime": HlsProgramDateTime.from_dict(obj["ProgramDateTime"]) if obj.get("ProgramDateTime") is not None else None,
            "ProgramDateTimePeriod": obj.get("ProgramDateTimePeriod"),
            "SegmentControl": HlsSegmentControl.from_dict(obj["SegmentControl"]) if obj.get("SegmentControl") is not None else None,
            "SegmentLength": obj.get("SegmentLength"),
            "SegmentLengthControl": HlsSegmentLengthControl.from_dict(obj["SegmentLengthControl"]) if obj.get("SegmentLengthControl") is not None else None,
            "SegmentsPerSubdirectory": obj.get("SegmentsPerSubdirectory"),
            "StreamInfResolution": HlsStreamInfResolution.from_dict(obj["StreamInfResolution"]) if obj.get("StreamInfResolution") is not None else None,
            "TargetDurationCompatibilityMode": HlsTargetDurationCompatibilityMode.from_dict(obj["TargetDurationCompatibilityMode"]) if obj.get("TargetDurationCompatibilityMode") is not None else None,
            "TimedMetadataId3Frame": HlsTimedMetadataId3Frame.from_dict(obj["TimedMetadataId3Frame"]) if obj.get("TimedMetadataId3Frame") is not None else None,
            "TimedMetadataId3Period": obj.get("TimedMetadataId3Period"),
            "TimestampDeltaMilliseconds": obj.get("TimestampDeltaMilliseconds")
        })
        return _obj


