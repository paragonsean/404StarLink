# coding: utf-8

"""
    AWS Elemental MediaConvert

    AWS Elemental MediaConvert

    The version of the OpenAPI document: 2017-08-29
    Contact: mike.ralphson@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.eac3_attenuation_control import Eac3AttenuationControl
from openapi_client.models.eac3_bitstream_mode import Eac3BitstreamMode
from openapi_client.models.eac3_coding_mode import Eac3CodingMode
from openapi_client.models.eac3_dc_filter import Eac3DcFilter
from openapi_client.models.eac3_dynamic_range_compression_line import Eac3DynamicRangeCompressionLine
from openapi_client.models.eac3_dynamic_range_compression_rf import Eac3DynamicRangeCompressionRf
from openapi_client.models.eac3_lfe_control import Eac3LfeControl
from openapi_client.models.eac3_lfe_filter import Eac3LfeFilter
from openapi_client.models.eac3_metadata_control import Eac3MetadataControl
from openapi_client.models.eac3_passthrough_control import Eac3PassthroughControl
from openapi_client.models.eac3_phase_control import Eac3PhaseControl
from openapi_client.models.eac3_stereo_downmix import Eac3StereoDownmix
from openapi_client.models.eac3_surround_ex_mode import Eac3SurroundExMode
from openapi_client.models.eac3_surround_mode import Eac3SurroundMode
from openapi_client.models.float import float
from openapi_client.models.int import int
from typing import Optional, Set
from typing_extensions import Self

class AudioCodecSettingsEac3Settings(BaseModel):
    """
    AudioCodecSettingsEac3Settings
    """ # noqa: E501
    attenuation_control: Optional[Any] = Field(default=None, alias="AttenuationControl")
    bitrate: Optional[Any] = Field(default=None, alias="Bitrate")
    bitstream_mode: Optional[Any] = Field(default=None, alias="BitstreamMode")
    coding_mode: Optional[Any] = Field(default=None, alias="CodingMode")
    dc_filter: Optional[Any] = Field(default=None, alias="DcFilter")
    dialnorm: Optional[Any] = Field(default=None, alias="Dialnorm")
    dynamic_range_compression_line: Optional[Any] = Field(default=None, alias="DynamicRangeCompressionLine")
    dynamic_range_compression_rf: Optional[Any] = Field(default=None, alias="DynamicRangeCompressionRf")
    lfe_control: Optional[Any] = Field(default=None, alias="LfeControl")
    lfe_filter: Optional[Any] = Field(default=None, alias="LfeFilter")
    lo_ro_center_mix_level: Optional[Any] = Field(default=None, alias="LoRoCenterMixLevel")
    lo_ro_surround_mix_level: Optional[Any] = Field(default=None, alias="LoRoSurroundMixLevel")
    lt_rt_center_mix_level: Optional[Any] = Field(default=None, alias="LtRtCenterMixLevel")
    lt_rt_surround_mix_level: Optional[Any] = Field(default=None, alias="LtRtSurroundMixLevel")
    metadata_control: Optional[Any] = Field(default=None, alias="MetadataControl")
    passthrough_control: Optional[Any] = Field(default=None, alias="PassthroughControl")
    phase_control: Optional[Any] = Field(default=None, alias="PhaseControl")
    sample_rate: Optional[Any] = Field(default=None, alias="SampleRate")
    stereo_downmix: Optional[Any] = Field(default=None, alias="StereoDownmix")
    surround_ex_mode: Optional[Any] = Field(default=None, alias="SurroundExMode")
    surround_mode: Optional[Any] = Field(default=None, alias="SurroundMode")
    __properties: ClassVar[List[str]] = ["AttenuationControl", "Bitrate", "BitstreamMode", "CodingMode", "DcFilter", "Dialnorm", "DynamicRangeCompressionLine", "DynamicRangeCompressionRf", "LfeControl", "LfeFilter", "LoRoCenterMixLevel", "LoRoSurroundMixLevel", "LtRtCenterMixLevel", "LtRtSurroundMixLevel", "MetadataControl", "PassthroughControl", "PhaseControl", "SampleRate", "StereoDownmix", "SurroundExMode", "SurroundMode"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AudioCodecSettingsEac3Settings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of attenuation_control
        if self.attenuation_control:
            _dict['AttenuationControl'] = self.attenuation_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bitstream_mode
        if self.bitstream_mode:
            _dict['BitstreamMode'] = self.bitstream_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of coding_mode
        if self.coding_mode:
            _dict['CodingMode'] = self.coding_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dc_filter
        if self.dc_filter:
            _dict['DcFilter'] = self.dc_filter.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dynamic_range_compression_line
        if self.dynamic_range_compression_line:
            _dict['DynamicRangeCompressionLine'] = self.dynamic_range_compression_line.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dynamic_range_compression_rf
        if self.dynamic_range_compression_rf:
            _dict['DynamicRangeCompressionRf'] = self.dynamic_range_compression_rf.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lfe_control
        if self.lfe_control:
            _dict['LfeControl'] = self.lfe_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of lfe_filter
        if self.lfe_filter:
            _dict['LfeFilter'] = self.lfe_filter.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metadata_control
        if self.metadata_control:
            _dict['MetadataControl'] = self.metadata_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of passthrough_control
        if self.passthrough_control:
            _dict['PassthroughControl'] = self.passthrough_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of phase_control
        if self.phase_control:
            _dict['PhaseControl'] = self.phase_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stereo_downmix
        if self.stereo_downmix:
            _dict['StereoDownmix'] = self.stereo_downmix.to_dict()
        # override the default output from pydantic by calling `to_dict()` of surround_ex_mode
        if self.surround_ex_mode:
            _dict['SurroundExMode'] = self.surround_ex_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of surround_mode
        if self.surround_mode:
            _dict['SurroundMode'] = self.surround_mode.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AudioCodecSettingsEac3Settings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "AttenuationControl": Eac3AttenuationControl.from_dict(obj["AttenuationControl"]) if obj.get("AttenuationControl") is not None else None,
            "Bitrate": obj.get("Bitrate"),
            "BitstreamMode": Eac3BitstreamMode.from_dict(obj["BitstreamMode"]) if obj.get("BitstreamMode") is not None else None,
            "CodingMode": Eac3CodingMode.from_dict(obj["CodingMode"]) if obj.get("CodingMode") is not None else None,
            "DcFilter": Eac3DcFilter.from_dict(obj["DcFilter"]) if obj.get("DcFilter") is not None else None,
            "Dialnorm": obj.get("Dialnorm"),
            "DynamicRangeCompressionLine": Eac3DynamicRangeCompressionLine.from_dict(obj["DynamicRangeCompressionLine"]) if obj.get("DynamicRangeCompressionLine") is not None else None,
            "DynamicRangeCompressionRf": Eac3DynamicRangeCompressionRf.from_dict(obj["DynamicRangeCompressionRf"]) if obj.get("DynamicRangeCompressionRf") is not None else None,
            "LfeControl": Eac3LfeControl.from_dict(obj["LfeControl"]) if obj.get("LfeControl") is not None else None,
            "LfeFilter": Eac3LfeFilter.from_dict(obj["LfeFilter"]) if obj.get("LfeFilter") is not None else None,
            "LoRoCenterMixLevel": obj.get("LoRoCenterMixLevel"),
            "LoRoSurroundMixLevel": obj.get("LoRoSurroundMixLevel"),
            "LtRtCenterMixLevel": obj.get("LtRtCenterMixLevel"),
            "LtRtSurroundMixLevel": obj.get("LtRtSurroundMixLevel"),
            "MetadataControl": Eac3MetadataControl.from_dict(obj["MetadataControl"]) if obj.get("MetadataControl") is not None else None,
            "PassthroughControl": Eac3PassthroughControl.from_dict(obj["PassthroughControl"]) if obj.get("PassthroughControl") is not None else None,
            "PhaseControl": Eac3PhaseControl.from_dict(obj["PhaseControl"]) if obj.get("PhaseControl") is not None else None,
            "SampleRate": obj.get("SampleRate"),
            "StereoDownmix": Eac3StereoDownmix.from_dict(obj["StereoDownmix"]) if obj.get("StereoDownmix") is not None else None,
            "SurroundExMode": Eac3SurroundExMode.from_dict(obj["SurroundExMode"]) if obj.get("SurroundExMode") is not None else None,
            "SurroundMode": Eac3SurroundMode.from_dict(obj["SurroundMode"]) if obj.get("SurroundMode") is not None else None
        })
        return _obj


