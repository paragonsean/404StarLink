# coding: utf-8

"""
    Master Data API - v2

    # ATTENTION: **This version isn't compliant with data entities of old version (e.g. CL and AD). It's possible to use this configuration only to new data entities.**      ## Welcome!    VTEX Master Data is an easy-to-use, secure, fast, scalable and extensible repository. On it you can create your own Entities, store data and consult directly from the storefront or use it to store info for some external integration.    There are internal VTEX modules that use VTEX Master Data as data repository. We have the VTEX Customer Service, VTEX Profile System and VTEX InStore, for example. It is also used by other internal services.    There are two ways to use Master Data:    1. Directly from the storefront  2. External integration    ### Directly from the storefront    If your scenario is to be used inside the storefront, be aware of the following observations:    1. Use the storefront host to query or store information to avoid **CORS**;  2. Configure which information should be public and which shouldn't, inside the JSON Schema of the Data Entity;  3. Do not create query loops (the storefront may be affected with Throttling and apis may be turned off as a security protection);  4. Never add via JS any type of authentication key (x-vtex-api-appkey or x-vtex-api-apptoken);    **It's important to avoid CORS using the relative path**    ### External Integration    If your scenario is to perform external integration, such as migrating client data from another service, be aware of the following observations:    1. Use the host ```{{accountName}}.vtexcommercestable.com.br```;  2. Use the authentication keys (x-vtex-api-appkey ou x-vtex-api-apptoken);    ### Most used attributes listed here    | Name | Description |  | -------- | -------- |  | accountName | Account name in VTEX License Manager |  | name | Data Entity name |  | schema | JSON Schema of a Data Entity |  | id | Identifier of a document |  | x-vtex-api-appKey | User key |  | x-vtex-api-appToken | User token |

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CreateUpdateProfileRequests(BaseModel):
    """
    CreateUpdateProfileRequests
    """ # noqa: E501
    document: Optional[StrictStr] = Field(default=None, description="Client document.")
    document_type: Optional[StrictStr] = Field(default=None, description="Client document type.", alias="documentType")
    email: Optional[StrictStr] = Field(default=None, description="Client email address.")
    first_name: Optional[StrictStr] = Field(default=None, description="Client first name.", alias="firstName")
    is_corporate: Optional[StrictBool] = Field(default=None, description="Indicates whether client is corporate.", alias="isCorporate")
    is_newsletter_opt_in: Optional[StrictBool] = Field(default=None, description="Indicates whether client otped to receive the store newsletter.", alias="isNewsletterOptIn")
    last_name: Optional[StrictStr] = Field(default=None, description="Client last name.", alias="lastName")
    locale_default: Optional[StrictStr] = Field(default=None, description="Default locale, used to set store language and currency, for example.", alias="localeDefault")
    phone: Optional[StrictStr] = Field(default=None, description="Client telephone number.")
    __properties: ClassVar[List[str]] = ["document", "documentType", "email", "firstName", "isCorporate", "isNewsletterOptIn", "lastName", "localeDefault", "phone"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateUpdateProfileRequests from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if document (nullable) is None
        # and model_fields_set contains the field
        if self.document is None and "document" in self.model_fields_set:
            _dict['document'] = None

        # set to None if document_type (nullable) is None
        # and model_fields_set contains the field
        if self.document_type is None and "document_type" in self.model_fields_set:
            _dict['documentType'] = None

        # set to None if email (nullable) is None
        # and model_fields_set contains the field
        if self.email is None and "email" in self.model_fields_set:
            _dict['email'] = None

        # set to None if first_name (nullable) is None
        # and model_fields_set contains the field
        if self.first_name is None and "first_name" in self.model_fields_set:
            _dict['firstName'] = None

        # set to None if is_corporate (nullable) is None
        # and model_fields_set contains the field
        if self.is_corporate is None and "is_corporate" in self.model_fields_set:
            _dict['isCorporate'] = None

        # set to None if is_newsletter_opt_in (nullable) is None
        # and model_fields_set contains the field
        if self.is_newsletter_opt_in is None and "is_newsletter_opt_in" in self.model_fields_set:
            _dict['isNewsletterOptIn'] = None

        # set to None if last_name (nullable) is None
        # and model_fields_set contains the field
        if self.last_name is None and "last_name" in self.model_fields_set:
            _dict['lastName'] = None

        # set to None if locale_default (nullable) is None
        # and model_fields_set contains the field
        if self.locale_default is None and "locale_default" in self.model_fields_set:
            _dict['localeDefault'] = None

        # set to None if phone (nullable) is None
        # and model_fields_set contains the field
        if self.phone is None and "phone" in self.model_fields_set:
            _dict['phone'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateUpdateProfileRequests from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "document": obj.get("document"),
            "documentType": obj.get("documentType"),
            "email": obj.get("email"),
            "firstName": obj.get("firstName"),
            "isCorporate": obj.get("isCorporate"),
            "isNewsletterOptIn": obj.get("isNewsletterOptIn"),
            "lastName": obj.get("lastName"),
            "localeDefault": obj.get("localeDefault"),
            "phone": obj.get("phone")
        })
        return _obj


