# coding: utf-8

"""
    MotaWord API

    Use MotaWord API to post and track your translation projects.

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.error import Error
from openapi_client.models.project_links import ProjectLinks
from openapi_client.models.project_price import ProjectPrice
from openapi_client.models.project_source import ProjectSource
from openapi_client.models.project_status import ProjectStatus
from openapi_client.models.project_word_count_analysis import ProjectWordCountAnalysis
from openapi_client.models.user import User
from openapi_client.models.vendor_project_pair import VendorProjectPair
from openapi_client.models.vendor_project_role import VendorProjectRole
from typing import Optional, Set
from typing_extensions import Self

class Project(BaseModel):
    """
    Project
    """ # noqa: E501
    average_scores: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = None
    budget_code: Optional[StrictStr] = None
    callback_url: Optional[StrictStr] = Field(default=None, description="Callback URL to notify when project status changed.")
    can_pam_manage: Optional[StrictBool] = None
    client: Optional[User] = None
    cm_id: Optional[StrictInt] = Field(default=None, description="Assigned admin's id")
    completed_on: Optional[datetime] = Field(default=None, description="the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z")
    continuous_project_type: Optional[StrictStr] = None
    created_at: Optional[StrictInt] = Field(default=None, description="Unix epoch time")
    custom: Optional[Dict[str, Any]] = Field(default=None, description="Custom data provided while creating a new project.")
    delivery_at: Optional[StrictInt] = Field(default=None, description="Unix epoch time")
    errors: Optional[List[Error]] = Field(default=None, description="A list of errors. Visible when creating a project and uploading your documents at the same time, in case of multiple errors.")
    id: Optional[StrictInt] = None
    is_api_project: Optional[StrictBool] = None
    is_certified: Optional[StrictBool] = None
    is_continuous: Optional[StrictBool] = None
    is_manual: Optional[StrictBool] = None
    links: Optional[ProjectLinks] = None
    pairs: Optional[List[VendorProjectPair]] = Field(default=None, description="Currently authed vendor's available working language pairs in this project. Includes rates per language pair. Includes complex pair logic such as bilingualism, project reverse pair enforcement etc.")
    pivoted_projects: Optional[List[StrictInt]] = Field(default=None, description="Quote IDs of pivots")
    price: Optional[ProjectPrice] = None
    price_without_discount: Optional[ProjectPrice] = None
    role: Optional[VendorProjectRole] = None
    should_send_client_survey: Optional[StrictBool] = None
    source: Optional[ProjectSource] = None
    source_language: Optional[StrictStr] = None
    status: Optional[ProjectStatus] = None
    subjects: Optional[List[StrictStr]] = None
    target_languages: Optional[List[StrictStr]] = None
    tms_name: Optional[StrictStr] = Field(default=None, description="TMS project name for this MW project. Requires privileged scope.")
    valid_until: Optional[StrictInt] = Field(default=None, description="Unix epoch time. Available only if status is `pending`.")
    vendor_word_count: Optional[StrictInt] = None
    word_count: Optional[StrictInt] = None
    word_count_analysis: Optional[ProjectWordCountAnalysis] = None
    __properties: ClassVar[List[str]] = ["average_scores", "budget_code", "callback_url", "can_pam_manage", "client", "cm_id", "completed_on", "continuous_project_type", "created_at", "custom", "delivery_at", "errors", "id", "is_api_project", "is_certified", "is_continuous", "is_manual", "links", "pairs", "pivoted_projects", "price", "price_without_discount", "role", "should_send_client_survey", "source", "source_language", "status", "subjects", "target_languages", "tms_name", "valid_until", "vendor_word_count", "word_count", "word_count_analysis"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Project from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of client
        if self.client:
            _dict['client'] = self.client.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in errors (list)
        _items = []
        if self.errors:
            for _item_errors in self.errors:
                if _item_errors:
                    _items.append(_item_errors.to_dict())
            _dict['errors'] = _items
        # override the default output from pydantic by calling `to_dict()` of links
        if self.links:
            _dict['links'] = self.links.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in pairs (list)
        _items = []
        if self.pairs:
            for _item_pairs in self.pairs:
                if _item_pairs:
                    _items.append(_item_pairs.to_dict())
            _dict['pairs'] = _items
        # override the default output from pydantic by calling `to_dict()` of price
        if self.price:
            _dict['price'] = self.price.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_without_discount
        if self.price_without_discount:
            _dict['price_without_discount'] = self.price_without_discount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of word_count_analysis
        if self.word_count_analysis:
            _dict['word_count_analysis'] = self.word_count_analysis.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Project from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "average_scores": obj.get("average_scores"),
            "budget_code": obj.get("budget_code"),
            "callback_url": obj.get("callback_url"),
            "can_pam_manage": obj.get("can_pam_manage"),
            "client": User.from_dict(obj["client"]) if obj.get("client") is not None else None,
            "cm_id": obj.get("cm_id"),
            "completed_on": obj.get("completed_on"),
            "continuous_project_type": obj.get("continuous_project_type"),
            "created_at": obj.get("created_at"),
            "custom": obj.get("custom"),
            "delivery_at": obj.get("delivery_at"),
            "errors": [Error.from_dict(_item) for _item in obj["errors"]] if obj.get("errors") is not None else None,
            "id": obj.get("id"),
            "is_api_project": obj.get("is_api_project"),
            "is_certified": obj.get("is_certified"),
            "is_continuous": obj.get("is_continuous"),
            "is_manual": obj.get("is_manual"),
            "links": ProjectLinks.from_dict(obj["links"]) if obj.get("links") is not None else None,
            "pairs": [VendorProjectPair.from_dict(_item) for _item in obj["pairs"]] if obj.get("pairs") is not None else None,
            "pivoted_projects": obj.get("pivoted_projects"),
            "price": ProjectPrice.from_dict(obj["price"]) if obj.get("price") is not None else None,
            "price_without_discount": ProjectPrice.from_dict(obj["price_without_discount"]) if obj.get("price_without_discount") is not None else None,
            "role": obj.get("role"),
            "should_send_client_survey": obj.get("should_send_client_survey"),
            "source": obj.get("source"),
            "source_language": obj.get("source_language"),
            "status": obj.get("status"),
            "subjects": obj.get("subjects"),
            "target_languages": obj.get("target_languages"),
            "tms_name": obj.get("tms_name"),
            "valid_until": obj.get("valid_until"),
            "vendor_word_count": obj.get("vendor_word_count"),
            "word_count": obj.get("word_count"),
            "word_count_analysis": ProjectWordCountAnalysis.from_dict(obj["word_count_analysis"]) if obj.get("word_count_analysis") is not None else None
        })
        return _obj


