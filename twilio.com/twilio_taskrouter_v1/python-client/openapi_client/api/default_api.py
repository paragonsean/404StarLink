# coding: utf-8

"""
    Twilio - Taskrouter

    This is the public Twilio REST API.

    The version of the OpenAPI document: 1.42.0
    Contact: support@twilio.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.list_activity_response import ListActivityResponse
from openapi_client.models.list_event_response import ListEventResponse
from openapi_client.models.list_task_channel_response import ListTaskChannelResponse
from openapi_client.models.list_task_queue_response import ListTaskQueueResponse
from openapi_client.models.list_task_queues_statistics_response import ListTaskQueuesStatisticsResponse
from openapi_client.models.list_task_reservation_response import ListTaskReservationResponse
from openapi_client.models.list_task_response import ListTaskResponse
from openapi_client.models.list_worker_channel_response import ListWorkerChannelResponse
from openapi_client.models.list_worker_reservation_response import ListWorkerReservationResponse
from openapi_client.models.list_worker_response import ListWorkerResponse
from openapi_client.models.list_workflow_response import ListWorkflowResponse
from openapi_client.models.list_workspace_response import ListWorkspaceResponse
from openapi_client.models.taskrouter_v1_workspace import TaskrouterV1Workspace
from openapi_client.models.taskrouter_v1_workspace_activity import TaskrouterV1WorkspaceActivity
from openapi_client.models.taskrouter_v1_workspace_event import TaskrouterV1WorkspaceEvent
from openapi_client.models.taskrouter_v1_workspace_task import TaskrouterV1WorkspaceTask
from openapi_client.models.taskrouter_v1_workspace_task_channel import TaskrouterV1WorkspaceTaskChannel
from openapi_client.models.taskrouter_v1_workspace_task_queue import TaskrouterV1WorkspaceTaskQueue
from openapi_client.models.taskrouter_v1_workspace_task_queue_task_queue_cumulative_statistics import TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics
from openapi_client.models.taskrouter_v1_workspace_task_queue_task_queue_real_time_statistics import TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics
from openapi_client.models.taskrouter_v1_workspace_task_queue_task_queue_statistics import TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics
from openapi_client.models.taskrouter_v1_workspace_task_task_reservation import TaskrouterV1WorkspaceTaskTaskReservation
from openapi_client.models.taskrouter_v1_workspace_worker import TaskrouterV1WorkspaceWorker
from openapi_client.models.taskrouter_v1_workspace_worker_worker_channel import TaskrouterV1WorkspaceWorkerWorkerChannel
from openapi_client.models.taskrouter_v1_workspace_worker_worker_instance_statistics import TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics
from openapi_client.models.taskrouter_v1_workspace_worker_worker_reservation import TaskrouterV1WorkspaceWorkerWorkerReservation
from openapi_client.models.taskrouter_v1_workspace_worker_worker_statistics import TaskrouterV1WorkspaceWorkerWorkerStatistics
from openapi_client.models.taskrouter_v1_workspace_worker_workers_cumulative_statistics import TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics
from openapi_client.models.taskrouter_v1_workspace_worker_workers_real_time_statistics import TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics
from openapi_client.models.taskrouter_v1_workspace_workflow import TaskrouterV1WorkspaceWorkflow
from openapi_client.models.taskrouter_v1_workspace_workflow_workflow_cumulative_statistics import TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics
from openapi_client.models.taskrouter_v1_workspace_workflow_workflow_real_time_statistics import TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics
from openapi_client.models.taskrouter_v1_workspace_workflow_workflow_statistics import TaskrouterV1WorkspaceWorkflowWorkflowStatistics
from openapi_client.models.taskrouter_v1_workspace_workspace_cumulative_statistics import TaskrouterV1WorkspaceWorkspaceCumulativeStatistics
from openapi_client.models.taskrouter_v1_workspace_workspace_real_time_statistics import TaskrouterV1WorkspaceWorkspaceRealTimeStatistics
from openapi_client.models.taskrouter_v1_workspace_workspace_statistics import TaskrouterV1WorkspaceWorkspaceStatistics

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_activity(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Activity belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceActivity:
        """create_activity

        

        :param workspace_sid: The SID of the Workspace that the new Activity belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`. (required)
        :type friendly_name: str
        :param available: Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.
        :type available: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_activity_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Activity belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceActivity]:
        """create_activity

        

        :param workspace_sid: The SID of the Workspace that the new Activity belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`. (required)
        :type friendly_name: str
        :param available: Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.
        :type available: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_activity_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Activity belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_activity

        

        :param workspace_sid: The SID of the Workspace that the new Activity belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`. (required)
        :type friendly_name: str
        :param available: Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.
        :type available: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_activity_serialize(
        self,
        workspace_sid,
        friendly_name,
        available,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if available is not None:
            _form_params.append(('Available', available))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Activities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_task(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task belongs to.")],
        attributes: Annotated[Optional[StrictStr], Field(description="A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTask:
        """create_task

        

        :param workspace_sid: The SID of the Workspace that the new Task belongs to. (required)
        :type workspace_sid: str
        :param attributes: A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.
        :type attributes: str
        :param priority: The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.
        :type task_channel: str
        :param timeout: The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.
        :type timeout: int
        :param workflow_sid: The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.
        :type workflow_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_serialize(
            workspace_sid=workspace_sid,
            attributes=attributes,
            priority=priority,
            task_channel=task_channel,
            timeout=timeout,
            workflow_sid=workflow_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_task_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task belongs to.")],
        attributes: Annotated[Optional[StrictStr], Field(description="A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTask]:
        """create_task

        

        :param workspace_sid: The SID of the Workspace that the new Task belongs to. (required)
        :type workspace_sid: str
        :param attributes: A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.
        :type attributes: str
        :param priority: The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.
        :type task_channel: str
        :param timeout: The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.
        :type timeout: int
        :param workflow_sid: The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.
        :type workflow_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_serialize(
            workspace_sid=workspace_sid,
            attributes=attributes,
            priority=priority,
            task_channel=task_channel,
            timeout=timeout,
            workflow_sid=workflow_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_task_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task belongs to.")],
        attributes: Annotated[Optional[StrictStr], Field(description="A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_task

        

        :param workspace_sid: The SID of the Workspace that the new Task belongs to. (required)
        :type workspace_sid: str
        :param attributes: A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.
        :type attributes: str
        :param priority: The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.
        :type task_channel: str
        :param timeout: The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.
        :type timeout: int
        :param workflow_sid: The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.
        :type workflow_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_serialize(
            workspace_sid=workspace_sid,
            attributes=attributes,
            priority=priority,
            task_channel=task_channel,
            timeout=timeout,
            workflow_sid=workflow_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_task_serialize(
        self,
        workspace_sid,
        attributes,
        priority,
        task_channel,
        timeout,
        workflow_sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if attributes is not None:
            _form_params.append(('Attributes', attributes))
        if priority is not None:
            _form_params.append(('Priority', priority))
        if task_channel is not None:
            _form_params.append(('TaskChannel', task_channel))
        if timeout is not None:
            _form_params.append(('Timeout', timeout))
        if workflow_sid is not None:
            _form_params.append(('WorkflowSid', workflow_sid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_task_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task Channel belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")],
        unique_name: Annotated[StrictStr, Field(description="An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskChannel:
        """create_task_channel

        

        :param workspace_sid: The SID of the Workspace that the new Task Channel belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param unique_name: An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`. (required)
        :type unique_name: str
        :param channel_optimized_routing: Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_channel_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            unique_name=unique_name,
            channel_optimized_routing=channel_optimized_routing,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_task_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task Channel belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")],
        unique_name: Annotated[StrictStr, Field(description="An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskChannel]:
        """create_task_channel

        

        :param workspace_sid: The SID of the Workspace that the new Task Channel belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param unique_name: An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`. (required)
        :type unique_name: str
        :param channel_optimized_routing: Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_channel_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            unique_name=unique_name,
            channel_optimized_routing=channel_optimized_routing,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_task_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Task Channel belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")],
        unique_name: Annotated[StrictStr, Field(description="An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_task_channel

        

        :param workspace_sid: The SID of the Workspace that the new Task Channel belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param unique_name: An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`. (required)
        :type unique_name: str
        :param channel_optimized_routing: Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_channel_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            unique_name=unique_name,
            channel_optimized_routing=channel_optimized_routing,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_task_channel_serialize(
        self,
        workspace_sid,
        friendly_name,
        unique_name,
        channel_optimized_routing,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if channel_optimized_routing is not None:
            _form_params.append(('ChannelOptimizedRouting', channel_optimized_routing))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if unique_name is not None:
            _form_params.append(('UniqueName', unique_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskChannels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_task_queue(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new TaskQueue belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned to them.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueue:
        """create_task_queue

        

        :param workspace_sid: The SID of the Workspace that the new TaskQueue belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`. (required)
        :type friendly_name: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned to them.
        :type assignment_activity_sid: str
        :param max_reserved_workers: The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            assignment_activity_sid=assignment_activity_sid,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_task_queue_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new TaskQueue belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned to them.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueue]:
        """create_task_queue

        

        :param workspace_sid: The SID of the Workspace that the new TaskQueue belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`. (required)
        :type friendly_name: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned to them.
        :type assignment_activity_sid: str
        :param max_reserved_workers: The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            assignment_activity_sid=assignment_activity_sid,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_task_queue_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new TaskQueue belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned to them.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_task_queue

        

        :param workspace_sid: The SID of the Workspace that the new TaskQueue belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`. (required)
        :type friendly_name: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned to them.
        :type assignment_activity_sid: str
        :param max_reserved_workers: The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            assignment_activity_sid=assignment_activity_sid,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_task_queue_serialize(
        self,
        workspace_sid,
        friendly_name,
        assignment_activity_sid,
        max_reserved_workers,
        reservation_activity_sid,
        target_workers,
        task_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if assignment_activity_sid is not None:
            _form_params.append(('AssignmentActivitySid', assignment_activity_sid))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if max_reserved_workers is not None:
            _form_params.append(('MaxReservedWorkers', max_reserved_workers))
        if reservation_activity_sid is not None:
            _form_params.append(('ReservationActivitySid', reservation_activity_sid))
        if target_workers is not None:
            _form_params.append(('TargetWorkers', target_workers))
        if task_order is not None:
            _form_params.append(('TaskOrder', task_order))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_worker(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Worker belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the new Worker. It can be up to 64 characters long.")],
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorker:
        """create_worker

        

        :param workspace_sid: The SID of the Workspace that the new Worker belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the new Worker. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param activity_sid: The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.
        :type activity_sid: str
        :param attributes: A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_worker_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            activity_sid=activity_sid,
            attributes=attributes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_worker_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Worker belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the new Worker. It can be up to 64 characters long.")],
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorker]:
        """create_worker

        

        :param workspace_sid: The SID of the Workspace that the new Worker belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the new Worker. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param activity_sid: The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.
        :type activity_sid: str
        :param attributes: A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_worker_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            activity_sid=activity_sid,
            attributes=attributes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_worker_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Worker belongs to.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the new Worker. It can be up to 64 characters long.")],
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_worker

        

        :param workspace_sid: The SID of the Workspace that the new Worker belongs to. (required)
        :type workspace_sid: str
        :param friendly_name: A descriptive string that you create to describe the new Worker. It can be up to 64 characters long. (required)
        :type friendly_name: str
        :param activity_sid: The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.
        :type activity_sid: str
        :param attributes: A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_worker_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            activity_sid=activity_sid,
            attributes=attributes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_worker_serialize(
        self,
        workspace_sid,
        friendly_name,
        activity_sid,
        attributes,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if activity_sid is not None:
            _form_params.append(('ActivitySid', activity_sid))
        if attributes is not None:
            _form_params.append(('Attributes', attributes))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_workflow(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Workflow to create belongs to.")],
        configuration: Annotated[StrictStr, Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflow:
        """create_workflow

        

        :param workspace_sid: The SID of the Workspace that the new Workflow to create belongs to. (required)
        :type workspace_sid: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information. (required)
        :type configuration: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`. (required)
        :type friendly_name: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workflow_serialize(
            workspace_sid=workspace_sid,
            configuration=configuration,
            friendly_name=friendly_name,
            assignment_callback_url=assignment_callback_url,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_workflow_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Workflow to create belongs to.")],
        configuration: Annotated[StrictStr, Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflow]:
        """create_workflow

        

        :param workspace_sid: The SID of the Workspace that the new Workflow to create belongs to. (required)
        :type workspace_sid: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information. (required)
        :type configuration: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`. (required)
        :type friendly_name: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workflow_serialize(
            workspace_sid=workspace_sid,
            configuration=configuration,
            friendly_name=friendly_name,
            assignment_callback_url=assignment_callback_url,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_workflow_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace that the new Workflow to create belongs to.")],
        configuration: Annotated[StrictStr, Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")],
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_workflow

        

        :param workspace_sid: The SID of the Workspace that the new Workflow to create belongs to. (required)
        :type workspace_sid: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information. (required)
        :type configuration: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`. (required)
        :type friendly_name: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workflow_serialize(
            workspace_sid=workspace_sid,
            configuration=configuration,
            friendly_name=friendly_name,
            assignment_callback_url=assignment_callback_url,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_workflow_serialize(
        self,
        workspace_sid,
        configuration,
        friendly_name,
        assignment_callback_url,
        fallback_assignment_callback_url,
        task_reservation_timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if assignment_callback_url is not None:
            _form_params.append(('AssignmentCallbackUrl', assignment_callback_url))
        if configuration is not None:
            _form_params.append(('Configuration', configuration))
        if fallback_assignment_callback_url is not None:
            _form_params.append(('FallbackAssignmentCallbackUrl', fallback_assignment_callback_url))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if task_reservation_timeout is not None:
            _form_params.append(('TaskReservationTimeout', task_reservation_timeout))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_workspace(
        self,
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`.")],
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        template: Annotated[Optional[StrictStr], Field(description="An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1Workspace:
        """create_workspace

        

        :param friendly_name: A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`. (required)
        :type friendly_name: str
        :param event_callback_url: The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param template: An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workspace_serialize(
            friendly_name=friendly_name,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_workspace_with_http_info(
        self,
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`.")],
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        template: Annotated[Optional[StrictStr], Field(description="An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1Workspace]:
        """create_workspace

        

        :param friendly_name: A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`. (required)
        :type friendly_name: str
        :param event_callback_url: The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param template: An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workspace_serialize(
            friendly_name=friendly_name,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_workspace_without_preload_content(
        self,
        friendly_name: Annotated[StrictStr, Field(description="A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`.")],
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        template: Annotated[Optional[StrictStr], Field(description="An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """create_workspace

        

        :param friendly_name: A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`. (required)
        :type friendly_name: str
        :param event_callback_url: The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param template: An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_workspace_serialize(
            friendly_name=friendly_name,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_workspace_serialize(
        self,
        friendly_name,
        event_callback_url,
        events_filter,
        multi_task_enabled,
        prioritize_queue_order,
        template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if event_callback_url is not None:
            _form_params.append(('EventCallbackUrl', event_callback_url))
        if events_filter is not None:
            _form_params.append(('EventsFilter', events_filter))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if multi_task_enabled is not None:
            _form_params.append(('MultiTaskEnabled', multi_task_enabled))
        if prioritize_queue_order is not None:
            _form_params.append(('PrioritizeQueueOrder', prioritize_queue_order))
        if template is not None:
            _form_params.append(('Template', template))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_activity(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_activity_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_activity_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_activity_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_task(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_task

        

        :param workspace_sid: The SID of the Workspace with the Task to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to delete. (required)
        :type sid: str
        :param if_match: If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_task_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_task

        

        :param workspace_sid: The SID of the Workspace with the Task to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to delete. (required)
        :type sid: str
        :param if_match: If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_task_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_task

        

        :param workspace_sid: The SID of the Workspace with the Task to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to delete. (required)
        :type sid: str
        :param if_match: If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_task_serialize(
        self,
        workspace_sid,
        sid,
        if_match,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_task_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to delete.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_task_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to delete.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_task_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to delete.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_task_channel_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_task_queue(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_task_queue_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_task_queue_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_task_queue_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_worker(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to delete. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_worker_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to delete. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_worker_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to delete.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to delete. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_worker_serialize(
        self,
        workspace_sid,
        sid,
        if_match,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_workflow(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_workflow_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_workflow_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to delete.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to delete. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_workflow_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_workspace(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> None:
        """delete_workspace

        

        :param sid: The SID of the Workspace resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_workspace_with_http_info(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[None]:
        """delete_workspace

        

        :param sid: The SID of the Workspace resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_workspace_without_preload_content(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """delete_workspace

        

        :param sid: The SID of the Workspace resource to delete. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_workspace_serialize(
        self,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v1/Workspaces/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_activity(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceActivity:
        """fetch_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_activity_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceActivity]:
        """fetch_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_activity_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_activity_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_event(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Event to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Event resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceEvent:
        """fetch_event

        

        :param workspace_sid: The SID of the Workspace with the Event to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Event resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_event_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_event_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Event to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Event resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceEvent]:
        """fetch_event

        

        :param workspace_sid: The SID of the Workspace with the Event to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Event resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_event_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_event_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Event to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Event resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_event

        

        :param workspace_sid: The SID of the Workspace with the Event to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Event resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_event_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceEvent",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_event_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Events/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTask:
        """fetch_task

        

        :param workspace_sid: The SID of the Workspace with the Task to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTask]:
        """fetch_task

        

        :param workspace_sid: The SID of the Workspace with the Task to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task

        

        :param workspace_sid: The SID of the Workspace with the Task to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskChannel:
        """fetch_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskChannel]:
        """fetch_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_channel_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_queue(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueue:
        """fetch_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_queue_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueue]:
        """fetch_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_queue_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_queue_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_queue_cumulative_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics:
        """fetch_task_queue_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_queue_cumulative_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics]:
        """fetch_task_queue_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_queue_cumulative_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_queue_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. TaskRouter will calculate statistics on up to 10,000 Tasks/Reservations for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_queue_cumulative_statistics_serialize(
        self,
        workspace_sid,
        task_queue_sid,
        end_date,
        minutes,
        start_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_queue_sid is not None:
            _path_params['TaskQueueSid'] = task_queue_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_queue_real_time_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics:
        """fetch_task_queue_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param task_channel: The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_queue_real_time_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics]:
        """fetch_task_queue_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param task_channel: The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_queue_real_time_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_queue_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param task_channel: The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_queue_real_time_statistics_serialize(
        self,
        workspace_sid,
        task_queue_sid,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_queue_sid is not None:
            _path_params['TaskQueueSid'] = task_queue_sid
        # process the query parameters
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_queue_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics:
        """fetch_task_queue_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_queue_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics]:
        """fetch_task_queue_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_queue_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to fetch.")],
        task_queue_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue for which to fetch statistics.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_queue_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to fetch. (required)
        :type workspace_sid: str
        :param task_queue_sid: The SID of the TaskQueue for which to fetch statistics. (required)
        :type task_queue_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_queue_statistics_serialize(
            workspace_sid=workspace_sid,
            task_queue_sid=task_queue_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_queue_statistics_serialize(
        self,
        workspace_sid,
        task_queue_sid,
        end_date,
        minutes,
        start_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_queue_sid is not None:
            _path_params['TaskQueueSid'] = task_queue_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_task_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resource to fetch.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskTaskReservation:
        """fetch_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resource to fetch. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resource to fetch. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_task_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resource to fetch.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskTaskReservation]:
        """fetch_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resource to fetch. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resource to fetch. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_task_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resource to fetch.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resource to fetch. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resource to fetch. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_task_reservation_serialize(
        self,
        workspace_sid,
        task_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_sid is not None:
            _path_params['TaskSid'] = task_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_worker(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorker:
        """fetch_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_worker_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorker]:
        """fetch_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_worker_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_worker_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_worker_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerChannel:
        """fetch_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_worker_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerChannel]:
        """fetch_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_worker_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_worker_channel_serialize(
        self,
        workspace_sid,
        worker_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_worker_instance_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics:
        """fetch_worker_instance_statistics

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_instance_statistics_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_worker_instance_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics]:
        """fetch_worker_instance_statistics

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_instance_statistics_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_worker_instance_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_worker_instance_statistics

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to fetch. (required)
        :type worker_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_instance_statistics_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_worker_instance_statistics_serialize(
        self,
        workspace_sid,
        worker_sid,
        minutes,
        start_date,
        end_date,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        # process the query parameters
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_worker_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resource to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerReservation:
        """fetch_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resource to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resource to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_worker_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resource to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerReservation]:
        """fetch_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resource to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resource to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_worker_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resource to fetch.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resource to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resource to fetch. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resource to fetch. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_worker_reservation_serialize(
        self,
        workspace_sid,
        worker_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_worker_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue for which to fetch Worker statistics.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue for which to fetch Worker statistics.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="Only include Workers with `friendly_name` values that match this parameter.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerStatistics:
        """fetch_worker_statistics

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_queue_sid: The SID of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_name: str
        :param friendly_name: Only include Workers with `friendly_name` values that match this parameter.
        :type friendly_name: str
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            friendly_name=friendly_name,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_worker_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue for which to fetch Worker statistics.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue for which to fetch Worker statistics.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="Only include Workers with `friendly_name` values that match this parameter.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerStatistics]:
        """fetch_worker_statistics

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_queue_sid: The SID of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_name: str
        :param friendly_name: Only include Workers with `friendly_name` values that match this parameter.
        :type friendly_name: str
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            friendly_name=friendly_name,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_worker_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue for which to fetch Worker statistics.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue for which to fetch Worker statistics.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="Only include Workers with `friendly_name` values that match this parameter.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_worker_statistics

        

        :param workspace_sid: The SID of the Workspace with the Worker to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_queue_sid: The SID of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue for which to fetch Worker statistics.
        :type task_queue_name: str
        :param friendly_name: Only include Workers with `friendly_name` values that match this parameter.
        :type friendly_name: str
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_worker_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            friendly_name=friendly_name,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_worker_statistics_serialize(
        self,
        workspace_sid,
        minutes,
        start_date,
        end_date,
        task_queue_sid,
        task_queue_name,
        friendly_name,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if task_queue_sid is not None:
            
            _query_params.append(('TaskQueueSid', task_queue_sid))
            
        if task_queue_name is not None:
            
            _query_params.append(('TaskQueueName', task_queue_name))
            
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workers_cumulative_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics:
        """fetch_workers_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workers_cumulative_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics]:
        """fetch_workers_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workers_cumulative_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workers_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workers_cumulative_statistics_serialize(
        self,
        workspace_sid,
        end_date,
        minutes,
        start_date,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workers_real_time_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics:
        """fetch_workers_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workers_real_time_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics]:
        """fetch_workers_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workers_real_time_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workers_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workers_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workers_real_time_statistics_serialize(
        self,
        workspace_sid,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workflow(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflow:
        """fetch_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workflow_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflow]:
        """fetch_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workflow_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workflow_serialize(
        self,
        workspace_sid,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workflow_cumulative_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics:
        """fetch_workflow_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value. (required)
        :type workflow_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workflow_cumulative_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics]:
        """fetch_workflow_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value. (required)
        :type workflow_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workflow_cumulative_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the resource to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workflow_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace with the resource to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value. (required)
        :type workflow_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workflow_cumulative_statistics_serialize(
        self,
        workspace_sid,
        workflow_sid,
        end_date,
        minutes,
        start_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if workflow_sid is not None:
            _path_params['WorkflowSid'] = workflow_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workflow_real_time_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics:
        """fetch_workflow_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workflow_real_time_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics]:
        """fetch_workflow_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workflow_real_time_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workflow_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workflow_real_time_statistics_serialize(
        self,
        workspace_sid,
        workflow_sid,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if workflow_sid is not None:
            _path_params['WorkflowSid'] = workflow_sid
        # process the query parameters
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workflow_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflowWorkflowStatistics:
        """fetch_workflow_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workflow_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflowWorkflowStatistics]:
        """fetch_workflow_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workflow_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to fetch.")],
        workflow_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workflow_statistics

        

        :param workspace_sid: The SID of the Workspace with the Workflow to fetch. (required)
        :type workspace_sid: str
        :param workflow_sid: Returns the list of Tasks that are being controlled by the Workflow with the specified SID value. (required)
        :type workflow_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workflow_statistics_serialize(
            workspace_sid=workspace_sid,
            workflow_sid=workflow_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflowWorkflowStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workflow_statistics_serialize(
        self,
        workspace_sid,
        workflow_sid,
        minutes,
        start_date,
        end_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if workflow_sid is not None:
            _path_params['WorkflowSid'] = workflow_sid
        # process the query parameters
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workspace(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1Workspace:
        """fetch_workspace

        

        :param sid: The SID of the Workspace resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workspace_with_http_info(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1Workspace]:
        """fetch_workspace

        

        :param sid: The SID of the Workspace resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workspace_without_preload_content(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to fetch.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workspace

        

        :param sid: The SID of the Workspace resource to fetch. (required)
        :type sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_serialize(
            sid=sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workspace_serialize(
        self,
        sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workspace_cumulative_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkspaceCumulativeStatistics:
        """fetch_workspace_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workspace_cumulative_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkspaceCumulativeStatistics]:
        """fetch_workspace_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workspace_cumulative_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workspace_cumulative_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param end_date: Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA. TaskRouter will calculate statistics on up to 10,000 Tasks for any given threshold.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_cumulative_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceCumulativeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workspace_cumulative_statistics_serialize(
        self,
        workspace_sid,
        end_date,
        minutes,
        start_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/CumulativeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workspace_real_time_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkspaceRealTimeStatistics:
        """fetch_workspace_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workspace_real_time_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkspaceRealTimeStatistics]:
        """fetch_workspace_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workspace_real_time_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workspace_real_time_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param task_channel: Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_real_time_statistics_serialize(
            workspace_sid=workspace_sid,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceRealTimeStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workspace_real_time_statistics_serialize(
        self,
        workspace_sid,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/RealTimeStatistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fetch_workspace_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkspaceStatistics:
        """fetch_workspace_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fetch_workspace_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkspaceStatistics]:
        """fetch_workspace_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fetch_workspace_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace to fetch.")],
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """fetch_workspace_statistics

        

        :param workspace_sid: The SID of the Workspace to fetch. (required)
        :type workspace_sid: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
        :type split_by_wait_time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fetch_workspace_statistics_serialize(
            workspace_sid=workspace_sid,
            minutes=minutes,
            start_date=start_date,
            end_date=end_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkspaceStatistics",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fetch_workspace_statistics_serialize(
        self,
        workspace_sid,
        minutes,
        start_date,
        end_date,
        task_channel,
        split_by_wait_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_activity(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Activity resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListActivityResponse:
        """list_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Activity resources to read.
        :type friendly_name: str
        :param available: Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.
        :type available: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListActivityResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_activity_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Activity resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListActivityResponse]:
        """list_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Activity resources to read.
        :type friendly_name: str
        :param available: Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.
        :type available: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListActivityResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_activity_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Activity resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Activity resources to read.
        :type friendly_name: str
        :param available: Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.
        :type available: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_activity_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            available=available,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListActivityResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_activity_serialize(
        self,
        workspace_sid,
        friendly_name,
        available,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if available is not None:
            
            _query_params.append(('Available', available))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Activities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_event(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="The type of Events to read. Returns only Events of the type specified.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.")] = None,
        reservation_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.")] = None,
        task_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.")] = None,
        sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Event resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListEventResponse:
        """list_event

        

        :param workspace_sid: The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace. (required)
        :type workspace_sid: str
        :param end_date: Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param event_type: The type of Events to read. Returns only Events of the type specified.
        :type event_type: str
        :param minutes: The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.
        :type minutes: int
        :param reservation_sid: The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.
        :type reservation_sid: str
        :param start_date: Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.
        :type start_date: datetime
        :param task_queue_sid: The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.
        :type task_queue_sid: str
        :param task_sid: The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.
        :type task_sid: str
        :param worker_sid: The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.
        :type worker_sid: str
        :param workflow_sid: The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.
        :type workflow_sid: str
        :param task_channel: The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.
        :type task_channel: str
        :param sid: The SID of the Event resource to read.
        :type sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_event_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            event_type=event_type,
            minutes=minutes,
            reservation_sid=reservation_sid,
            start_date=start_date,
            task_queue_sid=task_queue_sid,
            task_sid=task_sid,
            worker_sid=worker_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            sid=sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_event_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="The type of Events to read. Returns only Events of the type specified.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.")] = None,
        reservation_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.")] = None,
        task_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.")] = None,
        sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Event resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListEventResponse]:
        """list_event

        

        :param workspace_sid: The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace. (required)
        :type workspace_sid: str
        :param end_date: Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param event_type: The type of Events to read. Returns only Events of the type specified.
        :type event_type: str
        :param minutes: The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.
        :type minutes: int
        :param reservation_sid: The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.
        :type reservation_sid: str
        :param start_date: Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.
        :type start_date: datetime
        :param task_queue_sid: The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.
        :type task_queue_sid: str
        :param task_sid: The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.
        :type task_sid: str
        :param worker_sid: The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.
        :type worker_sid: str
        :param workflow_sid: The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.
        :type workflow_sid: str
        :param task_channel: The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.
        :type task_channel: str
        :param sid: The SID of the Event resource to read.
        :type sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_event_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            event_type=event_type,
            minutes=minutes,
            reservation_sid=reservation_sid,
            start_date=start_date,
            task_queue_sid=task_queue_sid,
            task_sid=task_sid,
            worker_sid=worker_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            sid=sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_event_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace.")],
        end_date: Annotated[Optional[datetime], Field(description="Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="The type of Events to read. Returns only Events of the type specified.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.")] = None,
        reservation_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.")] = None,
        task_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.")] = None,
        sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Event resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_event

        

        :param workspace_sid: The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace. (required)
        :type workspace_sid: str
        :param end_date: Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param event_type: The type of Events to read. Returns only Events of the type specified.
        :type event_type: str
        :param minutes: The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.
        :type minutes: int
        :param reservation_sid: The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.
        :type reservation_sid: str
        :param start_date: Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.
        :type start_date: datetime
        :param task_queue_sid: The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.
        :type task_queue_sid: str
        :param task_sid: The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.
        :type task_sid: str
        :param worker_sid: The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.
        :type worker_sid: str
        :param workflow_sid: The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.
        :type workflow_sid: str
        :param task_channel: The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.
        :type task_channel: str
        :param sid: The SID of the Event resource to read.
        :type sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_event_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            event_type=event_type,
            minutes=minutes,
            reservation_sid=reservation_sid,
            start_date=start_date,
            task_queue_sid=task_queue_sid,
            task_sid=task_sid,
            worker_sid=worker_sid,
            workflow_sid=workflow_sid,
            task_channel=task_channel,
            sid=sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_event_serialize(
        self,
        workspace_sid,
        end_date,
        event_type,
        minutes,
        reservation_sid,
        start_date,
        task_queue_sid,
        task_sid,
        worker_sid,
        workflow_sid,
        task_channel,
        sid,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if event_type is not None:
            
            _query_params.append(('EventType', event_type))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if reservation_sid is not None:
            
            _query_params.append(('ReservationSid', reservation_sid))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_queue_sid is not None:
            
            _query_params.append(('TaskQueueSid', task_queue_sid))
            
        if task_sid is not None:
            
            _query_params.append(('TaskSid', task_sid))
            
        if worker_sid is not None:
            
            _query_params.append(('WorkerSid', worker_sid))
            
        if workflow_sid is not None:
            
            _query_params.append(('WorkflowSid', workflow_sid))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if sid is not None:
            
            _query_params.append(('Sid', sid))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Tasks to read.")],
        priority: Annotated[Optional[StrictInt], Field(description="The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.")] = None,
        assignment_status: Annotated[Optional[List[StrictStr]], Field(description="The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.")] = None,
        workflow_name: Annotated[Optional[StrictStr], Field(description="The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.")] = None,
        evaluate_task_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.")] = None,
        has_addons: Annotated[Optional[StrictBool], Field(description="Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListTaskResponse:
        """list_task

        

        :param workspace_sid: The SID of the Workspace with the Tasks to read. (required)
        :type workspace_sid: str
        :param priority: The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.
        :type priority: int
        :param assignment_status: The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.
        :type assignment_status: List[str]
        :param workflow_sid: The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.
        :type workflow_sid: str
        :param workflow_name: The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.
        :type workflow_name: str
        :param task_queue_sid: The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.
        :type task_queue_name: str
        :param evaluate_task_attributes: The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.
        :type evaluate_task_attributes: str
        :param ordering: How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.
        :type ordering: str
        :param has_addons: Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.
        :type has_addons: bool
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_serialize(
            workspace_sid=workspace_sid,
            priority=priority,
            assignment_status=assignment_status,
            workflow_sid=workflow_sid,
            workflow_name=workflow_name,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            evaluate_task_attributes=evaluate_task_attributes,
            ordering=ordering,
            has_addons=has_addons,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Tasks to read.")],
        priority: Annotated[Optional[StrictInt], Field(description="The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.")] = None,
        assignment_status: Annotated[Optional[List[StrictStr]], Field(description="The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.")] = None,
        workflow_name: Annotated[Optional[StrictStr], Field(description="The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.")] = None,
        evaluate_task_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.")] = None,
        has_addons: Annotated[Optional[StrictBool], Field(description="Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListTaskResponse]:
        """list_task

        

        :param workspace_sid: The SID of the Workspace with the Tasks to read. (required)
        :type workspace_sid: str
        :param priority: The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.
        :type priority: int
        :param assignment_status: The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.
        :type assignment_status: List[str]
        :param workflow_sid: The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.
        :type workflow_sid: str
        :param workflow_name: The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.
        :type workflow_name: str
        :param task_queue_sid: The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.
        :type task_queue_name: str
        :param evaluate_task_attributes: The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.
        :type evaluate_task_attributes: str
        :param ordering: How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.
        :type ordering: str
        :param has_addons: Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.
        :type has_addons: bool
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_serialize(
            workspace_sid=workspace_sid,
            priority=priority,
            assignment_status=assignment_status,
            workflow_sid=workflow_sid,
            workflow_name=workflow_name,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            evaluate_task_attributes=evaluate_task_attributes,
            ordering=ordering,
            has_addons=has_addons,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Tasks to read.")],
        priority: Annotated[Optional[StrictInt], Field(description="The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.")] = None,
        assignment_status: Annotated[Optional[List[StrictStr]], Field(description="The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.")] = None,
        workflow_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.")] = None,
        workflow_name: Annotated[Optional[StrictStr], Field(description="The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.")] = None,
        evaluate_task_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.")] = None,
        has_addons: Annotated[Optional[StrictBool], Field(description="Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_task

        

        :param workspace_sid: The SID of the Workspace with the Tasks to read. (required)
        :type workspace_sid: str
        :param priority: The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.
        :type priority: int
        :param assignment_status: The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.
        :type assignment_status: List[str]
        :param workflow_sid: The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.
        :type workflow_sid: str
        :param workflow_name: The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.
        :type workflow_name: str
        :param task_queue_sid: The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.
        :type task_queue_sid: str
        :param task_queue_name: The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.
        :type task_queue_name: str
        :param evaluate_task_attributes: The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.
        :type evaluate_task_attributes: str
        :param ordering: How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.
        :type ordering: str
        :param has_addons: Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.
        :type has_addons: bool
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_serialize(
            workspace_sid=workspace_sid,
            priority=priority,
            assignment_status=assignment_status,
            workflow_sid=workflow_sid,
            workflow_name=workflow_name,
            task_queue_sid=task_queue_sid,
            task_queue_name=task_queue_name,
            evaluate_task_attributes=evaluate_task_attributes,
            ordering=ordering,
            has_addons=has_addons,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_serialize(
        self,
        workspace_sid,
        priority,
        assignment_status,
        workflow_sid,
        workflow_name,
        task_queue_sid,
        task_queue_name,
        evaluate_task_attributes,
        ordering,
        has_addons,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
            'AssignmentStatus': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if priority is not None:
            
            _query_params.append(('Priority', priority))
            
        if assignment_status is not None:
            
            _query_params.append(('AssignmentStatus', assignment_status))
            
        if workflow_sid is not None:
            
            _query_params.append(('WorkflowSid', workflow_sid))
            
        if workflow_name is not None:
            
            _query_params.append(('WorkflowName', workflow_name))
            
        if task_queue_sid is not None:
            
            _query_params.append(('TaskQueueSid', task_queue_sid))
            
        if task_queue_name is not None:
            
            _query_params.append(('TaskQueueName', task_queue_name))
            
        if evaluate_task_attributes is not None:
            
            _query_params.append(('EvaluateTaskAttributes', evaluate_task_attributes))
            
        if ordering is not None:
            
            _query_params.append(('Ordering', ordering))
            
        if has_addons is not None:
            
            _query_params.append(('HasAddons', has_addons))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListTaskChannelResponse:
        """list_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to read. (required)
        :type workspace_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_channel_serialize(
            workspace_sid=workspace_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListTaskChannelResponse]:
        """list_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to read. (required)
        :type workspace_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_channel_serialize(
            workspace_sid=workspace_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to read. (required)
        :type workspace_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_channel_serialize(
            workspace_sid=workspace_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_channel_serialize(
        self,
        workspace_sid,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskChannels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_queue(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue resources to read.")] = None,
        evaluate_worker_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the TaskQueue resources to read.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for TaskQueues")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListTaskQueueResponse:
        """list_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the TaskQueue resources to read.
        :type friendly_name: str
        :param evaluate_worker_attributes: The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.
        :type evaluate_worker_attributes: str
        :param worker_sid: The SID of the Worker with the TaskQueue resources to read.
        :type worker_sid: str
        :param ordering: Sorting parameter for TaskQueues
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            evaluate_worker_attributes=evaluate_worker_attributes,
            worker_sid=worker_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueueResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_queue_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue resources to read.")] = None,
        evaluate_worker_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the TaskQueue resources to read.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for TaskQueues")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListTaskQueueResponse]:
        """list_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the TaskQueue resources to read.
        :type friendly_name: str
        :param evaluate_worker_attributes: The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.
        :type evaluate_worker_attributes: str
        :param worker_sid: The SID of the Worker with the TaskQueue resources to read.
        :type worker_sid: str
        :param ordering: Sorting parameter for TaskQueues
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            evaluate_worker_attributes=evaluate_worker_attributes,
            worker_sid=worker_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueueResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_queue_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue resources to read.")] = None,
        evaluate_worker_attributes: Annotated[Optional[StrictStr], Field(description="The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Worker with the TaskQueue resources to read.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for TaskQueues")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the TaskQueue resources to read.
        :type friendly_name: str
        :param evaluate_worker_attributes: The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.
        :type evaluate_worker_attributes: str
        :param worker_sid: The SID of the Worker with the TaskQueue resources to read.
        :type worker_sid: str
        :param ordering: Sorting parameter for TaskQueues
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queue_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            evaluate_worker_attributes=evaluate_worker_attributes,
            worker_sid=worker_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueueResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_queue_serialize(
        self,
        workspace_sid,
        friendly_name,
        evaluate_worker_attributes,
        worker_sid,
        ordering,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if evaluate_worker_attributes is not None:
            
            _query_params.append(('EvaluateWorkerAttributes', evaluate_worker_attributes))
            
        if worker_sid is not None:
            
            _query_params.append(('WorkerSid', worker_sid))
            
        if ordering is not None:
            
            _query_params.append(('Ordering', ordering))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_queues_statistics(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueues to read.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue statistics to read.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListTaskQueuesStatisticsResponse:
        """list_task_queues_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueues to read. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param friendly_name: The `friendly_name` of the TaskQueue statistics to read.
        :type friendly_name: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queues_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            friendly_name=friendly_name,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueuesStatisticsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_queues_statistics_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueues to read.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue statistics to read.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListTaskQueuesStatisticsResponse]:
        """list_task_queues_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueues to read. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param friendly_name: The `friendly_name` of the TaskQueue statistics to read.
        :type friendly_name: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queues_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            friendly_name=friendly_name,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueuesStatisticsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_queues_statistics_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueues to read.")],
        end_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue statistics to read.")] = None,
        minutes: Annotated[Optional[StrictInt], Field(description="Only calculate statistics since this many minutes in the past. The default is 15 minutes.")] = None,
        start_date: Annotated[Optional[datetime], Field(description="Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        split_by_wait_time: Annotated[Optional[StrictStr], Field(description="A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_task_queues_statistics

        

        :param workspace_sid: The SID of the Workspace with the TaskQueues to read. (required)
        :type workspace_sid: str
        :param end_date: Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
        :type end_date: datetime
        :param friendly_name: The `friendly_name` of the TaskQueue statistics to read.
        :type friendly_name: str
        :param minutes: Only calculate statistics since this many minutes in the past. The default is 15 minutes.
        :type minutes: int
        :param start_date: Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
        :type start_date: datetime
        :param task_channel: Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param split_by_wait_time: A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
        :type split_by_wait_time: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_queues_statistics_serialize(
            workspace_sid=workspace_sid,
            end_date=end_date,
            friendly_name=friendly_name,
            minutes=minutes,
            start_date=start_date,
            task_channel=task_channel,
            split_by_wait_time=split_by_wait_time,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskQueuesStatisticsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_queues_statistics_serialize(
        self,
        workspace_sid,
        end_date,
        friendly_name,
        minutes,
        start_date,
        task_channel,
        split_by_wait_time,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        'EndDate',
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('EndDate', end_date))
            
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if minutes is not None:
            
            _query_params.append(('Minutes', minutes))
            
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        'StartDate',
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('StartDate', start_date))
            
        if task_channel is not None:
            
            _query_params.append(('TaskChannel', task_channel))
            
        if split_by_wait_time is not None:
            
            _query_params.append(('SplitByWaitTime', split_by_wait_time))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to read.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the reserved Worker resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListTaskReservationResponse:
        """list_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to read. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to read. (required)
        :type task_sid: str
        :param reservation_status: Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.
        :type reservation_status: TaskReservationEnumStatus
        :param worker_sid: The SID of the reserved Worker resource to read.
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            reservation_status=reservation_status,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to read.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the reserved Worker resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListTaskReservationResponse]:
        """list_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to read. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to read. (required)
        :type task_sid: str
        :param reservation_status: Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.
        :type reservation_status: TaskReservationEnumStatus
        :param worker_sid: The SID of the reserved Worker resource to read.
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            reservation_status=reservation_status,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to read.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.")] = None,
        worker_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the reserved Worker resource to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to read. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to read. (required)
        :type task_sid: str
        :param reservation_status: Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.
        :type reservation_status: TaskReservationEnumStatus
        :param worker_sid: The SID of the reserved Worker resource to read.
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            reservation_status=reservation_status,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTaskReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_reservation_serialize(
        self,
        workspace_sid,
        task_sid,
        reservation_status,
        worker_sid,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_sid is not None:
            _path_params['TaskSid'] = task_sid
        # process the query parameters
        if reservation_status is not None:
            
            _query_params.append(('ReservationStatus', reservation_status.value))
            
        if worker_sid is not None:
            
            _query_params.append(('WorkerSid', worker_sid))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_worker(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workers to read.")],
        activity_name: Annotated[Optional[StrictStr], Field(description="The `activity_name` of the Worker resources to read.")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The `activity_sid` of the Worker resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Worker resources to read.")] = None,
        target_workers_expression: Annotated[Optional[StrictStr], Field(description="Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue that the Workers to read are eligible for.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue that the Workers to read are eligible for.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for Workers")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListWorkerResponse:
        """list_worker

        

        :param workspace_sid: The SID of the Workspace with the Workers to read. (required)
        :type workspace_sid: str
        :param activity_name: The `activity_name` of the Worker resources to read.
        :type activity_name: str
        :param activity_sid: The `activity_sid` of the Worker resources to read.
        :type activity_sid: str
        :param available: Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.
        :type available: str
        :param friendly_name: The `friendly_name` of the Worker resources to read.
        :type friendly_name: str
        :param target_workers_expression: Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.
        :type target_workers_expression: str
        :param task_queue_name: The `friendly_name` of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_name: str
        :param task_queue_sid: The SID of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_sid: str
        :param ordering: Sorting parameter for Workers
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_serialize(
            workspace_sid=workspace_sid,
            activity_name=activity_name,
            activity_sid=activity_sid,
            available=available,
            friendly_name=friendly_name,
            target_workers_expression=target_workers_expression,
            task_queue_name=task_queue_name,
            task_queue_sid=task_queue_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_worker_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workers to read.")],
        activity_name: Annotated[Optional[StrictStr], Field(description="The `activity_name` of the Worker resources to read.")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The `activity_sid` of the Worker resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Worker resources to read.")] = None,
        target_workers_expression: Annotated[Optional[StrictStr], Field(description="Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue that the Workers to read are eligible for.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue that the Workers to read are eligible for.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for Workers")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListWorkerResponse]:
        """list_worker

        

        :param workspace_sid: The SID of the Workspace with the Workers to read. (required)
        :type workspace_sid: str
        :param activity_name: The `activity_name` of the Worker resources to read.
        :type activity_name: str
        :param activity_sid: The `activity_sid` of the Worker resources to read.
        :type activity_sid: str
        :param available: Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.
        :type available: str
        :param friendly_name: The `friendly_name` of the Worker resources to read.
        :type friendly_name: str
        :param target_workers_expression: Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.
        :type target_workers_expression: str
        :param task_queue_name: The `friendly_name` of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_name: str
        :param task_queue_sid: The SID of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_sid: str
        :param ordering: Sorting parameter for Workers
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_serialize(
            workspace_sid=workspace_sid,
            activity_name=activity_name,
            activity_sid=activity_sid,
            available=available,
            friendly_name=friendly_name,
            target_workers_expression=target_workers_expression,
            task_queue_name=task_queue_name,
            task_queue_sid=task_queue_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_worker_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workers to read.")],
        activity_name: Annotated[Optional[StrictStr], Field(description="The `activity_name` of the Worker resources to read.")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The `activity_sid` of the Worker resources to read.")] = None,
        available: Annotated[Optional[StrictStr], Field(description="Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Worker resources to read.")] = None,
        target_workers_expression: Annotated[Optional[StrictStr], Field(description="Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.")] = None,
        task_queue_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the TaskQueue that the Workers to read are eligible for.")] = None,
        task_queue_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the TaskQueue that the Workers to read are eligible for.")] = None,
        ordering: Annotated[Optional[StrictStr], Field(description="Sorting parameter for Workers")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_worker

        

        :param workspace_sid: The SID of the Workspace with the Workers to read. (required)
        :type workspace_sid: str
        :param activity_name: The `activity_name` of the Worker resources to read.
        :type activity_name: str
        :param activity_sid: The `activity_sid` of the Worker resources to read.
        :type activity_sid: str
        :param available: Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.
        :type available: str
        :param friendly_name: The `friendly_name` of the Worker resources to read.
        :type friendly_name: str
        :param target_workers_expression: Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.
        :type target_workers_expression: str
        :param task_queue_name: The `friendly_name` of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_name: str
        :param task_queue_sid: The SID of the TaskQueue that the Workers to read are eligible for.
        :type task_queue_sid: str
        :param ordering: Sorting parameter for Workers
        :type ordering: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_serialize(
            workspace_sid=workspace_sid,
            activity_name=activity_name,
            activity_sid=activity_sid,
            available=available,
            friendly_name=friendly_name,
            target_workers_expression=target_workers_expression,
            task_queue_name=task_queue_name,
            task_queue_sid=task_queue_sid,
            ordering=ordering,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_worker_serialize(
        self,
        workspace_sid,
        activity_name,
        activity_sid,
        available,
        friendly_name,
        target_workers_expression,
        task_queue_name,
        task_queue_sid,
        ordering,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if activity_name is not None:
            
            _query_params.append(('ActivityName', activity_name))
            
        if activity_sid is not None:
            
            _query_params.append(('ActivitySid', activity_sid))
            
        if available is not None:
            
            _query_params.append(('Available', available))
            
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if target_workers_expression is not None:
            
            _query_params.append(('TargetWorkersExpression', target_workers_expression))
            
        if task_queue_name is not None:
            
            _query_params.append(('TaskQueueName', task_queue_name))
            
        if task_queue_sid is not None:
            
            _query_params.append(('TaskQueueSid', task_queue_sid))
            
        if ordering is not None:
            
            _query_params.append(('Ordering', ordering))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_worker_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannels to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannels to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListWorkerChannelResponse:
        """list_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannels to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannels to read. (required)
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_worker_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannels to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannels to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListWorkerChannelResponse]:
        """list_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannels to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannels to read. (required)
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_worker_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannels to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannels to read.")],
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannels to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannels to read. (required)
        :type worker_sid: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerChannelResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_worker_channel_serialize(
        self,
        workspace_sid,
        worker_sid,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        # process the query parameters
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_worker_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListWorkerReservationResponse:
        """list_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to read. (required)
        :type worker_sid: str
        :param reservation_status: Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
        :type reservation_status: WorkerReservationEnumStatus
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            reservation_status=reservation_status,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_worker_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListWorkerReservationResponse]:
        """list_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to read. (required)
        :type worker_sid: str
        :param reservation_status: Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
        :type reservation_status: WorkerReservationEnumStatus
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            reservation_status=reservation_status,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_worker_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to read.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to read.")],
        reservation_status: Annotated[Optional[StrictStr], Field(description="Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to read. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to read. (required)
        :type worker_sid: str
        :param reservation_status: Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
        :type reservation_status: WorkerReservationEnumStatus
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            reservation_status=reservation_status,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkerReservationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_worker_reservation_serialize(
        self,
        workspace_sid,
        worker_sid,
        reservation_status,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        # process the query parameters
        if reservation_status is not None:
            
            _query_params.append(('ReservationStatus', reservation_status.value))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_workflow(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workflow resources to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListWorkflowResponse:
        """list_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Workflow resources to read.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workflow_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkflowResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_workflow_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workflow resources to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListWorkflowResponse]:
        """list_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Workflow resources to read.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workflow_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkflowResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_workflow_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to read.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workflow resources to read.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to read. (required)
        :type workspace_sid: str
        :param friendly_name: The `friendly_name` of the Workflow resources to read.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workflow_serialize(
            workspace_sid=workspace_sid,
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkflowResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_workflow_serialize(
        self,
        workspace_sid,
        friendly_name,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        # process the query parameters
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_workspace(
        self,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ListWorkspaceResponse:
        """list_workspace

        

        :param friendly_name: The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workspace_serialize(
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkspaceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_workspace_with_http_info(
        self,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[ListWorkspaceResponse]:
        """list_workspace

        

        :param friendly_name: The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workspace_serialize(
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkspaceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_workspace_without_preload_content(
        self,
        friendly_name: Annotated[Optional[StrictStr], Field(description="The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="How many resources to return in each list page. The default is 50, and the maximum is 1000.")] = None,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The page index. This value is simply for client state.")] = None,
        page_token: Annotated[Optional[StrictStr], Field(description="The page token. This is provided by the API.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """list_workspace

        

        :param friendly_name: The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.
        :type friendly_name: str
        :param page_size: How many resources to return in each list page. The default is 50, and the maximum is 1000.
        :type page_size: int
        :param page: The page index. This value is simply for client state.
        :type page: int
        :param page_token: The page token. This is provided by the API.
        :type page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_workspace_serialize(
            friendly_name=friendly_name,
            page_size=page_size,
            page=page,
            page_token=page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListWorkspaceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_workspace_serialize(
        self,
        friendly_name,
        page_size,
        page,
        page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if friendly_name is not None:
            
            _query_params.append(('FriendlyName', friendly_name))
            
        if page_size is not None:
            
            _query_params.append(('PageSize', page_size))
            
        if page is not None:
            
            _query_params.append(('Page', page))
            
        if page_token is not None:
            
            _query_params.append(('PageToken', page_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/Workspaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_activity(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to update.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceActivity:
        """update_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to update. (required)
        :type sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_activity_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to update.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceActivity]:
        """update_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to update. (required)
        :type sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_activity_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Activity resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Activity resource to update.")],
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_activity

        

        :param workspace_sid: The SID of the Workspace with the Activity resources to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Activity resource to update. (required)
        :type sid: str
        :param friendly_name: A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_activity_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceActivity",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_activity_serialize(
        self,
        workspace_sid,
        sid,
        friendly_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        assignment_status: Optional[StrictStr] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the custom attributes of the task.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTask:
        """update_task

        

        :param workspace_sid: The SID of the Workspace with the Task to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to update. (required)
        :type sid: str
        :param if_match: If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param assignment_status:
        :type assignment_status: TaskEnumStatus
        :param attributes: The JSON string that describes the custom attributes of the task.
        :type attributes: str
        :param priority: The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param reason: The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.
        :type reason: str
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            assignment_status=assignment_status,
            attributes=attributes,
            priority=priority,
            reason=reason,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        assignment_status: Optional[StrictStr] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the custom attributes of the task.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTask]:
        """update_task

        

        :param workspace_sid: The SID of the Workspace with the Task to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to update. (required)
        :type sid: str
        :param if_match: If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param assignment_status:
        :type assignment_status: TaskEnumStatus
        :param attributes: The JSON string that describes the custom attributes of the task.
        :type attributes: str
        :param priority: The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param reason: The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.
        :type reason: str
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            assignment_status=assignment_status,
            attributes=attributes,
            priority=priority,
            reason=reason,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Task resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).")] = None,
        assignment_status: Optional[StrictStr] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the custom attributes of the task.")] = None,
        priority: Annotated[Optional[StrictInt], Field(description="The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).")] = None,
        reason: Annotated[Optional[StrictStr], Field(description="The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.")] = None,
        task_channel: Annotated[Optional[StrictStr], Field(description="When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_task

        

        :param workspace_sid: The SID of the Workspace with the Task to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task resource to update. (required)
        :type sid: str
        :param if_match: If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
        :type if_match: str
        :param assignment_status:
        :type assignment_status: TaskEnumStatus
        :param attributes: The JSON string that describes the custom attributes of the task.
        :type attributes: str
        :param priority: The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).
        :type priority: int
        :param reason: The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.
        :type reason: str
        :param task_channel: When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
        :type task_channel: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            assignment_status=assignment_status,
            attributes=attributes,
            priority=priority,
            reason=reason,
            task_channel=task_channel,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTask",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_serialize(
        self,
        workspace_sid,
        sid,
        if_match,
        assignment_status,
        attributes,
        priority,
        reason,
        task_channel,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        if assignment_status is not None:
            _form_params.append(('AssignmentStatus', assignment_status))
        if attributes is not None:
            _form_params.append(('Attributes', attributes))
        if priority is not None:
            _form_params.append(('Priority', priority))
        if reason is not None:
            _form_params.append(('Reason', reason))
        if task_channel is not None:
            _form_params.append(('TaskChannel', task_channel))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to update.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskChannel:
        """update_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to update. (required)
        :type sid: str
        :param channel_optimized_routing: Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            channel_optimized_routing=channel_optimized_routing,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to update.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskChannel]:
        """update_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to update. (required)
        :type sid: str
        :param channel_optimized_routing: Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            channel_optimized_routing=channel_optimized_routing,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Task Channel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the Task Channel resource to update.")],
        channel_optimized_routing: Annotated[Optional[StrictBool], Field(description="Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_task_channel

        

        :param workspace_sid: The SID of the Workspace with the Task Channel to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Task Channel resource to update. (required)
        :type sid: str
        :param channel_optimized_routing: Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
        :type channel_optimized_routing: bool
        :param friendly_name: A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
        :type friendly_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_channel_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            channel_optimized_routing=channel_optimized_routing,
            friendly_name=friendly_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_channel_serialize(
        self,
        workspace_sid,
        sid,
        channel_optimized_routing,
        friendly_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if channel_optimized_routing is not None:
            _form_params.append(('ChannelOptimizedRouting', channel_optimized_routing))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task_queue(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to update.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned for them.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskQueue:
        """update_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to update. (required)
        :type sid: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned for them.
        :type assignment_activity_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
        :type friendly_name: str
        :param max_reserved_workers: The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_activity_sid=assignment_activity_sid,
            friendly_name=friendly_name,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_queue_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to update.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned for them.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskQueue]:
        """update_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to update. (required)
        :type sid: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned for them.
        :type assignment_activity_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
        :type friendly_name: str
        :param max_reserved_workers: The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_activity_sid=assignment_activity_sid,
            friendly_name=friendly_name,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_queue_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskQueue to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskQueue resource to update.")],
        assignment_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is assigned for them.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.")] = None,
        max_reserved_workers: Annotated[Optional[StrictInt], Field(description="The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.")] = None,
        reservation_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity to assign Workers when a task is reserved for them.")] = None,
        target_workers: Annotated[Optional[StrictStr], Field(description="A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.")] = None,
        task_order: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_task_queue

        

        :param workspace_sid: The SID of the Workspace with the TaskQueue to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the TaskQueue resource to update. (required)
        :type sid: str
        :param assignment_activity_sid: The SID of the Activity to assign Workers when a task is assigned for them.
        :type assignment_activity_sid: str
        :param friendly_name: A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
        :type friendly_name: str
        :param max_reserved_workers: The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.
        :type max_reserved_workers: int
        :param reservation_activity_sid: The SID of the Activity to assign Workers when a task is reserved for them.
        :type reservation_activity_sid: str
        :param target_workers: A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.
        :type target_workers: str
        :param task_order:
        :type task_order: TaskQueueEnumTaskOrder
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_queue_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_activity_sid=assignment_activity_sid,
            friendly_name=friendly_name,
            max_reserved_workers=max_reserved_workers,
            reservation_activity_sid=reservation_activity_sid,
            target_workers=target_workers,
            task_order=task_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskQueue",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_queue_serialize(
        self,
        workspace_sid,
        sid,
        assignment_activity_sid,
        friendly_name,
        max_reserved_workers,
        reservation_activity_sid,
        target_workers,
        task_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if assignment_activity_sid is not None:
            _form_params.append(('AssignmentActivitySid', assignment_activity_sid))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if max_reserved_workers is not None:
            _form_params.append(('MaxReservedWorkers', max_reserved_workers))
        if reservation_activity_sid is not None:
            _form_params.append(('ReservationActivitySid', reservation_activity_sid))
        if target_workers is not None:
            _form_params.append(('TargetWorkers', target_workers))
        if task_order is not None:
            _form_params.append(('TaskOrder', task_order))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to update.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction or which leg to record.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call  for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The Call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The Callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. The default is `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. The default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        supervisor: Annotated[Optional[StrictStr], Field(description="The Supervisor SID/URI when executing the Supervise instruction.")] = None,
        supervisor_mode: Optional[StrictStr] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceTaskTaskReservation:
        """update_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to update. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to update. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction or which leg to record.
        :type call_record: str
        :param call_status_callback_url: The URL to call  for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: Timeout for call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[TaskReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The Caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The Call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The Callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: Timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The Caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. The default is `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. The default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: TaskReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[TaskReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param supervisor: The Supervisor SID/URI when executing the Supervise instruction.
        :type supervisor: str
        :param supervisor_mode:
        :type supervisor_mode: TaskReservationEnumSupervisorMode
        :param timeout: Timeout for call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            supervisor=supervisor,
            supervisor_mode=supervisor_mode,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to update.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction or which leg to record.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call  for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The Call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The Callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. The default is `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. The default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        supervisor: Annotated[Optional[StrictStr], Field(description="The Supervisor SID/URI when executing the Supervise instruction.")] = None,
        supervisor_mode: Optional[StrictStr] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceTaskTaskReservation]:
        """update_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to update. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to update. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction or which leg to record.
        :type call_record: str
        :param call_status_callback_url: The URL to call  for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: Timeout for call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[TaskReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The Caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The Call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The Callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: Timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The Caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. The default is `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. The default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: TaskReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[TaskReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param supervisor: The Supervisor SID/URI when executing the Supervise instruction.
        :type supervisor: str
        :param supervisor_mode:
        :type supervisor_mode: TaskReservationEnumSupervisorMode
        :param timeout: Timeout for call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            supervisor=supervisor,
            supervisor_mode=supervisor_mode,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the TaskReservation resources to update.")],
        task_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Task resource with the TaskReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the TaskReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction or which leg to record.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call  for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The Call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The Callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. The default is `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. The default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        supervisor: Annotated[Optional[StrictStr], Field(description="The Supervisor SID/URI when executing the Supervise instruction.")] = None,
        supervisor_mode: Optional[StrictStr] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="Timeout for call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_task_reservation

        

        :param workspace_sid: The SID of the Workspace with the TaskReservation resources to update. (required)
        :type workspace_sid: str
        :param task_sid: The SID of the reserved Task resource with the TaskReservation resources to update. (required)
        :type task_sid: str
        :param sid: The SID of the TaskReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction or which leg to record.
        :type call_record: str
        :param call_status_callback_url: The URL to call  for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: Timeout for call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[TaskReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The Caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The Call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The Callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: Timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The Caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. The default is `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. The default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: TaskReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[TaskReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param supervisor: The Supervisor SID/URI when executing the Supervise instruction.
        :type supervisor: str
        :param supervisor_mode:
        :type supervisor_mode: TaskReservationEnumSupervisorMode
        :param timeout: Timeout for call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_reservation_serialize(
            workspace_sid=workspace_sid,
            task_sid=task_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            supervisor=supervisor,
            supervisor_mode=supervisor_mode,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceTaskTaskReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_reservation_serialize(
        self,
        workspace_sid,
        task_sid,
        sid,
        if_match,
        beep,
        beep_on_customer_entrance,
        call_accept,
        call_from,
        call_record,
        call_status_callback_url,
        call_timeout,
        call_to,
        call_url,
        conference_record,
        conference_recording_status_callback,
        conference_recording_status_callback_method,
        conference_status_callback,
        conference_status_callback_event,
        conference_status_callback_method,
        conference_trim,
        dequeue_from,
        dequeue_post_work_activity_sid,
        dequeue_record,
        dequeue_status_callback_event,
        dequeue_status_callback_url,
        dequeue_timeout,
        dequeue_to,
        early_media,
        end_conference_on_customer_exit,
        end_conference_on_exit,
        var_from,
        instruction,
        max_participants,
        muted,
        post_work_activity_sid,
        record,
        recording_channels,
        recording_status_callback,
        recording_status_callback_method,
        redirect_accept,
        redirect_call_sid,
        redirect_url,
        region,
        reservation_status,
        sip_auth_password,
        sip_auth_username,
        start_conference_on_enter,
        status_callback,
        status_callback_event,
        status_callback_method,
        supervisor,
        supervisor_mode,
        timeout,
        to,
        wait_method,
        wait_url,
        worker_activity_sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
            'ConferenceStatusCallbackEvent': 'csv',
            'DequeueStatusCallbackEvent': 'csv',
            'StatusCallbackEvent': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if task_sid is not None:
            _path_params['TaskSid'] = task_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        if beep is not None:
            _form_params.append(('Beep', beep))
        if beep_on_customer_entrance is not None:
            _form_params.append(('BeepOnCustomerEntrance', beep_on_customer_entrance))
        if call_accept is not None:
            _form_params.append(('CallAccept', call_accept))
        if call_from is not None:
            _form_params.append(('CallFrom', call_from))
        if call_record is not None:
            _form_params.append(('CallRecord', call_record))
        if call_status_callback_url is not None:
            _form_params.append(('CallStatusCallbackUrl', call_status_callback_url))
        if call_timeout is not None:
            _form_params.append(('CallTimeout', call_timeout))
        if call_to is not None:
            _form_params.append(('CallTo', call_to))
        if call_url is not None:
            _form_params.append(('CallUrl', call_url))
        if conference_record is not None:
            _form_params.append(('ConferenceRecord', conference_record))
        if conference_recording_status_callback is not None:
            _form_params.append(('ConferenceRecordingStatusCallback', conference_recording_status_callback))
        if conference_recording_status_callback_method is not None:
            _form_params.append(('ConferenceRecordingStatusCallbackMethod', conference_recording_status_callback_method))
        if conference_status_callback is not None:
            _form_params.append(('ConferenceStatusCallback', conference_status_callback))
        if conference_status_callback_event is not None:
            _form_params.append(('ConferenceStatusCallbackEvent', conference_status_callback_event))
        if conference_status_callback_method is not None:
            _form_params.append(('ConferenceStatusCallbackMethod', conference_status_callback_method))
        if conference_trim is not None:
            _form_params.append(('ConferenceTrim', conference_trim))
        if dequeue_from is not None:
            _form_params.append(('DequeueFrom', dequeue_from))
        if dequeue_post_work_activity_sid is not None:
            _form_params.append(('DequeuePostWorkActivitySid', dequeue_post_work_activity_sid))
        if dequeue_record is not None:
            _form_params.append(('DequeueRecord', dequeue_record))
        if dequeue_status_callback_event is not None:
            _form_params.append(('DequeueStatusCallbackEvent', dequeue_status_callback_event))
        if dequeue_status_callback_url is not None:
            _form_params.append(('DequeueStatusCallbackUrl', dequeue_status_callback_url))
        if dequeue_timeout is not None:
            _form_params.append(('DequeueTimeout', dequeue_timeout))
        if dequeue_to is not None:
            _form_params.append(('DequeueTo', dequeue_to))
        if early_media is not None:
            _form_params.append(('EarlyMedia', early_media))
        if end_conference_on_customer_exit is not None:
            _form_params.append(('EndConferenceOnCustomerExit', end_conference_on_customer_exit))
        if end_conference_on_exit is not None:
            _form_params.append(('EndConferenceOnExit', end_conference_on_exit))
        if var_from is not None:
            _form_params.append(('From', var_from))
        if instruction is not None:
            _form_params.append(('Instruction', instruction))
        if max_participants is not None:
            _form_params.append(('MaxParticipants', max_participants))
        if muted is not None:
            _form_params.append(('Muted', muted))
        if post_work_activity_sid is not None:
            _form_params.append(('PostWorkActivitySid', post_work_activity_sid))
        if record is not None:
            _form_params.append(('Record', record))
        if recording_channels is not None:
            _form_params.append(('RecordingChannels', recording_channels))
        if recording_status_callback is not None:
            _form_params.append(('RecordingStatusCallback', recording_status_callback))
        if recording_status_callback_method is not None:
            _form_params.append(('RecordingStatusCallbackMethod', recording_status_callback_method))
        if redirect_accept is not None:
            _form_params.append(('RedirectAccept', redirect_accept))
        if redirect_call_sid is not None:
            _form_params.append(('RedirectCallSid', redirect_call_sid))
        if redirect_url is not None:
            _form_params.append(('RedirectUrl', redirect_url))
        if region is not None:
            _form_params.append(('Region', region))
        if reservation_status is not None:
            _form_params.append(('ReservationStatus', reservation_status))
        if sip_auth_password is not None:
            _form_params.append(('SipAuthPassword', sip_auth_password))
        if sip_auth_username is not None:
            _form_params.append(('SipAuthUsername', sip_auth_username))
        if start_conference_on_enter is not None:
            _form_params.append(('StartConferenceOnEnter', start_conference_on_enter))
        if status_callback is not None:
            _form_params.append(('StatusCallback', status_callback))
        if status_callback_event is not None:
            _form_params.append(('StatusCallbackEvent', status_callback_event))
        if status_callback_method is not None:
            _form_params.append(('StatusCallbackMethod', status_callback_method))
        if supervisor is not None:
            _form_params.append(('Supervisor', supervisor))
        if supervisor_mode is not None:
            _form_params.append(('SupervisorMode', supervisor_mode))
        if timeout is not None:
            _form_params.append(('Timeout', timeout))
        if to is not None:
            _form_params.append(('To', to))
        if wait_method is not None:
            _form_params.append(('WaitMethod', wait_method))
        if wait_url is not None:
            _form_params.append(('WaitUrl', wait_url))
        if worker_activity_sid is not None:
            _form_params.append(('WorkerActivitySid', worker_activity_sid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_worker(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Worker. It can be up to 64 characters long.")] = None,
        reject_pending_reservations: Annotated[Optional[StrictBool], Field(description="Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorker:
        """update_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param activity_sid: The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.
        :type activity_sid: str
        :param attributes: The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param friendly_name: A descriptive string that you create to describe the Worker. It can be up to 64 characters long.
        :type friendly_name: str
        :param reject_pending_reservations: Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.
        :type reject_pending_reservations: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            activity_sid=activity_sid,
            attributes=attributes,
            friendly_name=friendly_name,
            reject_pending_reservations=reject_pending_reservations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_worker_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Worker. It can be up to 64 characters long.")] = None,
        reject_pending_reservations: Annotated[Optional[StrictBool], Field(description="Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorker]:
        """update_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param activity_sid: The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.
        :type activity_sid: str
        :param attributes: The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param friendly_name: A descriptive string that you create to describe the Worker. It can be up to 64 characters long.
        :type friendly_name: str
        :param reject_pending_reservations: Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.
        :type reject_pending_reservations: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            activity_sid=activity_sid,
            attributes=attributes,
            friendly_name=friendly_name,
            reject_pending_reservations=reject_pending_reservations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_worker_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Worker to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.")] = None,
        attributes: Annotated[Optional[StrictStr], Field(description="The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Worker. It can be up to 64 characters long.")] = None,
        reject_pending_reservations: Annotated[Optional[StrictBool], Field(description="Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_worker

        

        :param workspace_sid: The SID of the Workspace with the Worker to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Worker resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param activity_sid: The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.
        :type activity_sid: str
        :param attributes: The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
        :type attributes: str
        :param friendly_name: A descriptive string that you create to describe the Worker. It can be up to 64 characters long.
        :type friendly_name: str
        :param reject_pending_reservations: Whether to reject the Worker's pending reservations. This option is only valid if the Worker's new [Activity](https://www.twilio.com/docs/taskrouter/api/activity) resource has its `availability` property set to `False`.
        :type reject_pending_reservations: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            if_match=if_match,
            activity_sid=activity_sid,
            attributes=attributes,
            friendly_name=friendly_name,
            reject_pending_reservations=reject_pending_reservations,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorker",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_worker_serialize(
        self,
        workspace_sid,
        sid,
        if_match,
        activity_sid,
        attributes,
        friendly_name,
        reject_pending_reservations,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        if activity_sid is not None:
            _form_params.append(('ActivitySid', activity_sid))
        if attributes is not None:
            _form_params.append(('Attributes', attributes))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if reject_pending_reservations is not None:
            _form_params.append(('RejectPendingReservations', reject_pending_reservations))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_worker_channel(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to update.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.")] = None,
        capacity: Annotated[Optional[StrictInt], Field(description="The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerChannel:
        """update_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to update. (required)
        :type sid: str
        :param available: Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.
        :type available: bool
        :param capacity: The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.
        :type capacity: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            available=available,
            capacity=capacity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_worker_channel_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to update.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.")] = None,
        capacity: Annotated[Optional[StrictInt], Field(description="The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerChannel]:
        """update_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to update. (required)
        :type sid: str
        :param available: Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.
        :type available: bool
        :param capacity: The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.
        :type capacity: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            available=available,
            capacity=capacity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_worker_channel_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerChannel to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Worker with the WorkerChannel to update.")],
        sid: Annotated[StrictStr, Field(description="The SID of the WorkerChannel to update.")],
        available: Annotated[Optional[StrictBool], Field(description="Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.")] = None,
        capacity: Annotated[Optional[StrictInt], Field(description="The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_worker_channel

        

        :param workspace_sid: The SID of the Workspace with the WorkerChannel to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the Worker with the WorkerChannel to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerChannel to update. (required)
        :type sid: str
        :param available: Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.
        :type available: bool
        :param capacity: The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.
        :type capacity: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_channel_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            available=available,
            capacity=capacity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerChannel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_worker_channel_serialize(
        self,
        workspace_sid,
        worker_sid,
        sid,
        available,
        capacity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if available is not None:
            _form_params.append(('Available', available))
        if capacity is not None:
            _form_params.append(('Capacity', capacity))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_worker_reservation(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for the reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. Defaults to `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkerWorkerReservation:
        """update_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction.
        :type call_record: str
        :param call_status_callback_url: The URL to call for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: The timeout for a call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[WorkerReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: The timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for the reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. Defaults to `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: WorkerReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[WorkerReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param timeout: The timeout for a call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_worker_reservation_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for the reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. Defaults to `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkerWorkerReservation]:
        """update_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction.
        :type call_record: str
        :param call_status_callback_url: The URL to call for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: The timeout for a call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[WorkerReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: The timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for the reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. Defaults to `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: WorkerReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[WorkerReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param timeout: The timeout for a call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_worker_reservation_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the WorkerReservation resources to update.")],
        worker_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the reserved Worker resource with the WorkerReservation resources to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the WorkerReservation resource to update.")],
        if_match: Annotated[Optional[StrictStr], Field(description="The If-Match HTTP request header")] = None,
        beep: Annotated[Optional[StrictStr], Field(description="Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.")] = None,
        beep_on_customer_entrance: Annotated[Optional[StrictBool], Field(description="Whether to play a notification beep when the customer joins.")] = None,
        call_accept: Annotated[Optional[StrictBool], Field(description="Whether to accept a reservation when executing a Call instruction.")] = None,
        call_from: Annotated[Optional[StrictStr], Field(description="The Caller ID of the outbound call when executing a Call instruction.")] = None,
        call_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Call instruction.")] = None,
        call_status_callback_url: Annotated[Optional[StrictStr], Field(description="The URL to call for the completed call event when executing a Call instruction.")] = None,
        call_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Call instruction.")] = None,
        call_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        call_url: Annotated[Optional[StrictStr], Field(description="TwiML URI executed on answering the worker's leg as a result of the Call instruction.")] = None,
        conference_record: Annotated[Optional[StrictStr], Field(description="Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.")] = None,
        conference_recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.")] = None,
        conference_recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.")] = None,
        conference_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.")] = None,
        conference_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        conference_trim: Annotated[Optional[StrictStr], Field(description="Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.")] = None,
        dequeue_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Dequeue instruction.")] = None,
        dequeue_post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity resource to start after executing a Dequeue instruction.")] = None,
        dequeue_record: Annotated[Optional[StrictStr], Field(description="Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.")] = None,
        dequeue_status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events sent via webhooks as a result of a Dequeue instruction.")] = None,
        dequeue_status_callback_url: Annotated[Optional[StrictStr], Field(description="The callback URL for completed call event when executing a Dequeue instruction.")] = None,
        dequeue_timeout: Annotated[Optional[StrictInt], Field(description="The timeout for call when executing a Dequeue instruction.")] = None,
        dequeue_to: Annotated[Optional[StrictStr], Field(description="The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        early_media: Annotated[Optional[StrictBool], Field(description="Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.")] = None,
        end_conference_on_customer_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the customer leaves.")] = None,
        end_conference_on_exit: Annotated[Optional[StrictBool], Field(description="Whether to end the conference when the agent leaves.")] = None,
        var_from: Annotated[Optional[StrictStr], Field(description="The caller ID of the call to the worker when executing a Conference instruction.")] = None,
        instruction: Annotated[Optional[StrictStr], Field(description="The assignment instruction for the reservation.")] = None,
        max_participants: Annotated[Optional[StrictInt], Field(description="The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.")] = None,
        muted: Annotated[Optional[StrictBool], Field(description="Whether the agent is muted in the conference. Defaults to `false`.")] = None,
        post_work_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID after executing a Conference instruction.")] = None,
        record: Annotated[Optional[StrictBool], Field(description="Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.")] = None,
        recording_channels: Annotated[Optional[StrictStr], Field(description="The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.")] = None,
        recording_status_callback: Annotated[Optional[StrictStr], Field(description="The URL that we should call using the `recording_status_callback_method` when the recording status changes.")] = None,
        recording_status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.")] = None,
        redirect_accept: Annotated[Optional[StrictBool], Field(description="Whether the reservation should be accepted when executing a Redirect instruction.")] = None,
        redirect_call_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The Call SID of the call parked in the queue when executing a Redirect instruction.")] = None,
        redirect_url: Annotated[Optional[StrictStr], Field(description="TwiML URI to redirect the call to when executing the Redirect instruction.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.")] = None,
        reservation_status: Optional[StrictStr] = None,
        sip_auth_password: Annotated[Optional[StrictStr], Field(description="The SIP password for authentication.")] = None,
        sip_auth_username: Annotated[Optional[StrictStr], Field(description="The SIP username used for authentication.")] = None,
        start_conference_on_enter: Annotated[Optional[StrictBool], Field(description="Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.")] = None,
        status_callback: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `status_callback_method` to send status information to your application.")] = None,
        status_callback_event: Annotated[Optional[List[StrictStr]], Field(description="The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.")] = None,
        status_callback_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The timeout for a call when executing a Conference instruction.")] = None,
        to: Annotated[Optional[StrictStr], Field(description="The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.")] = None,
        wait_method: Annotated[Optional[StrictStr], Field(description="The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.")] = None,
        wait_url: Annotated[Optional[StrictStr], Field(description="The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).")] = None,
        worker_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The new worker activity SID if rejecting a reservation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_worker_reservation

        

        :param workspace_sid: The SID of the Workspace with the WorkerReservation resources to update. (required)
        :type workspace_sid: str
        :param worker_sid: The SID of the reserved Worker resource with the WorkerReservation resources to update. (required)
        :type worker_sid: str
        :param sid: The SID of the WorkerReservation resource to update. (required)
        :type sid: str
        :param if_match: The If-Match HTTP request header
        :type if_match: str
        :param beep: Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
        :type beep: str
        :param beep_on_customer_entrance: Whether to play a notification beep when the customer joins.
        :type beep_on_customer_entrance: bool
        :param call_accept: Whether to accept a reservation when executing a Call instruction.
        :type call_accept: bool
        :param call_from: The Caller ID of the outbound call when executing a Call instruction.
        :type call_from: str
        :param call_record: Whether to record both legs of a call when executing a Call instruction.
        :type call_record: str
        :param call_status_callback_url: The URL to call for the completed call event when executing a Call instruction.
        :type call_status_callback_url: str
        :param call_timeout: The timeout for a call when executing a Call instruction.
        :type call_timeout: int
        :param call_to: The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type call_to: str
        :param call_url: TwiML URI executed on answering the worker's leg as a result of the Call instruction.
        :type call_url: str
        :param conference_record: Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
        :type conference_record: str
        :param conference_recording_status_callback: The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
        :type conference_recording_status_callback: str
        :param conference_recording_status_callback_method: The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_recording_status_callback_method: str
        :param conference_status_callback: The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
        :type conference_status_callback: str
        :param conference_status_callback_event: The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
        :type conference_status_callback_event: List[WorkerReservationEnumConferenceEvent]
        :param conference_status_callback_method: The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type conference_status_callback_method: str
        :param conference_trim: Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
        :type conference_trim: str
        :param dequeue_from: The caller ID of the call to the worker when executing a Dequeue instruction.
        :type dequeue_from: str
        :param dequeue_post_work_activity_sid: The SID of the Activity resource to start after executing a Dequeue instruction.
        :type dequeue_post_work_activity_sid: str
        :param dequeue_record: Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
        :type dequeue_record: str
        :param dequeue_status_callback_event: The call progress events sent via webhooks as a result of a Dequeue instruction.
        :type dequeue_status_callback_event: List[str]
        :param dequeue_status_callback_url: The callback URL for completed call event when executing a Dequeue instruction.
        :type dequeue_status_callback_url: str
        :param dequeue_timeout: The timeout for call when executing a Dequeue instruction.
        :type dequeue_timeout: int
        :param dequeue_to: The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type dequeue_to: str
        :param early_media: Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
        :type early_media: bool
        :param end_conference_on_customer_exit: Whether to end the conference when the customer leaves.
        :type end_conference_on_customer_exit: bool
        :param end_conference_on_exit: Whether to end the conference when the agent leaves.
        :type end_conference_on_exit: bool
        :param var_from: The caller ID of the call to the worker when executing a Conference instruction.
        :type var_from: str
        :param instruction: The assignment instruction for the reservation.
        :type instruction: str
        :param max_participants: The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
        :type max_participants: int
        :param muted: Whether the agent is muted in the conference. Defaults to `false`.
        :type muted: bool
        :param post_work_activity_sid: The new worker activity SID after executing a Conference instruction.
        :type post_work_activity_sid: str
        :param record: Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
        :type record: bool
        :param recording_channels: The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
        :type recording_channels: str
        :param recording_status_callback: The URL that we should call using the `recording_status_callback_method` when the recording status changes.
        :type recording_status_callback: str
        :param recording_status_callback_method: The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
        :type recording_status_callback_method: str
        :param redirect_accept: Whether the reservation should be accepted when executing a Redirect instruction.
        :type redirect_accept: bool
        :param redirect_call_sid: The Call SID of the call parked in the queue when executing a Redirect instruction.
        :type redirect_call_sid: str
        :param redirect_url: TwiML URI to redirect the call to when executing the Redirect instruction.
        :type redirect_url: str
        :param region: The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
        :type region: str
        :param reservation_status:
        :type reservation_status: WorkerReservationEnumStatus
        :param sip_auth_password: The SIP password for authentication.
        :type sip_auth_password: str
        :param sip_auth_username: The SIP username used for authentication.
        :type sip_auth_username: str
        :param start_conference_on_enter: Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
        :type start_conference_on_enter: bool
        :param status_callback: The URL we should call using the `status_callback_method` to send status information to your application.
        :type status_callback: str
        :param status_callback_event: The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
        :type status_callback_event: List[WorkerReservationEnumCallStatus]
        :param status_callback_method: The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
        :type status_callback_method: str
        :param timeout: The timeout for a call when executing a Conference instruction.
        :type timeout: int
        :param to: The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
        :type to: str
        :param wait_method: The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
        :type wait_method: str
        :param wait_url: The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
        :type wait_url: str
        :param worker_activity_sid: The new worker activity SID if rejecting a reservation.
        :type worker_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_worker_reservation_serialize(
            workspace_sid=workspace_sid,
            worker_sid=worker_sid,
            sid=sid,
            if_match=if_match,
            beep=beep,
            beep_on_customer_entrance=beep_on_customer_entrance,
            call_accept=call_accept,
            call_from=call_from,
            call_record=call_record,
            call_status_callback_url=call_status_callback_url,
            call_timeout=call_timeout,
            call_to=call_to,
            call_url=call_url,
            conference_record=conference_record,
            conference_recording_status_callback=conference_recording_status_callback,
            conference_recording_status_callback_method=conference_recording_status_callback_method,
            conference_status_callback=conference_status_callback,
            conference_status_callback_event=conference_status_callback_event,
            conference_status_callback_method=conference_status_callback_method,
            conference_trim=conference_trim,
            dequeue_from=dequeue_from,
            dequeue_post_work_activity_sid=dequeue_post_work_activity_sid,
            dequeue_record=dequeue_record,
            dequeue_status_callback_event=dequeue_status_callback_event,
            dequeue_status_callback_url=dequeue_status_callback_url,
            dequeue_timeout=dequeue_timeout,
            dequeue_to=dequeue_to,
            early_media=early_media,
            end_conference_on_customer_exit=end_conference_on_customer_exit,
            end_conference_on_exit=end_conference_on_exit,
            var_from=var_from,
            instruction=instruction,
            max_participants=max_participants,
            muted=muted,
            post_work_activity_sid=post_work_activity_sid,
            record=record,
            recording_channels=recording_channels,
            recording_status_callback=recording_status_callback,
            recording_status_callback_method=recording_status_callback_method,
            redirect_accept=redirect_accept,
            redirect_call_sid=redirect_call_sid,
            redirect_url=redirect_url,
            region=region,
            reservation_status=reservation_status,
            sip_auth_password=sip_auth_password,
            sip_auth_username=sip_auth_username,
            start_conference_on_enter=start_conference_on_enter,
            status_callback=status_callback,
            status_callback_event=status_callback_event,
            status_callback_method=status_callback_method,
            timeout=timeout,
            to=to,
            wait_method=wait_method,
            wait_url=wait_url,
            worker_activity_sid=worker_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkerWorkerReservation",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_worker_reservation_serialize(
        self,
        workspace_sid,
        worker_sid,
        sid,
        if_match,
        beep,
        beep_on_customer_entrance,
        call_accept,
        call_from,
        call_record,
        call_status_callback_url,
        call_timeout,
        call_to,
        call_url,
        conference_record,
        conference_recording_status_callback,
        conference_recording_status_callback_method,
        conference_status_callback,
        conference_status_callback_event,
        conference_status_callback_method,
        conference_trim,
        dequeue_from,
        dequeue_post_work_activity_sid,
        dequeue_record,
        dequeue_status_callback_event,
        dequeue_status_callback_url,
        dequeue_timeout,
        dequeue_to,
        early_media,
        end_conference_on_customer_exit,
        end_conference_on_exit,
        var_from,
        instruction,
        max_participants,
        muted,
        post_work_activity_sid,
        record,
        recording_channels,
        recording_status_callback,
        recording_status_callback_method,
        redirect_accept,
        redirect_call_sid,
        redirect_url,
        region,
        reservation_status,
        sip_auth_password,
        sip_auth_username,
        start_conference_on_enter,
        status_callback,
        status_callback_event,
        status_callback_method,
        timeout,
        to,
        wait_method,
        wait_url,
        worker_activity_sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
            'ConferenceStatusCallbackEvent': 'csv',
            'DequeueStatusCallbackEvent': 'csv',
            'StatusCallbackEvent': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if worker_sid is not None:
            _path_params['WorkerSid'] = worker_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params['If-Match'] = if_match
        # process the form parameters
        if beep is not None:
            _form_params.append(('Beep', beep))
        if beep_on_customer_entrance is not None:
            _form_params.append(('BeepOnCustomerEntrance', beep_on_customer_entrance))
        if call_accept is not None:
            _form_params.append(('CallAccept', call_accept))
        if call_from is not None:
            _form_params.append(('CallFrom', call_from))
        if call_record is not None:
            _form_params.append(('CallRecord', call_record))
        if call_status_callback_url is not None:
            _form_params.append(('CallStatusCallbackUrl', call_status_callback_url))
        if call_timeout is not None:
            _form_params.append(('CallTimeout', call_timeout))
        if call_to is not None:
            _form_params.append(('CallTo', call_to))
        if call_url is not None:
            _form_params.append(('CallUrl', call_url))
        if conference_record is not None:
            _form_params.append(('ConferenceRecord', conference_record))
        if conference_recording_status_callback is not None:
            _form_params.append(('ConferenceRecordingStatusCallback', conference_recording_status_callback))
        if conference_recording_status_callback_method is not None:
            _form_params.append(('ConferenceRecordingStatusCallbackMethod', conference_recording_status_callback_method))
        if conference_status_callback is not None:
            _form_params.append(('ConferenceStatusCallback', conference_status_callback))
        if conference_status_callback_event is not None:
            _form_params.append(('ConferenceStatusCallbackEvent', conference_status_callback_event))
        if conference_status_callback_method is not None:
            _form_params.append(('ConferenceStatusCallbackMethod', conference_status_callback_method))
        if conference_trim is not None:
            _form_params.append(('ConferenceTrim', conference_trim))
        if dequeue_from is not None:
            _form_params.append(('DequeueFrom', dequeue_from))
        if dequeue_post_work_activity_sid is not None:
            _form_params.append(('DequeuePostWorkActivitySid', dequeue_post_work_activity_sid))
        if dequeue_record is not None:
            _form_params.append(('DequeueRecord', dequeue_record))
        if dequeue_status_callback_event is not None:
            _form_params.append(('DequeueStatusCallbackEvent', dequeue_status_callback_event))
        if dequeue_status_callback_url is not None:
            _form_params.append(('DequeueStatusCallbackUrl', dequeue_status_callback_url))
        if dequeue_timeout is not None:
            _form_params.append(('DequeueTimeout', dequeue_timeout))
        if dequeue_to is not None:
            _form_params.append(('DequeueTo', dequeue_to))
        if early_media is not None:
            _form_params.append(('EarlyMedia', early_media))
        if end_conference_on_customer_exit is not None:
            _form_params.append(('EndConferenceOnCustomerExit', end_conference_on_customer_exit))
        if end_conference_on_exit is not None:
            _form_params.append(('EndConferenceOnExit', end_conference_on_exit))
        if var_from is not None:
            _form_params.append(('From', var_from))
        if instruction is not None:
            _form_params.append(('Instruction', instruction))
        if max_participants is not None:
            _form_params.append(('MaxParticipants', max_participants))
        if muted is not None:
            _form_params.append(('Muted', muted))
        if post_work_activity_sid is not None:
            _form_params.append(('PostWorkActivitySid', post_work_activity_sid))
        if record is not None:
            _form_params.append(('Record', record))
        if recording_channels is not None:
            _form_params.append(('RecordingChannels', recording_channels))
        if recording_status_callback is not None:
            _form_params.append(('RecordingStatusCallback', recording_status_callback))
        if recording_status_callback_method is not None:
            _form_params.append(('RecordingStatusCallbackMethod', recording_status_callback_method))
        if redirect_accept is not None:
            _form_params.append(('RedirectAccept', redirect_accept))
        if redirect_call_sid is not None:
            _form_params.append(('RedirectCallSid', redirect_call_sid))
        if redirect_url is not None:
            _form_params.append(('RedirectUrl', redirect_url))
        if region is not None:
            _form_params.append(('Region', region))
        if reservation_status is not None:
            _form_params.append(('ReservationStatus', reservation_status))
        if sip_auth_password is not None:
            _form_params.append(('SipAuthPassword', sip_auth_password))
        if sip_auth_username is not None:
            _form_params.append(('SipAuthUsername', sip_auth_username))
        if start_conference_on_enter is not None:
            _form_params.append(('StartConferenceOnEnter', start_conference_on_enter))
        if status_callback is not None:
            _form_params.append(('StatusCallback', status_callback))
        if status_callback_event is not None:
            _form_params.append(('StatusCallbackEvent', status_callback_event))
        if status_callback_method is not None:
            _form_params.append(('StatusCallbackMethod', status_callback_method))
        if timeout is not None:
            _form_params.append(('Timeout', timeout))
        if to is not None:
            _form_params.append(('To', to))
        if wait_method is not None:
            _form_params.append(('WaitMethod', wait_method))
        if wait_url is not None:
            _form_params.append(('WaitUrl', wait_url))
        if worker_activity_sid is not None:
            _form_params.append(('WorkerActivitySid', worker_activity_sid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_workflow(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to update.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        configuration: Annotated[Optional[StrictStr], Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")] = None,
        re_evaluate_tasks: Annotated[Optional[StrictStr], Field(description="Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1WorkspaceWorkflow:
        """update_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to update. (required)
        :type sid: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
        :type configuration: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
        :type friendly_name: str
        :param re_evaluate_tasks: Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.
        :type re_evaluate_tasks: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_callback_url=assignment_callback_url,
            configuration=configuration,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            friendly_name=friendly_name,
            re_evaluate_tasks=re_evaluate_tasks,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_workflow_with_http_info(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to update.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        configuration: Annotated[Optional[StrictStr], Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")] = None,
        re_evaluate_tasks: Annotated[Optional[StrictStr], Field(description="Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1WorkspaceWorkflow]:
        """update_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to update. (required)
        :type sid: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
        :type configuration: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
        :type friendly_name: str
        :param re_evaluate_tasks: Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.
        :type re_evaluate_tasks: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_callback_url=assignment_callback_url,
            configuration=configuration,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            friendly_name=friendly_name,
            re_evaluate_tasks=re_evaluate_tasks,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_workflow_without_preload_content(
        self,
        workspace_sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace with the Workflow to update.")],
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workflow resource to update.")],
        assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.")] = None,
        configuration: Annotated[Optional[StrictStr], Field(description="A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.")] = None,
        fallback_assignment_callback_url: Annotated[Optional[StrictStr], Field(description="The URL that we should call when a call to the `assignment_callback_url` fails.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.")] = None,
        re_evaluate_tasks: Annotated[Optional[StrictStr], Field(description="Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.")] = None,
        task_reservation_timeout: Annotated[Optional[StrictInt], Field(description="How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_workflow

        

        :param workspace_sid: The SID of the Workspace with the Workflow to update. (required)
        :type workspace_sid: str
        :param sid: The SID of the Workflow resource to update. (required)
        :type sid: str
        :param assignment_callback_url: The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
        :type assignment_callback_url: str
        :param configuration: A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
        :type configuration: str
        :param fallback_assignment_callback_url: The URL that we should call when a call to the `assignment_callback_url` fails.
        :type fallback_assignment_callback_url: str
        :param friendly_name: A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
        :type friendly_name: str
        :param re_evaluate_tasks: Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.
        :type re_evaluate_tasks: str
        :param task_reservation_timeout: How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
        :type task_reservation_timeout: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workflow_serialize(
            workspace_sid=workspace_sid,
            sid=sid,
            assignment_callback_url=assignment_callback_url,
            configuration=configuration,
            fallback_assignment_callback_url=fallback_assignment_callback_url,
            friendly_name=friendly_name,
            re_evaluate_tasks=re_evaluate_tasks,
            task_reservation_timeout=task_reservation_timeout,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1WorkspaceWorkflow",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_workflow_serialize(
        self,
        workspace_sid,
        sid,
        assignment_callback_url,
        configuration,
        fallback_assignment_callback_url,
        friendly_name,
        re_evaluate_tasks,
        task_reservation_timeout,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if workspace_sid is not None:
            _path_params['WorkspaceSid'] = workspace_sid
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if assignment_callback_url is not None:
            _form_params.append(('AssignmentCallbackUrl', assignment_callback_url))
        if configuration is not None:
            _form_params.append(('Configuration', configuration))
        if fallback_assignment_callback_url is not None:
            _form_params.append(('FallbackAssignmentCallbackUrl', fallback_assignment_callback_url))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if re_evaluate_tasks is not None:
            _form_params.append(('ReEvaluateTasks', re_evaluate_tasks))
        if task_reservation_timeout is not None:
            _form_params.append(('TaskReservationTimeout', task_reservation_timeout))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_workspace(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to update.")],
        default_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be used when new Workers are created in the Workspace.")] = None,
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        timeout_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> TaskrouterV1Workspace:
        """update_workspace

        

        :param sid: The SID of the Workspace resource to update. (required)
        :type sid: str
        :param default_activity_sid: The SID of the Activity that will be used when new Workers are created in the Workspace.
        :type default_activity_sid: str
        :param event_callback_url: The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param friendly_name: A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.
        :type friendly_name: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param timeout_activity_sid: The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
        :type timeout_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workspace_serialize(
            sid=sid,
            default_activity_sid=default_activity_sid,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            friendly_name=friendly_name,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            timeout_activity_sid=timeout_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_workspace_with_http_info(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to update.")],
        default_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be used when new Workers are created in the Workspace.")] = None,
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        timeout_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> ApiResponse[TaskrouterV1Workspace]:
        """update_workspace

        

        :param sid: The SID of the Workspace resource to update. (required)
        :type sid: str
        :param default_activity_sid: The SID of the Activity that will be used when new Workers are created in the Workspace.
        :type default_activity_sid: str
        :param event_callback_url: The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param friendly_name: A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.
        :type friendly_name: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param timeout_activity_sid: The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
        :type timeout_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workspace_serialize(
            sid=sid,
            default_activity_sid=default_activity_sid,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            friendly_name=friendly_name,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            timeout_activity_sid=timeout_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_workspace_without_preload_content(
        self,
        sid: Annotated[str, Field(min_length=34, strict=True, max_length=34, description="The SID of the Workspace resource to update.")],
        default_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be used when new Workers are created in the Workspace.")] = None,
        event_callback_url: Annotated[Optional[StrictStr], Field(description="The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).")] = None,
        events_filter: Annotated[Optional[StrictStr], Field(description="The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.")] = None,
        friendly_name: Annotated[Optional[StrictStr], Field(description="A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.")] = None,
        multi_task_enabled: Annotated[Optional[StrictBool], Field(description="Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).")] = None,
        prioritize_queue_order: Optional[StrictStr] = None,
        timeout_activity_sid: Annotated[Optional[Annotated[str, Field(min_length=34, strict=True, max_length=34)]], Field(description="The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=1)] = 0,
    ) -> RESTResponseType:
        """update_workspace

        

        :param sid: The SID of the Workspace resource to update. (required)
        :type sid: str
        :param default_activity_sid: The SID of the Activity that will be used when new Workers are created in the Workspace.
        :type default_activity_sid: str
        :param event_callback_url: The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information. This parameter supports Twilio's [Webhooks (HTTP callbacks) Connection Overrides](https://www.twilio.com/docs/usage/webhooks/webhooks-connection-overrides).
        :type event_callback_url: str
        :param events_filter: The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
        :type events_filter: str
        :param friendly_name: A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.
        :type friendly_name: str
        :param multi_task_enabled: Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
        :type multi_task_enabled: bool
        :param prioritize_queue_order:
        :type prioritize_queue_order: WorkspaceEnumQueueOrder
        :param timeout_activity_sid: The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
        :type timeout_activity_sid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_workspace_serialize(
            sid=sid,
            default_activity_sid=default_activity_sid,
            event_callback_url=event_callback_url,
            events_filter=events_filter,
            friendly_name=friendly_name,
            multi_task_enabled=multi_task_enabled,
            prioritize_queue_order=prioritize_queue_order,
            timeout_activity_sid=timeout_activity_sid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskrouterV1Workspace",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_workspace_serialize(
        self,
        sid,
        default_activity_sid,
        event_callback_url,
        events_filter,
        friendly_name,
        multi_task_enabled,
        prioritize_queue_order,
        timeout_activity_sid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _hosts = [
            'https://taskrouter.twilio.com'
        ]
        _host = _hosts[_host_index]

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if sid is not None:
            _path_params['Sid'] = sid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if default_activity_sid is not None:
            _form_params.append(('DefaultActivitySid', default_activity_sid))
        if event_callback_url is not None:
            _form_params.append(('EventCallbackUrl', event_callback_url))
        if events_filter is not None:
            _form_params.append(('EventsFilter', events_filter))
        if friendly_name is not None:
            _form_params.append(('FriendlyName', friendly_name))
        if multi_task_enabled is not None:
            _form_params.append(('MultiTaskEnabled', multi_task_enabled))
        if prioritize_queue_order is not None:
            _form_params.append(('PrioritizeQueueOrder', prioritize_queue_order))
        if timeout_activity_sid is not None:
            _form_params.append(('TimeoutActivitySid', timeout_activity_sid))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'accountSid_authToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/Workspaces/{Sid}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


