# coding: utf-8

"""
    AWS Elemental MediaConvert

    AWS Elemental MediaConvert

    The version of the OpenAPI document: 2017-08-29
    Contact: mike.ralphson@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.cmaf_client_cache import CmafClientCache
from openapi_client.models.cmaf_codec_specification import CmafCodecSpecification
from openapi_client.models.cmaf_group_settings_destination_settings import CmafGroupSettingsDestinationSettings
from openapi_client.models.cmaf_group_settings_encryption import CmafGroupSettingsEncryption
from openapi_client.models.cmaf_group_settings_image_based_trick_play_settings import CmafGroupSettingsImageBasedTrickPlaySettings
from openapi_client.models.cmaf_image_based_trick_play import CmafImageBasedTrickPlay
from openapi_client.models.cmaf_manifest_compression import CmafManifestCompression
from openapi_client.models.cmaf_manifest_duration_format import CmafManifestDurationFormat
from openapi_client.models.cmaf_mpd_manifest_bandwidth_type import CmafMpdManifestBandwidthType
from openapi_client.models.cmaf_mpd_profile import CmafMpdProfile
from openapi_client.models.cmaf_pts_offset_handling_for_b_frames import CmafPtsOffsetHandlingForBFrames
from openapi_client.models.cmaf_segment_control import CmafSegmentControl
from openapi_client.models.cmaf_segment_length_control import CmafSegmentLengthControl
from openapi_client.models.cmaf_stream_inf_resolution import CmafStreamInfResolution
from openapi_client.models.cmaf_target_duration_compatibility_mode import CmafTargetDurationCompatibilityMode
from openapi_client.models.cmaf_video_composition_offsets import CmafVideoCompositionOffsets
from openapi_client.models.cmaf_write_dash_manifest import CmafWriteDASHManifest
from openapi_client.models.cmaf_write_hls_manifest import CmafWriteHLSManifest
from openapi_client.models.cmaf_write_segment_timeline_in_representation import CmafWriteSegmentTimelineInRepresentation
from openapi_client.models.dash_manifest_style import DashManifestStyle
from openapi_client.models.float import float
from openapi_client.models.int import int
from openapi_client.models.list import List
from openapi_client.models.str import str
from typing import Optional, Set
from typing_extensions import Self

class OutputGroupSettingsCmafGroupSettings(BaseModel):
    """
    OutputGroupSettingsCmafGroupSettings
    """ # noqa: E501
    additional_manifests: Optional[Any] = Field(default=None, alias="AdditionalManifests")
    base_url: Optional[Any] = Field(default=None, alias="BaseUrl")
    client_cache: Optional[Any] = Field(default=None, alias="ClientCache")
    codec_specification: Optional[Any] = Field(default=None, alias="CodecSpecification")
    dash_manifest_style: Optional[Any] = Field(default=None, alias="DashManifestStyle")
    destination: Optional[Any] = Field(default=None, alias="Destination")
    destination_settings: Optional[CmafGroupSettingsDestinationSettings] = Field(default=None, alias="DestinationSettings")
    encryption: Optional[CmafGroupSettingsEncryption] = Field(default=None, alias="Encryption")
    fragment_length: Optional[Any] = Field(default=None, alias="FragmentLength")
    image_based_trick_play: Optional[Any] = Field(default=None, alias="ImageBasedTrickPlay")
    image_based_trick_play_settings: Optional[CmafGroupSettingsImageBasedTrickPlaySettings] = Field(default=None, alias="ImageBasedTrickPlaySettings")
    manifest_compression: Optional[Any] = Field(default=None, alias="ManifestCompression")
    manifest_duration_format: Optional[Any] = Field(default=None, alias="ManifestDurationFormat")
    min_buffer_time: Optional[Any] = Field(default=None, alias="MinBufferTime")
    min_final_segment_length: Optional[Any] = Field(default=None, alias="MinFinalSegmentLength")
    mpd_manifest_bandwidth_type: Optional[Any] = Field(default=None, alias="MpdManifestBandwidthType")
    mpd_profile: Optional[Any] = Field(default=None, alias="MpdProfile")
    pts_offset_handling_for_b_frames: Optional[Any] = Field(default=None, alias="PtsOffsetHandlingForBFrames")
    segment_control: Optional[Any] = Field(default=None, alias="SegmentControl")
    segment_length: Optional[Any] = Field(default=None, alias="SegmentLength")
    segment_length_control: Optional[Any] = Field(default=None, alias="SegmentLengthControl")
    stream_inf_resolution: Optional[Any] = Field(default=None, alias="StreamInfResolution")
    target_duration_compatibility_mode: Optional[Any] = Field(default=None, alias="TargetDurationCompatibilityMode")
    video_composition_offsets: Optional[Any] = Field(default=None, alias="VideoCompositionOffsets")
    write_dash_manifest: Optional[Any] = Field(default=None, alias="WriteDashManifest")
    write_hls_manifest: Optional[Any] = Field(default=None, alias="WriteHlsManifest")
    write_segment_timeline_in_representation: Optional[Any] = Field(default=None, alias="WriteSegmentTimelineInRepresentation")
    __properties: ClassVar[List[str]] = ["AdditionalManifests", "BaseUrl", "ClientCache", "CodecSpecification", "DashManifestStyle", "Destination", "DestinationSettings", "Encryption", "FragmentLength", "ImageBasedTrickPlay", "ImageBasedTrickPlaySettings", "ManifestCompression", "ManifestDurationFormat", "MinBufferTime", "MinFinalSegmentLength", "MpdManifestBandwidthType", "MpdProfile", "PtsOffsetHandlingForBFrames", "SegmentControl", "SegmentLength", "SegmentLengthControl", "StreamInfResolution", "TargetDurationCompatibilityMode", "VideoCompositionOffsets", "WriteDashManifest", "WriteHlsManifest", "WriteSegmentTimelineInRepresentation"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OutputGroupSettingsCmafGroupSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of client_cache
        if self.client_cache:
            _dict['ClientCache'] = self.client_cache.to_dict()
        # override the default output from pydantic by calling `to_dict()` of codec_specification
        if self.codec_specification:
            _dict['CodecSpecification'] = self.codec_specification.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dash_manifest_style
        if self.dash_manifest_style:
            _dict['DashManifestStyle'] = self.dash_manifest_style.to_dict()
        # override the default output from pydantic by calling `to_dict()` of destination_settings
        if self.destination_settings:
            _dict['DestinationSettings'] = self.destination_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of encryption
        if self.encryption:
            _dict['Encryption'] = self.encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_based_trick_play
        if self.image_based_trick_play:
            _dict['ImageBasedTrickPlay'] = self.image_based_trick_play.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_based_trick_play_settings
        if self.image_based_trick_play_settings:
            _dict['ImageBasedTrickPlaySettings'] = self.image_based_trick_play_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manifest_compression
        if self.manifest_compression:
            _dict['ManifestCompression'] = self.manifest_compression.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manifest_duration_format
        if self.manifest_duration_format:
            _dict['ManifestDurationFormat'] = self.manifest_duration_format.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mpd_manifest_bandwidth_type
        if self.mpd_manifest_bandwidth_type:
            _dict['MpdManifestBandwidthType'] = self.mpd_manifest_bandwidth_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mpd_profile
        if self.mpd_profile:
            _dict['MpdProfile'] = self.mpd_profile.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pts_offset_handling_for_b_frames
        if self.pts_offset_handling_for_b_frames:
            _dict['PtsOffsetHandlingForBFrames'] = self.pts_offset_handling_for_b_frames.to_dict()
        # override the default output from pydantic by calling `to_dict()` of segment_control
        if self.segment_control:
            _dict['SegmentControl'] = self.segment_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of segment_length_control
        if self.segment_length_control:
            _dict['SegmentLengthControl'] = self.segment_length_control.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stream_inf_resolution
        if self.stream_inf_resolution:
            _dict['StreamInfResolution'] = self.stream_inf_resolution.to_dict()
        # override the default output from pydantic by calling `to_dict()` of target_duration_compatibility_mode
        if self.target_duration_compatibility_mode:
            _dict['TargetDurationCompatibilityMode'] = self.target_duration_compatibility_mode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of video_composition_offsets
        if self.video_composition_offsets:
            _dict['VideoCompositionOffsets'] = self.video_composition_offsets.to_dict()
        # override the default output from pydantic by calling `to_dict()` of write_dash_manifest
        if self.write_dash_manifest:
            _dict['WriteDashManifest'] = self.write_dash_manifest.to_dict()
        # override the default output from pydantic by calling `to_dict()` of write_hls_manifest
        if self.write_hls_manifest:
            _dict['WriteHlsManifest'] = self.write_hls_manifest.to_dict()
        # override the default output from pydantic by calling `to_dict()` of write_segment_timeline_in_representation
        if self.write_segment_timeline_in_representation:
            _dict['WriteSegmentTimelineInRepresentation'] = self.write_segment_timeline_in_representation.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OutputGroupSettingsCmafGroupSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "AdditionalManifests": obj.get("AdditionalManifests"),
            "BaseUrl": obj.get("BaseUrl"),
            "ClientCache": CmafClientCache.from_dict(obj["ClientCache"]) if obj.get("ClientCache") is not None else None,
            "CodecSpecification": CmafCodecSpecification.from_dict(obj["CodecSpecification"]) if obj.get("CodecSpecification") is not None else None,
            "DashManifestStyle": DashManifestStyle.from_dict(obj["DashManifestStyle"]) if obj.get("DashManifestStyle") is not None else None,
            "Destination": obj.get("Destination"),
            "DestinationSettings": CmafGroupSettingsDestinationSettings.from_dict(obj["DestinationSettings"]) if obj.get("DestinationSettings") is not None else None,
            "Encryption": CmafGroupSettingsEncryption.from_dict(obj["Encryption"]) if obj.get("Encryption") is not None else None,
            "FragmentLength": obj.get("FragmentLength"),
            "ImageBasedTrickPlay": CmafImageBasedTrickPlay.from_dict(obj["ImageBasedTrickPlay"]) if obj.get("ImageBasedTrickPlay") is not None else None,
            "ImageBasedTrickPlaySettings": CmafGroupSettingsImageBasedTrickPlaySettings.from_dict(obj["ImageBasedTrickPlaySettings"]) if obj.get("ImageBasedTrickPlaySettings") is not None else None,
            "ManifestCompression": CmafManifestCompression.from_dict(obj["ManifestCompression"]) if obj.get("ManifestCompression") is not None else None,
            "ManifestDurationFormat": CmafManifestDurationFormat.from_dict(obj["ManifestDurationFormat"]) if obj.get("ManifestDurationFormat") is not None else None,
            "MinBufferTime": obj.get("MinBufferTime"),
            "MinFinalSegmentLength": obj.get("MinFinalSegmentLength"),
            "MpdManifestBandwidthType": CmafMpdManifestBandwidthType.from_dict(obj["MpdManifestBandwidthType"]) if obj.get("MpdManifestBandwidthType") is not None else None,
            "MpdProfile": CmafMpdProfile.from_dict(obj["MpdProfile"]) if obj.get("MpdProfile") is not None else None,
            "PtsOffsetHandlingForBFrames": CmafPtsOffsetHandlingForBFrames.from_dict(obj["PtsOffsetHandlingForBFrames"]) if obj.get("PtsOffsetHandlingForBFrames") is not None else None,
            "SegmentControl": CmafSegmentControl.from_dict(obj["SegmentControl"]) if obj.get("SegmentControl") is not None else None,
            "SegmentLength": obj.get("SegmentLength"),
            "SegmentLengthControl": CmafSegmentLengthControl.from_dict(obj["SegmentLengthControl"]) if obj.get("SegmentLengthControl") is not None else None,
            "StreamInfResolution": CmafStreamInfResolution.from_dict(obj["StreamInfResolution"]) if obj.get("StreamInfResolution") is not None else None,
            "TargetDurationCompatibilityMode": CmafTargetDurationCompatibilityMode.from_dict(obj["TargetDurationCompatibilityMode"]) if obj.get("TargetDurationCompatibilityMode") is not None else None,
            "VideoCompositionOffsets": CmafVideoCompositionOffsets.from_dict(obj["VideoCompositionOffsets"]) if obj.get("VideoCompositionOffsets") is not None else None,
            "WriteDashManifest": CmafWriteDASHManifest.from_dict(obj["WriteDashManifest"]) if obj.get("WriteDashManifest") is not None else None,
            "WriteHlsManifest": CmafWriteHLSManifest.from_dict(obj["WriteHlsManifest"]) if obj.get("WriteHlsManifest") is not None else None,
            "WriteSegmentTimelineInRepresentation": CmafWriteSegmentTimelineInRepresentation.from_dict(obj["WriteSegmentTimelineInRepresentation"]) if obj.get("WriteSegmentTimelineInRepresentation") is not None else None
        })
        return _obj


