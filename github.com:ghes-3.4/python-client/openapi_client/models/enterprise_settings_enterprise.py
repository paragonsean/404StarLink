# coding: utf-8

"""
    GitHub v3 REST API

    GitHub's v3 REST API.

    The version of the OpenAPI document: 1.1.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.branch_protection_allow_deletions import BranchProtectionAllowDeletions
from openapi_client.models.enterprise_settings_enterprise_avatar import EnterpriseSettingsEnterpriseAvatar
from openapi_client.models.enterprise_settings_enterprise_cas import EnterpriseSettingsEnterpriseCas
from openapi_client.models.enterprise_settings_enterprise_collectd import EnterpriseSettingsEnterpriseCollectd
from openapi_client.models.enterprise_settings_enterprise_customer import EnterpriseSettingsEnterpriseCustomer
from openapi_client.models.enterprise_settings_enterprise_github_oauth import EnterpriseSettingsEnterpriseGithubOauth
from openapi_client.models.enterprise_settings_enterprise_github_ssl import EnterpriseSettingsEnterpriseGithubSsl
from openapi_client.models.enterprise_settings_enterprise_ldap import EnterpriseSettingsEnterpriseLdap
from openapi_client.models.enterprise_settings_enterprise_license import EnterpriseSettingsEnterpriseLicense
from openapi_client.models.enterprise_settings_enterprise_mapping import EnterpriseSettingsEnterpriseMapping
from openapi_client.models.enterprise_settings_enterprise_ntp import EnterpriseSettingsEnterpriseNtp
from openapi_client.models.enterprise_settings_enterprise_saml import EnterpriseSettingsEnterpriseSaml
from openapi_client.models.enterprise_settings_enterprise_smtp import EnterpriseSettingsEnterpriseSmtp
from openapi_client.models.enterprise_settings_enterprise_snmp import EnterpriseSettingsEnterpriseSnmp
from openapi_client.models.enterprise_settings_enterprise_syslog import EnterpriseSettingsEnterpriseSyslog
from typing import Optional, Set
from typing_extensions import Self

class EnterpriseSettingsEnterprise(BaseModel):
    """
    EnterpriseSettingsEnterprise
    """ # noqa: E501
    admin_password: Optional[StrictStr] = None
    assets: Optional[StrictStr] = None
    auth_mode: Optional[StrictStr] = None
    avatar: Optional[EnterpriseSettingsEnterpriseAvatar] = None
    cas: Optional[EnterpriseSettingsEnterpriseCas] = None
    collectd: Optional[EnterpriseSettingsEnterpriseCollectd] = None
    configuration_id: Optional[StrictInt] = None
    configuration_run_count: Optional[StrictInt] = None
    customer: Optional[EnterpriseSettingsEnterpriseCustomer] = None
    expire_sessions: Optional[StrictBool] = None
    github_hostname: Optional[StrictStr] = None
    github_oauth: Optional[EnterpriseSettingsEnterpriseGithubOauth] = None
    github_ssl: Optional[EnterpriseSettingsEnterpriseGithubSsl] = None
    http_proxy: Optional[StrictStr] = None
    identicons_host: Optional[StrictStr] = None
    ldap: Optional[EnterpriseSettingsEnterpriseLdap] = None
    license: Optional[EnterpriseSettingsEnterpriseLicense] = None
    load_balancer: Optional[StrictStr] = None
    mapping: Optional[EnterpriseSettingsEnterpriseMapping] = None
    ntp: Optional[EnterpriseSettingsEnterpriseNtp] = None
    pages: Optional[BranchProtectionAllowDeletions] = None
    private_mode: Optional[StrictBool] = None
    public_pages: Optional[StrictBool] = None
    saml: Optional[EnterpriseSettingsEnterpriseSaml] = None
    signup_enabled: Optional[StrictBool] = None
    smtp: Optional[EnterpriseSettingsEnterpriseSmtp] = None
    snmp: Optional[EnterpriseSettingsEnterpriseSnmp] = None
    subdomain_isolation: Optional[StrictBool] = None
    syslog: Optional[EnterpriseSettingsEnterpriseSyslog] = None
    timezone: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["admin_password", "assets", "auth_mode", "avatar", "cas", "collectd", "configuration_id", "configuration_run_count", "customer", "expire_sessions", "github_hostname", "github_oauth", "github_ssl", "http_proxy", "identicons_host", "ldap", "license", "load_balancer", "mapping", "ntp", "pages", "private_mode", "public_pages", "saml", "signup_enabled", "smtp", "snmp", "subdomain_isolation", "syslog", "timezone"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EnterpriseSettingsEnterprise from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of avatar
        if self.avatar:
            _dict['avatar'] = self.avatar.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cas
        if self.cas:
            _dict['cas'] = self.cas.to_dict()
        # override the default output from pydantic by calling `to_dict()` of collectd
        if self.collectd:
            _dict['collectd'] = self.collectd.to_dict()
        # override the default output from pydantic by calling `to_dict()` of customer
        if self.customer:
            _dict['customer'] = self.customer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of github_oauth
        if self.github_oauth:
            _dict['github_oauth'] = self.github_oauth.to_dict()
        # override the default output from pydantic by calling `to_dict()` of github_ssl
        if self.github_ssl:
            _dict['github_ssl'] = self.github_ssl.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ldap
        if self.ldap:
            _dict['ldap'] = self.ldap.to_dict()
        # override the default output from pydantic by calling `to_dict()` of license
        if self.license:
            _dict['license'] = self.license.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mapping
        if self.mapping:
            _dict['mapping'] = self.mapping.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ntp
        if self.ntp:
            _dict['ntp'] = self.ntp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pages
        if self.pages:
            _dict['pages'] = self.pages.to_dict()
        # override the default output from pydantic by calling `to_dict()` of saml
        if self.saml:
            _dict['saml'] = self.saml.to_dict()
        # override the default output from pydantic by calling `to_dict()` of smtp
        if self.smtp:
            _dict['smtp'] = self.smtp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of snmp
        if self.snmp:
            _dict['snmp'] = self.snmp.to_dict()
        # override the default output from pydantic by calling `to_dict()` of syslog
        if self.syslog:
            _dict['syslog'] = self.syslog.to_dict()
        # set to None if admin_password (nullable) is None
        # and model_fields_set contains the field
        if self.admin_password is None and "admin_password" in self.model_fields_set:
            _dict['admin_password'] = None

        # set to None if assets (nullable) is None
        # and model_fields_set contains the field
        if self.assets is None and "assets" in self.model_fields_set:
            _dict['assets'] = None

        # set to None if http_proxy (nullable) is None
        # and model_fields_set contains the field
        if self.http_proxy is None and "http_proxy" in self.model_fields_set:
            _dict['http_proxy'] = None

        # set to None if load_balancer (nullable) is None
        # and model_fields_set contains the field
        if self.load_balancer is None and "load_balancer" in self.model_fields_set:
            _dict['load_balancer'] = None

        # set to None if timezone (nullable) is None
        # and model_fields_set contains the field
        if self.timezone is None and "timezone" in self.model_fields_set:
            _dict['timezone'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EnterpriseSettingsEnterprise from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "admin_password": obj.get("admin_password"),
            "assets": obj.get("assets"),
            "auth_mode": obj.get("auth_mode"),
            "avatar": EnterpriseSettingsEnterpriseAvatar.from_dict(obj["avatar"]) if obj.get("avatar") is not None else None,
            "cas": EnterpriseSettingsEnterpriseCas.from_dict(obj["cas"]) if obj.get("cas") is not None else None,
            "collectd": EnterpriseSettingsEnterpriseCollectd.from_dict(obj["collectd"]) if obj.get("collectd") is not None else None,
            "configuration_id": obj.get("configuration_id"),
            "configuration_run_count": obj.get("configuration_run_count"),
            "customer": EnterpriseSettingsEnterpriseCustomer.from_dict(obj["customer"]) if obj.get("customer") is not None else None,
            "expire_sessions": obj.get("expire_sessions"),
            "github_hostname": obj.get("github_hostname"),
            "github_oauth": EnterpriseSettingsEnterpriseGithubOauth.from_dict(obj["github_oauth"]) if obj.get("github_oauth") is not None else None,
            "github_ssl": EnterpriseSettingsEnterpriseGithubSsl.from_dict(obj["github_ssl"]) if obj.get("github_ssl") is not None else None,
            "http_proxy": obj.get("http_proxy"),
            "identicons_host": obj.get("identicons_host"),
            "ldap": EnterpriseSettingsEnterpriseLdap.from_dict(obj["ldap"]) if obj.get("ldap") is not None else None,
            "license": EnterpriseSettingsEnterpriseLicense.from_dict(obj["license"]) if obj.get("license") is not None else None,
            "load_balancer": obj.get("load_balancer"),
            "mapping": EnterpriseSettingsEnterpriseMapping.from_dict(obj["mapping"]) if obj.get("mapping") is not None else None,
            "ntp": EnterpriseSettingsEnterpriseNtp.from_dict(obj["ntp"]) if obj.get("ntp") is not None else None,
            "pages": BranchProtectionAllowDeletions.from_dict(obj["pages"]) if obj.get("pages") is not None else None,
            "private_mode": obj.get("private_mode"),
            "public_pages": obj.get("public_pages"),
            "saml": EnterpriseSettingsEnterpriseSaml.from_dict(obj["saml"]) if obj.get("saml") is not None else None,
            "signup_enabled": obj.get("signup_enabled"),
            "smtp": EnterpriseSettingsEnterpriseSmtp.from_dict(obj["smtp"]) if obj.get("smtp") is not None else None,
            "snmp": EnterpriseSettingsEnterpriseSnmp.from_dict(obj["snmp"]) if obj.get("snmp") is not None else None,
            "subdomain_isolation": obj.get("subdomain_isolation"),
            "syslog": EnterpriseSettingsEnterpriseSyslog.from_dict(obj["syslog"]) if obj.get("syslog") is not None else None,
            "timezone": obj.get("timezone")
        })
        return _obj


