# coding: utf-8

"""
    Master Data API - v2

    # ATTENTION: **This version isn't compliant with data entities of old version (e.g. CL and AD). It's possible to use this configuration only to new data entities.**      ## Welcome!    VTEX Master Data is an easy-to-use, secure, fast, scalable and extensible repository. On it you can create your own Entities, store data and consult directly from the storefront or use it to store info for some external integration.    There are internal VTEX modules that use VTEX Master Data as data repository. We have the VTEX Customer Service, VTEX Profile System and VTEX InStore, for example. It is also used by other internal services.    There are two ways to use Master Data:    1. Directly from the storefront  2. External integration    ### Directly from the storefront    If your scenario is to be used inside the storefront, be aware of the following observations:    1. Use the storefront host to query or store information to avoid **CORS**;  2. Configure which information should be public and which shouldn't, inside the JSON Schema of the Data Entity;  3. Do not create query loops (the storefront may be affected with Throttling and apis may be turned off as a security protection);  4. Never add via JS any type of authentication key (x-vtex-api-appkey or x-vtex-api-apptoken);    **It's important to avoid CORS using the relative path**    ### External Integration    If your scenario is to perform external integration, such as migrating client data from another service, be aware of the following observations:    1. Use the host ```{{accountName}}.vtexcommercestable.com.br```;  2. Use the authentication keys (x-vtex-api-appkey ou x-vtex-api-apptoken);    ### Most used attributes listed here    | Name | Description |  | -------- | -------- |  | accountName | Account name in VTEX License Manager |  | name | Data Entity name |  | schema | JSON Schema of a Data Entity |  | id | Identifier of a document |  | x-vtex-api-appKey | User key |  | x-vtex-api-appToken | User token |

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CreateUpdateAddressRequests(BaseModel):
    """
    CreateUpdateAddressRequests
    """ # noqa: E501
    address_name: Optional[StrictStr] = Field(default=None, description="Address name.", alias="addressName")
    address_type: Optional[StrictStr] = Field(default=None, description="Type of address. For example, `Residential` or `Pickup`, among others.", alias="addressType")
    city: Optional[StrictStr] = Field(default=None, description="City of the shipping address.")
    complement: Optional[StrictStr] = Field(default=None, description="Complement to the shipping address in case it applies.")
    country: Optional[StrictStr] = Field(default=None, description="Three letter ISO code of the country of the shipping address.")
    neighborhood: Optional[StrictStr] = Field(default=None, description="Neighborhood of the address.")
    number: Optional[StrictStr] = Field(default=None, description="Number of the building, house or apartment in the shipping address.")
    postal_code: Optional[StrictStr] = Field(default=None, description="Postal Code.", alias="postalCode")
    receiver_name: Optional[StrictStr] = Field(default=None, description="Name of the person who is going to receive the order.", alias="receiverName")
    reference: Optional[StrictStr] = Field(default=None, description="Complement that might help locate the shipping address more precisely in case of delivery.")
    state: Optional[StrictStr] = Field(default=None, description="State of the shipping address.")
    street: Optional[StrictStr] = Field(default=None, description="Street of the address.")
    user_id: Optional[StrictStr] = Field(default=None, description="ID of the customer to whom the address belongs.", alias="userId")
    __properties: ClassVar[List[str]] = ["addressName", "addressType", "city", "complement", "country", "neighborhood", "number", "postalCode", "receiverName", "reference", "state", "street", "userId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateUpdateAddressRequests from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if address_name (nullable) is None
        # and model_fields_set contains the field
        if self.address_name is None and "address_name" in self.model_fields_set:
            _dict['addressName'] = None

        # set to None if address_type (nullable) is None
        # and model_fields_set contains the field
        if self.address_type is None and "address_type" in self.model_fields_set:
            _dict['addressType'] = None

        # set to None if city (nullable) is None
        # and model_fields_set contains the field
        if self.city is None and "city" in self.model_fields_set:
            _dict['city'] = None

        # set to None if complement (nullable) is None
        # and model_fields_set contains the field
        if self.complement is None and "complement" in self.model_fields_set:
            _dict['complement'] = None

        # set to None if country (nullable) is None
        # and model_fields_set contains the field
        if self.country is None and "country" in self.model_fields_set:
            _dict['country'] = None

        # set to None if neighborhood (nullable) is None
        # and model_fields_set contains the field
        if self.neighborhood is None and "neighborhood" in self.model_fields_set:
            _dict['neighborhood'] = None

        # set to None if number (nullable) is None
        # and model_fields_set contains the field
        if self.number is None and "number" in self.model_fields_set:
            _dict['number'] = None

        # set to None if postal_code (nullable) is None
        # and model_fields_set contains the field
        if self.postal_code is None and "postal_code" in self.model_fields_set:
            _dict['postalCode'] = None

        # set to None if receiver_name (nullable) is None
        # and model_fields_set contains the field
        if self.receiver_name is None and "receiver_name" in self.model_fields_set:
            _dict['receiverName'] = None

        # set to None if reference (nullable) is None
        # and model_fields_set contains the field
        if self.reference is None and "reference" in self.model_fields_set:
            _dict['reference'] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict['state'] = None

        # set to None if street (nullable) is None
        # and model_fields_set contains the field
        if self.street is None and "street" in self.model_fields_set:
            _dict['street'] = None

        # set to None if user_id (nullable) is None
        # and model_fields_set contains the field
        if self.user_id is None and "user_id" in self.model_fields_set:
            _dict['userId'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateUpdateAddressRequests from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "addressName": obj.get("addressName"),
            "addressType": obj.get("addressType"),
            "city": obj.get("city"),
            "complement": obj.get("complement"),
            "country": obj.get("country"),
            "neighborhood": obj.get("neighborhood"),
            "number": obj.get("number"),
            "postalCode": obj.get("postalCode"),
            "receiverName": obj.get("receiverName"),
            "reference": obj.get("reference"),
            "state": obj.get("state"),
            "street": obj.get("street"),
            "userId": obj.get("userId")
        })
        return _obj


