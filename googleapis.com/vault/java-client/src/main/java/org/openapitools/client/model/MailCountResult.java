/*
 * Google Vault API
 * Retention and eDiscovery for Google Workspace. To work with Vault resources, the account must have the [required Vault privileges](https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege. For example, to download an export, an account needs the **Manage Exports** privilege and the matter shared with them. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountCount;
import org.openapitools.client.model.AccountCountError;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Gmail and classic Hangouts-specific count metrics.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:17:41.496021-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MailCountResult {
  public static final String SERIALIZED_NAME_ACCOUNT_COUNT_ERRORS = "accountCountErrors";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_COUNT_ERRORS)
  private List<AccountCountError> accountCountErrors = new ArrayList<>();

  public static final String SERIALIZED_NAME_ACCOUNT_COUNTS = "accountCounts";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_COUNTS)
  private List<AccountCount> accountCounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCHING_ACCOUNTS_COUNT = "matchingAccountsCount";
  @SerializedName(SERIALIZED_NAME_MATCHING_ACCOUNTS_COUNT)
  private String matchingAccountsCount;

  public static final String SERIALIZED_NAME_NON_QUERYABLE_ACCOUNTS = "nonQueryableAccounts";
  @SerializedName(SERIALIZED_NAME_NON_QUERYABLE_ACCOUNTS)
  private List<String> nonQueryableAccounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUERIED_ACCOUNTS_COUNT = "queriedAccountsCount";
  @SerializedName(SERIALIZED_NAME_QUERIED_ACCOUNTS_COUNT)
  private String queriedAccountsCount;

  public MailCountResult() {
  }

  public MailCountResult accountCountErrors(List<AccountCountError> accountCountErrors) {
    this.accountCountErrors = accountCountErrors;
    return this;
  }

  public MailCountResult addAccountCountErrorsItem(AccountCountError accountCountErrorsItem) {
    if (this.accountCountErrors == null) {
      this.accountCountErrors = new ArrayList<>();
    }
    this.accountCountErrors.add(accountCountErrorsItem);
    return this;
  }

  /**
   * Errors occurred when querying these accounts.
   * @return accountCountErrors
   */
  @javax.annotation.Nullable
  public List<AccountCountError> getAccountCountErrors() {
    return accountCountErrors;
  }

  public void setAccountCountErrors(List<AccountCountError> accountCountErrors) {
    this.accountCountErrors = accountCountErrors;
  }


  public MailCountResult accountCounts(List<AccountCount> accountCounts) {
    this.accountCounts = accountCounts;
    return this;
  }

  public MailCountResult addAccountCountsItem(AccountCount accountCountsItem) {
    if (this.accountCounts == null) {
      this.accountCounts = new ArrayList<>();
    }
    this.accountCounts.add(accountCountsItem);
    return this;
  }

  /**
   * Subtotal count per matching account that have more than zero messages.
   * @return accountCounts
   */
  @javax.annotation.Nullable
  public List<AccountCount> getAccountCounts() {
    return accountCounts;
  }

  public void setAccountCounts(List<AccountCount> accountCounts) {
    this.accountCounts = accountCounts;
  }


  public MailCountResult matchingAccountsCount(String matchingAccountsCount) {
    this.matchingAccountsCount = matchingAccountsCount;
    return this;
  }

  /**
   * Total number of accounts that can be queried and have more than zero messages.
   * @return matchingAccountsCount
   */
  @javax.annotation.Nullable
  public String getMatchingAccountsCount() {
    return matchingAccountsCount;
  }

  public void setMatchingAccountsCount(String matchingAccountsCount) {
    this.matchingAccountsCount = matchingAccountsCount;
  }


  public MailCountResult nonQueryableAccounts(List<String> nonQueryableAccounts) {
    this.nonQueryableAccounts = nonQueryableAccounts;
    return this;
  }

  public MailCountResult addNonQueryableAccountsItem(String nonQueryableAccountsItem) {
    if (this.nonQueryableAccounts == null) {
      this.nonQueryableAccounts = new ArrayList<>();
    }
    this.nonQueryableAccounts.add(nonQueryableAccountsItem);
    return this;
  }

  /**
   * When **DataScope** is **HELD_DATA** and when account emails are passed in explicitly, the list of accounts in the request that are not queried because they are not on hold in the matter. For other data scopes, this field is not set.
   * @return nonQueryableAccounts
   */
  @javax.annotation.Nullable
  public List<String> getNonQueryableAccounts() {
    return nonQueryableAccounts;
  }

  public void setNonQueryableAccounts(List<String> nonQueryableAccounts) {
    this.nonQueryableAccounts = nonQueryableAccounts;
  }


  public MailCountResult queriedAccountsCount(String queriedAccountsCount) {
    this.queriedAccountsCount = queriedAccountsCount;
    return this;
  }

  /**
   * Total number of accounts involved in this count operation.
   * @return queriedAccountsCount
   */
  @javax.annotation.Nullable
  public String getQueriedAccountsCount() {
    return queriedAccountsCount;
  }

  public void setQueriedAccountsCount(String queriedAccountsCount) {
    this.queriedAccountsCount = queriedAccountsCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MailCountResult mailCountResult = (MailCountResult) o;
    return Objects.equals(this.accountCountErrors, mailCountResult.accountCountErrors) &&
        Objects.equals(this.accountCounts, mailCountResult.accountCounts) &&
        Objects.equals(this.matchingAccountsCount, mailCountResult.matchingAccountsCount) &&
        Objects.equals(this.nonQueryableAccounts, mailCountResult.nonQueryableAccounts) &&
        Objects.equals(this.queriedAccountsCount, mailCountResult.queriedAccountsCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountCountErrors, accountCounts, matchingAccountsCount, nonQueryableAccounts, queriedAccountsCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MailCountResult {\n");
    sb.append("    accountCountErrors: ").append(toIndentedString(accountCountErrors)).append("\n");
    sb.append("    accountCounts: ").append(toIndentedString(accountCounts)).append("\n");
    sb.append("    matchingAccountsCount: ").append(toIndentedString(matchingAccountsCount)).append("\n");
    sb.append("    nonQueryableAccounts: ").append(toIndentedString(nonQueryableAccounts)).append("\n");
    sb.append("    queriedAccountsCount: ").append(toIndentedString(queriedAccountsCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountCountErrors");
    openapiFields.add("accountCounts");
    openapiFields.add("matchingAccountsCount");
    openapiFields.add("nonQueryableAccounts");
    openapiFields.add("queriedAccountsCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MailCountResult
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MailCountResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MailCountResult is not found in the empty JSON string", MailCountResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MailCountResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MailCountResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("accountCountErrors") != null && !jsonObj.get("accountCountErrors").isJsonNull()) {
        JsonArray jsonArrayaccountCountErrors = jsonObj.getAsJsonArray("accountCountErrors");
        if (jsonArrayaccountCountErrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accountCountErrors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accountCountErrors` to be an array in the JSON string but got `%s`", jsonObj.get("accountCountErrors").toString()));
          }

          // validate the optional field `accountCountErrors` (array)
          for (int i = 0; i < jsonArrayaccountCountErrors.size(); i++) {
            AccountCountError.validateJsonElement(jsonArrayaccountCountErrors.get(i));
          };
        }
      }
      if (jsonObj.get("accountCounts") != null && !jsonObj.get("accountCounts").isJsonNull()) {
        JsonArray jsonArrayaccountCounts = jsonObj.getAsJsonArray("accountCounts");
        if (jsonArrayaccountCounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accountCounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accountCounts` to be an array in the JSON string but got `%s`", jsonObj.get("accountCounts").toString()));
          }

          // validate the optional field `accountCounts` (array)
          for (int i = 0; i < jsonArrayaccountCounts.size(); i++) {
            AccountCount.validateJsonElement(jsonArrayaccountCounts.get(i));
          };
        }
      }
      if ((jsonObj.get("matchingAccountsCount") != null && !jsonObj.get("matchingAccountsCount").isJsonNull()) && !jsonObj.get("matchingAccountsCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchingAccountsCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchingAccountsCount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("nonQueryableAccounts") != null && !jsonObj.get("nonQueryableAccounts").isJsonNull() && !jsonObj.get("nonQueryableAccounts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `nonQueryableAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("nonQueryableAccounts").toString()));
      }
      if ((jsonObj.get("queriedAccountsCount") != null && !jsonObj.get("queriedAccountsCount").isJsonNull()) && !jsonObj.get("queriedAccountsCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queriedAccountsCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queriedAccountsCount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MailCountResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MailCountResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MailCountResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MailCountResult.class));

       return (TypeAdapter<T>) new TypeAdapter<MailCountResult>() {
           @Override
           public void write(JsonWriter out, MailCountResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MailCountResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MailCountResult given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MailCountResult
   * @throws IOException if the JSON string is invalid with respect to MailCountResult
   */
  public static MailCountResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MailCountResult.class);
  }

  /**
   * Convert an instance of MailCountResult to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

