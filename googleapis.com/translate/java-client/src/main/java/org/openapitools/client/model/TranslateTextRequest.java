/*
 * Cloud Translation API
 * Integrates text translation into your website or application.
 *
 * The version of the OpenAPI document: v3beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.TranslateTextGlossaryConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request message for synchronous translation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:18:25.577525-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TranslateTextRequest {
  public static final String SERIALIZED_NAME_CONTENTS = "contents";
  @SerializedName(SERIALIZED_NAME_CONTENTS)
  private List<String> contents = new ArrayList<>();

  public static final String SERIALIZED_NAME_GLOSSARY_CONFIG = "glossaryConfig";
  @SerializedName(SERIALIZED_NAME_GLOSSARY_CONFIG)
  private TranslateTextGlossaryConfig glossaryConfig;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_MODEL = "model";
  @SerializedName(SERIALIZED_NAME_MODEL)
  private String model;

  public static final String SERIALIZED_NAME_SOURCE_LANGUAGE_CODE = "sourceLanguageCode";
  @SerializedName(SERIALIZED_NAME_SOURCE_LANGUAGE_CODE)
  private String sourceLanguageCode;

  public static final String SERIALIZED_NAME_TARGET_LANGUAGE_CODE = "targetLanguageCode";
  @SerializedName(SERIALIZED_NAME_TARGET_LANGUAGE_CODE)
  private String targetLanguageCode;

  public TranslateTextRequest() {
  }

  public TranslateTextRequest contents(List<String> contents) {
    this.contents = contents;
    return this;
  }

  public TranslateTextRequest addContentsItem(String contentsItem) {
    if (this.contents == null) {
      this.contents = new ArrayList<>();
    }
    this.contents.add(contentsItem);
    return this;
  }

  /**
   * Required. The content of the input in string format. We recommend the total content be less than 30k codepoints. The max length of this field is 1024. Use BatchTranslateText for larger text.
   * @return contents
   */
  @javax.annotation.Nullable
  public List<String> getContents() {
    return contents;
  }

  public void setContents(List<String> contents) {
    this.contents = contents;
  }


  public TranslateTextRequest glossaryConfig(TranslateTextGlossaryConfig glossaryConfig) {
    this.glossaryConfig = glossaryConfig;
    return this;
  }

  /**
   * Get glossaryConfig
   * @return glossaryConfig
   */
  @javax.annotation.Nullable
  public TranslateTextGlossaryConfig getGlossaryConfig() {
    return glossaryConfig;
  }

  public void setGlossaryConfig(TranslateTextGlossaryConfig glossaryConfig) {
    this.glossaryConfig = glossaryConfig;
  }


  public TranslateTextRequest labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public TranslateTextRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. The labels with user-defined metadata for the request. Label keys and values can be no longer than 63 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter. See https://cloud.google.com/translate/docs/labels for more information.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public TranslateTextRequest mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * Optional. The format of the source text, for example, \&quot;text/html\&quot;, \&quot;text/plain\&quot;. If left blank, the MIME type defaults to \&quot;text/html\&quot;.
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public TranslateTextRequest model(String model) {
    this.model = model;
    return this;
  }

  /**
   * Optional. The &#x60;model&#x60; type requested for this translation. The format depends on model type: - AutoML Translation models: &#x60;projects/{project-number-or-id}/locations/{location-id}/models/{model-id}&#x60; - General (built-in) models: &#x60;projects/{project-number-or-id}/locations/{location-id}/models/general/nmt&#x60;, For global (non-regionalized) requests, use &#x60;location-id&#x60; &#x60;global&#x60;. For example, &#x60;projects/{project-number-or-id}/locations/global/models/general/nmt&#x60;. If not provided, the default Google model (NMT) will be used
   * @return model
   */
  @javax.annotation.Nullable
  public String getModel() {
    return model;
  }

  public void setModel(String model) {
    this.model = model;
  }


  public TranslateTextRequest sourceLanguageCode(String sourceLanguageCode) {
    this.sourceLanguageCode = sourceLanguageCode;
    return this;
  }

  /**
   * Optional. The BCP-47 language code of the input text if known, for example, \&quot;en-US\&quot; or \&quot;sr-Latn\&quot;. Supported language codes are listed in Language Support. If the source language isn&#39;t specified, the API attempts to identify the source language automatically and returns the source language within the response.
   * @return sourceLanguageCode
   */
  @javax.annotation.Nullable
  public String getSourceLanguageCode() {
    return sourceLanguageCode;
  }

  public void setSourceLanguageCode(String sourceLanguageCode) {
    this.sourceLanguageCode = sourceLanguageCode;
  }


  public TranslateTextRequest targetLanguageCode(String targetLanguageCode) {
    this.targetLanguageCode = targetLanguageCode;
    return this;
  }

  /**
   * Required. The BCP-47 language code to use for translation of the input text, set to one of the language codes listed in Language Support.
   * @return targetLanguageCode
   */
  @javax.annotation.Nullable
  public String getTargetLanguageCode() {
    return targetLanguageCode;
  }

  public void setTargetLanguageCode(String targetLanguageCode) {
    this.targetLanguageCode = targetLanguageCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TranslateTextRequest translateTextRequest = (TranslateTextRequest) o;
    return Objects.equals(this.contents, translateTextRequest.contents) &&
        Objects.equals(this.glossaryConfig, translateTextRequest.glossaryConfig) &&
        Objects.equals(this.labels, translateTextRequest.labels) &&
        Objects.equals(this.mimeType, translateTextRequest.mimeType) &&
        Objects.equals(this.model, translateTextRequest.model) &&
        Objects.equals(this.sourceLanguageCode, translateTextRequest.sourceLanguageCode) &&
        Objects.equals(this.targetLanguageCode, translateTextRequest.targetLanguageCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(contents, glossaryConfig, labels, mimeType, model, sourceLanguageCode, targetLanguageCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TranslateTextRequest {\n");
    sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
    sb.append("    glossaryConfig: ").append(toIndentedString(glossaryConfig)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    sourceLanguageCode: ").append(toIndentedString(sourceLanguageCode)).append("\n");
    sb.append("    targetLanguageCode: ").append(toIndentedString(targetLanguageCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("contents");
    openapiFields.add("glossaryConfig");
    openapiFields.add("labels");
    openapiFields.add("mimeType");
    openapiFields.add("model");
    openapiFields.add("sourceLanguageCode");
    openapiFields.add("targetLanguageCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TranslateTextRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TranslateTextRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TranslateTextRequest is not found in the empty JSON string", TranslateTextRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TranslateTextRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TranslateTextRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("contents") != null && !jsonObj.get("contents").isJsonNull() && !jsonObj.get("contents").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `contents` to be an array in the JSON string but got `%s`", jsonObj.get("contents").toString()));
      }
      // validate the optional field `glossaryConfig`
      if (jsonObj.get("glossaryConfig") != null && !jsonObj.get("glossaryConfig").isJsonNull()) {
        TranslateTextGlossaryConfig.validateJsonElement(jsonObj.get("glossaryConfig"));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("model") != null && !jsonObj.get("model").isJsonNull()) && !jsonObj.get("model").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `model` to be a primitive type in the JSON string but got `%s`", jsonObj.get("model").toString()));
      }
      if ((jsonObj.get("sourceLanguageCode") != null && !jsonObj.get("sourceLanguageCode").isJsonNull()) && !jsonObj.get("sourceLanguageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceLanguageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceLanguageCode").toString()));
      }
      if ((jsonObj.get("targetLanguageCode") != null && !jsonObj.get("targetLanguageCode").isJsonNull()) && !jsonObj.get("targetLanguageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetLanguageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("targetLanguageCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TranslateTextRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TranslateTextRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TranslateTextRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TranslateTextRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<TranslateTextRequest>() {
           @Override
           public void write(JsonWriter out, TranslateTextRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TranslateTextRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TranslateTextRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TranslateTextRequest
   * @throws IOException if the JSON string is invalid with respect to TranslateTextRequest
   */
  public static TranslateTextRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TranslateTextRequest.class);
  }

  /**
   * Convert an instance of TranslateTextRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

