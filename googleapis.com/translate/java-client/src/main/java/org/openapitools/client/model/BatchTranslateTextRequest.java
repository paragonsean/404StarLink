/*
 * Cloud Translation API
 * Integrates text translation into your website or application.
 *
 * The version of the OpenAPI document: v3beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.InputConfig;
import org.openapitools.client.model.OutputConfig;
import org.openapitools.client.model.TranslateTextGlossaryConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The batch translation request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T02:18:25.577525-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BatchTranslateTextRequest {
  public static final String SERIALIZED_NAME_GLOSSARIES = "glossaries";
  @SerializedName(SERIALIZED_NAME_GLOSSARIES)
  private Map<String, TranslateTextGlossaryConfig> glossaries = new HashMap<>();

  public static final String SERIALIZED_NAME_INPUT_CONFIGS = "inputConfigs";
  @SerializedName(SERIALIZED_NAME_INPUT_CONFIGS)
  private List<InputConfig> inputConfigs = new ArrayList<>();

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MODELS = "models";
  @SerializedName(SERIALIZED_NAME_MODELS)
  private Map<String, String> models = new HashMap<>();

  public static final String SERIALIZED_NAME_OUTPUT_CONFIG = "outputConfig";
  @SerializedName(SERIALIZED_NAME_OUTPUT_CONFIG)
  private OutputConfig outputConfig;

  public static final String SERIALIZED_NAME_SOURCE_LANGUAGE_CODE = "sourceLanguageCode";
  @SerializedName(SERIALIZED_NAME_SOURCE_LANGUAGE_CODE)
  private String sourceLanguageCode;

  public static final String SERIALIZED_NAME_TARGET_LANGUAGE_CODES = "targetLanguageCodes";
  @SerializedName(SERIALIZED_NAME_TARGET_LANGUAGE_CODES)
  private List<String> targetLanguageCodes = new ArrayList<>();

  public BatchTranslateTextRequest() {
  }

  public BatchTranslateTextRequest glossaries(Map<String, TranslateTextGlossaryConfig> glossaries) {
    this.glossaries = glossaries;
    return this;
  }

  public BatchTranslateTextRequest putGlossariesItem(String key, TranslateTextGlossaryConfig glossariesItem) {
    if (this.glossaries == null) {
      this.glossaries = new HashMap<>();
    }
    this.glossaries.put(key, glossariesItem);
    return this;
  }

  /**
   * Optional. Glossaries to be applied for translation. It&#39;s keyed by target language code.
   * @return glossaries
   */
  @javax.annotation.Nullable
  public Map<String, TranslateTextGlossaryConfig> getGlossaries() {
    return glossaries;
  }

  public void setGlossaries(Map<String, TranslateTextGlossaryConfig> glossaries) {
    this.glossaries = glossaries;
  }


  public BatchTranslateTextRequest inputConfigs(List<InputConfig> inputConfigs) {
    this.inputConfigs = inputConfigs;
    return this;
  }

  public BatchTranslateTextRequest addInputConfigsItem(InputConfig inputConfigsItem) {
    if (this.inputConfigs == null) {
      this.inputConfigs = new ArrayList<>();
    }
    this.inputConfigs.add(inputConfigsItem);
    return this;
  }

  /**
   * Required. Input configurations. The total number of files matched should be &lt;&#x3D; 100. The total content size should be &lt;&#x3D; 100M Unicode codepoints. The files must use UTF-8 encoding.
   * @return inputConfigs
   */
  @javax.annotation.Nullable
  public List<InputConfig> getInputConfigs() {
    return inputConfigs;
  }

  public void setInputConfigs(List<InputConfig> inputConfigs) {
    this.inputConfigs = inputConfigs;
  }


  public BatchTranslateTextRequest labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public BatchTranslateTextRequest putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. The labels with user-defined metadata for the request. Label keys and values can be no longer than 63 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter. See https://cloud.google.com/translate/docs/labels for more information.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public BatchTranslateTextRequest models(Map<String, String> models) {
    this.models = models;
    return this;
  }

  public BatchTranslateTextRequest putModelsItem(String key, String modelsItem) {
    if (this.models == null) {
      this.models = new HashMap<>();
    }
    this.models.put(key, modelsItem);
    return this;
  }

  /**
   * Optional. The models to use for translation. Map&#39;s key is target language code. Map&#39;s value is model name. Value can be a built-in general model, or an AutoML Translation model. The value format depends on model type: - AutoML Translation models: &#x60;projects/{project-number-or-id}/locations/{location-id}/models/{model-id}&#x60; - General (built-in) models: &#x60;projects/{project-number-or-id}/locations/{location-id}/models/general/nmt&#x60;, If the map is empty or a specific model is not requested for a language pair, then default google model (nmt) is used.
   * @return models
   */
  @javax.annotation.Nullable
  public Map<String, String> getModels() {
    return models;
  }

  public void setModels(Map<String, String> models) {
    this.models = models;
  }


  public BatchTranslateTextRequest outputConfig(OutputConfig outputConfig) {
    this.outputConfig = outputConfig;
    return this;
  }

  /**
   * Get outputConfig
   * @return outputConfig
   */
  @javax.annotation.Nullable
  public OutputConfig getOutputConfig() {
    return outputConfig;
  }

  public void setOutputConfig(OutputConfig outputConfig) {
    this.outputConfig = outputConfig;
  }


  public BatchTranslateTextRequest sourceLanguageCode(String sourceLanguageCode) {
    this.sourceLanguageCode = sourceLanguageCode;
    return this;
  }

  /**
   * Required. Source language code.
   * @return sourceLanguageCode
   */
  @javax.annotation.Nullable
  public String getSourceLanguageCode() {
    return sourceLanguageCode;
  }

  public void setSourceLanguageCode(String sourceLanguageCode) {
    this.sourceLanguageCode = sourceLanguageCode;
  }


  public BatchTranslateTextRequest targetLanguageCodes(List<String> targetLanguageCodes) {
    this.targetLanguageCodes = targetLanguageCodes;
    return this;
  }

  public BatchTranslateTextRequest addTargetLanguageCodesItem(String targetLanguageCodesItem) {
    if (this.targetLanguageCodes == null) {
      this.targetLanguageCodes = new ArrayList<>();
    }
    this.targetLanguageCodes.add(targetLanguageCodesItem);
    return this;
  }

  /**
   * Required. Specify up to 10 language codes here.
   * @return targetLanguageCodes
   */
  @javax.annotation.Nullable
  public List<String> getTargetLanguageCodes() {
    return targetLanguageCodes;
  }

  public void setTargetLanguageCodes(List<String> targetLanguageCodes) {
    this.targetLanguageCodes = targetLanguageCodes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchTranslateTextRequest batchTranslateTextRequest = (BatchTranslateTextRequest) o;
    return Objects.equals(this.glossaries, batchTranslateTextRequest.glossaries) &&
        Objects.equals(this.inputConfigs, batchTranslateTextRequest.inputConfigs) &&
        Objects.equals(this.labels, batchTranslateTextRequest.labels) &&
        Objects.equals(this.models, batchTranslateTextRequest.models) &&
        Objects.equals(this.outputConfig, batchTranslateTextRequest.outputConfig) &&
        Objects.equals(this.sourceLanguageCode, batchTranslateTextRequest.sourceLanguageCode) &&
        Objects.equals(this.targetLanguageCodes, batchTranslateTextRequest.targetLanguageCodes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(glossaries, inputConfigs, labels, models, outputConfig, sourceLanguageCode, targetLanguageCodes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchTranslateTextRequest {\n");
    sb.append("    glossaries: ").append(toIndentedString(glossaries)).append("\n");
    sb.append("    inputConfigs: ").append(toIndentedString(inputConfigs)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    models: ").append(toIndentedString(models)).append("\n");
    sb.append("    outputConfig: ").append(toIndentedString(outputConfig)).append("\n");
    sb.append("    sourceLanguageCode: ").append(toIndentedString(sourceLanguageCode)).append("\n");
    sb.append("    targetLanguageCodes: ").append(toIndentedString(targetLanguageCodes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("glossaries");
    openapiFields.add("inputConfigs");
    openapiFields.add("labels");
    openapiFields.add("models");
    openapiFields.add("outputConfig");
    openapiFields.add("sourceLanguageCode");
    openapiFields.add("targetLanguageCodes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchTranslateTextRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchTranslateTextRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchTranslateTextRequest is not found in the empty JSON string", BatchTranslateTextRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchTranslateTextRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchTranslateTextRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("inputConfigs") != null && !jsonObj.get("inputConfigs").isJsonNull()) {
        JsonArray jsonArrayinputConfigs = jsonObj.getAsJsonArray("inputConfigs");
        if (jsonArrayinputConfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inputConfigs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inputConfigs` to be an array in the JSON string but got `%s`", jsonObj.get("inputConfigs").toString()));
          }

          // validate the optional field `inputConfigs` (array)
          for (int i = 0; i < jsonArrayinputConfigs.size(); i++) {
            InputConfig.validateJsonElement(jsonArrayinputConfigs.get(i));
          };
        }
      }
      // validate the optional field `outputConfig`
      if (jsonObj.get("outputConfig") != null && !jsonObj.get("outputConfig").isJsonNull()) {
        OutputConfig.validateJsonElement(jsonObj.get("outputConfig"));
      }
      if ((jsonObj.get("sourceLanguageCode") != null && !jsonObj.get("sourceLanguageCode").isJsonNull()) && !jsonObj.get("sourceLanguageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceLanguageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceLanguageCode").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("targetLanguageCodes") != null && !jsonObj.get("targetLanguageCodes").isJsonNull() && !jsonObj.get("targetLanguageCodes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetLanguageCodes` to be an array in the JSON string but got `%s`", jsonObj.get("targetLanguageCodes").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchTranslateTextRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchTranslateTextRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchTranslateTextRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchTranslateTextRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchTranslateTextRequest>() {
           @Override
           public void write(JsonWriter out, BatchTranslateTextRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchTranslateTextRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchTranslateTextRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchTranslateTextRequest
   * @throws IOException if the JSON string is invalid with respect to BatchTranslateTextRequest
   */
  public static BatchTranslateTextRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchTranslateTextRequest.class);
  }

  /**
   * Convert an instance of BatchTranslateTextRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

