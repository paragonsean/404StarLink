/*
 * AWS SecurityHub
 * <p>Security Hub provides you with a comprehensive view of the security state of your Amazon Web Services environment and resources. It also provides you with the readiness status of your environment based on controls from supported security standards. Security Hub collects security data from Amazon Web Services accounts, services, and integrated third-party products and helps you analyze security trends in your environment to identify the highest priority security issues. For more information about Security Hub, see the <a href=\"https://docs.aws.amazon.com/securityhub/latest/userguide/what-is-securityhub.html\">Security HubUser Guide</a>.</p> <p>When you use operations in the Security Hub API, the requests are executed only in the Amazon Web Services Region that is currently active or in the specific Amazon Web Services Region that you specify in your request. Any configuration or settings change that results from the operation is applied only to that Region. To make the same change in other Regions, run the same command for each Region in which you want to apply the change.</p> <p>For example, if your Region is set to <code>us-west-2</code>, when you use <code>CreateMembers</code> to add a member account to Security Hub, the association of the member account with the administrator account is created only in the <code>us-west-2</code> Region. Security Hub must be enabled for the member account in the same Region that the invitation was sent from.</p> <p>The following throttling limits apply to using Security Hub API operations.</p> <ul> <li> <p> <code>BatchEnableStandards</code> - <code>RateLimit</code> of 1 request per second. <code>BurstLimit</code> of 1 request per second.</p> </li> <li> <p> <code>GetFindings</code> - <code>RateLimit</code> of 3 requests per second. <code>BurstLimit</code> of 6 requests per second.</p> </li> <li> <p> <code>BatchImportFindings</code> - <code>RateLimit</code> of 10 requests per second. <code>BurstLimit</code> of 30 requests per second.</p> </li> <li> <p> <code>BatchUpdateFindings</code> - <code>RateLimit</code> of 10 requests per second. <code>BurstLimit</code> of 30 requests per second.</p> </li> <li> <p> <code>UpdateStandardsControl</code> - <code>RateLimit</code> of 1 request per second. <code>BurstLimit</code> of 5 requests per second.</p> </li> <li> <p>All other operations - <code>RateLimit</code> of 10 requests per second. <code>BurstLimit</code> of 30 requests per second.</p> </li> </ul>
 *
 * The version of the OpenAPI document: 2018-10-26
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information about a software package.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-11T01:57:02.717661-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SoftwarePackage {
  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_VERSION = "Version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_EPOCH = "Epoch";
  @SerializedName(SERIALIZED_NAME_EPOCH)
  private String epoch;

  public static final String SERIALIZED_NAME_RELEASE = "Release";
  @SerializedName(SERIALIZED_NAME_RELEASE)
  private String release;

  public static final String SERIALIZED_NAME_ARCHITECTURE = "Architecture";
  @SerializedName(SERIALIZED_NAME_ARCHITECTURE)
  private String architecture;

  public static final String SERIALIZED_NAME_PACKAGE_MANAGER = "PackageManager";
  @SerializedName(SERIALIZED_NAME_PACKAGE_MANAGER)
  private String packageManager;

  public static final String SERIALIZED_NAME_FILE_PATH = "FilePath";
  @SerializedName(SERIALIZED_NAME_FILE_PATH)
  private String filePath;

  public static final String SERIALIZED_NAME_FIXED_IN_VERSION = "FixedInVersion";
  @SerializedName(SERIALIZED_NAME_FIXED_IN_VERSION)
  private String fixedInVersion;

  public static final String SERIALIZED_NAME_REMEDIATION = "Remediation";
  @SerializedName(SERIALIZED_NAME_REMEDIATION)
  private String remediation;

  public static final String SERIALIZED_NAME_SOURCE_LAYER_HASH = "SourceLayerHash";
  @SerializedName(SERIALIZED_NAME_SOURCE_LAYER_HASH)
  private String sourceLayerHash;

  public static final String SERIALIZED_NAME_SOURCE_LAYER_ARN = "SourceLayerArn";
  @SerializedName(SERIALIZED_NAME_SOURCE_LAYER_ARN)
  private String sourceLayerArn;

  public SoftwarePackage() {
  }

  public SoftwarePackage name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public SoftwarePackage version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Get version
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public SoftwarePackage epoch(String epoch) {
    this.epoch = epoch;
    return this;
  }

  /**
   * Get epoch
   * @return epoch
   */
  @javax.annotation.Nullable
  public String getEpoch() {
    return epoch;
  }

  public void setEpoch(String epoch) {
    this.epoch = epoch;
  }


  public SoftwarePackage release(String release) {
    this.release = release;
    return this;
  }

  /**
   * Get release
   * @return release
   */
  @javax.annotation.Nullable
  public String getRelease() {
    return release;
  }

  public void setRelease(String release) {
    this.release = release;
  }


  public SoftwarePackage architecture(String architecture) {
    this.architecture = architecture;
    return this;
  }

  /**
   * Get architecture
   * @return architecture
   */
  @javax.annotation.Nullable
  public String getArchitecture() {
    return architecture;
  }

  public void setArchitecture(String architecture) {
    this.architecture = architecture;
  }


  public SoftwarePackage packageManager(String packageManager) {
    this.packageManager = packageManager;
    return this;
  }

  /**
   * Get packageManager
   * @return packageManager
   */
  @javax.annotation.Nullable
  public String getPackageManager() {
    return packageManager;
  }

  public void setPackageManager(String packageManager) {
    this.packageManager = packageManager;
  }


  public SoftwarePackage filePath(String filePath) {
    this.filePath = filePath;
    return this;
  }

  /**
   * Get filePath
   * @return filePath
   */
  @javax.annotation.Nullable
  public String getFilePath() {
    return filePath;
  }

  public void setFilePath(String filePath) {
    this.filePath = filePath;
  }


  public SoftwarePackage fixedInVersion(String fixedInVersion) {
    this.fixedInVersion = fixedInVersion;
    return this;
  }

  /**
   * Get fixedInVersion
   * @return fixedInVersion
   */
  @javax.annotation.Nullable
  public String getFixedInVersion() {
    return fixedInVersion;
  }

  public void setFixedInVersion(String fixedInVersion) {
    this.fixedInVersion = fixedInVersion;
  }


  public SoftwarePackage remediation(String remediation) {
    this.remediation = remediation;
    return this;
  }

  /**
   * Get remediation
   * @return remediation
   */
  @javax.annotation.Nullable
  public String getRemediation() {
    return remediation;
  }

  public void setRemediation(String remediation) {
    this.remediation = remediation;
  }


  public SoftwarePackage sourceLayerHash(String sourceLayerHash) {
    this.sourceLayerHash = sourceLayerHash;
    return this;
  }

  /**
   * Get sourceLayerHash
   * @return sourceLayerHash
   */
  @javax.annotation.Nullable
  public String getSourceLayerHash() {
    return sourceLayerHash;
  }

  public void setSourceLayerHash(String sourceLayerHash) {
    this.sourceLayerHash = sourceLayerHash;
  }


  public SoftwarePackage sourceLayerArn(String sourceLayerArn) {
    this.sourceLayerArn = sourceLayerArn;
    return this;
  }

  /**
   * Get sourceLayerArn
   * @return sourceLayerArn
   */
  @javax.annotation.Nullable
  public String getSourceLayerArn() {
    return sourceLayerArn;
  }

  public void setSourceLayerArn(String sourceLayerArn) {
    this.sourceLayerArn = sourceLayerArn;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SoftwarePackage softwarePackage = (SoftwarePackage) o;
    return Objects.equals(this.name, softwarePackage.name) &&
        Objects.equals(this.version, softwarePackage.version) &&
        Objects.equals(this.epoch, softwarePackage.epoch) &&
        Objects.equals(this.release, softwarePackage.release) &&
        Objects.equals(this.architecture, softwarePackage.architecture) &&
        Objects.equals(this.packageManager, softwarePackage.packageManager) &&
        Objects.equals(this.filePath, softwarePackage.filePath) &&
        Objects.equals(this.fixedInVersion, softwarePackage.fixedInVersion) &&
        Objects.equals(this.remediation, softwarePackage.remediation) &&
        Objects.equals(this.sourceLayerHash, softwarePackage.sourceLayerHash) &&
        Objects.equals(this.sourceLayerArn, softwarePackage.sourceLayerArn);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, version, epoch, release, architecture, packageManager, filePath, fixedInVersion, remediation, sourceLayerHash, sourceLayerArn);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SoftwarePackage {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    epoch: ").append(toIndentedString(epoch)).append("\n");
    sb.append("    release: ").append(toIndentedString(release)).append("\n");
    sb.append("    architecture: ").append(toIndentedString(architecture)).append("\n");
    sb.append("    packageManager: ").append(toIndentedString(packageManager)).append("\n");
    sb.append("    filePath: ").append(toIndentedString(filePath)).append("\n");
    sb.append("    fixedInVersion: ").append(toIndentedString(fixedInVersion)).append("\n");
    sb.append("    remediation: ").append(toIndentedString(remediation)).append("\n");
    sb.append("    sourceLayerHash: ").append(toIndentedString(sourceLayerHash)).append("\n");
    sb.append("    sourceLayerArn: ").append(toIndentedString(sourceLayerArn)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Name");
    openapiFields.add("Version");
    openapiFields.add("Epoch");
    openapiFields.add("Release");
    openapiFields.add("Architecture");
    openapiFields.add("PackageManager");
    openapiFields.add("FilePath");
    openapiFields.add("FixedInVersion");
    openapiFields.add("Remediation");
    openapiFields.add("SourceLayerHash");
    openapiFields.add("SourceLayerArn");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SoftwarePackage
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SoftwarePackage.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SoftwarePackage is not found in the empty JSON string", SoftwarePackage.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SoftwarePackage.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SoftwarePackage` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Name`
      if (jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Name"));
      }
      // validate the optional field `Version`
      if (jsonObj.get("Version") != null && !jsonObj.get("Version").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Version"));
      }
      // validate the optional field `Epoch`
      if (jsonObj.get("Epoch") != null && !jsonObj.get("Epoch").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Epoch"));
      }
      // validate the optional field `Release`
      if (jsonObj.get("Release") != null && !jsonObj.get("Release").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Release"));
      }
      // validate the optional field `Architecture`
      if (jsonObj.get("Architecture") != null && !jsonObj.get("Architecture").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Architecture"));
      }
      // validate the optional field `PackageManager`
      if (jsonObj.get("PackageManager") != null && !jsonObj.get("PackageManager").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("PackageManager"));
      }
      // validate the optional field `FilePath`
      if (jsonObj.get("FilePath") != null && !jsonObj.get("FilePath").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("FilePath"));
      }
      // validate the optional field `FixedInVersion`
      if (jsonObj.get("FixedInVersion") != null && !jsonObj.get("FixedInVersion").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("FixedInVersion"));
      }
      // validate the optional field `Remediation`
      if (jsonObj.get("Remediation") != null && !jsonObj.get("Remediation").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("Remediation"));
      }
      // validate the optional field `SourceLayerHash`
      if (jsonObj.get("SourceLayerHash") != null && !jsonObj.get("SourceLayerHash").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("SourceLayerHash"));
      }
      // validate the optional field `SourceLayerArn`
      if (jsonObj.get("SourceLayerArn") != null && !jsonObj.get("SourceLayerArn").isJsonNull()) {
        String.validateJsonElement(jsonObj.get("SourceLayerArn"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SoftwarePackage.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SoftwarePackage' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SoftwarePackage> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SoftwarePackage.class));

       return (TypeAdapter<T>) new TypeAdapter<SoftwarePackage>() {
           @Override
           public void write(JsonWriter out, SoftwarePackage value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SoftwarePackage read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SoftwarePackage given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SoftwarePackage
   * @throws IOException if the JSON string is invalid with respect to SoftwarePackage
   */
  public static SoftwarePackage fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SoftwarePackage.class);
  }

  /**
   * Convert an instance of SoftwarePackage to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

